---
phase: 15-conversational-reanalysis
plan: 04
type: execute
wave: 3
depends_on: ["15-01", "15-02", "15-03"]
files_modified:
  - bot/handlers/context_input.py
  - bot/handlers/leads.py
  - data/pipelines/reanalysis.yaml
  - packages/webapp/src/features/leads/components/ActivityTimeline.tsx
autonomous: true

must_haves:
  truths:
    - "User can trigger re-analysis via button after adding context"
    - "Re-analysis produces updated strategy with changes summary displayed first"
    - "After re-analysis, user is asked 'Update engagement plan too?'"
    - "Analysis version is saved to lead_analysis_history"
    - "Re-analysis entry appears in activity timeline"
  artifacts:
    - path: "data/pipelines/reanalysis.yaml"
      provides: "Pipeline configuration for re-analysis flow"
      contains: "reanalysis_strategist"
    - path: "bot/handlers/context_input.py"
      provides: "Re-analysis trigger and plan update handlers"
      contains: "on_reanalyze_start"
  key_links:
    - from: "bot/handlers/context_input.py"
      to: "bot/agents/reanalysis_strategist.py"
      via: "pipeline execution"
      pattern: "reanalysis_strategist"
    - from: "bot/handlers/context_input.py"
      to: "bot/storage/repositories.py"
      via: "LeadAnalysisHistoryRepo save_version"
      pattern: "history_repo\\.save_version"
---

<objective>
Wire the re-analysis trigger to execute the ReanalysisStrategistAgent, save history, update the lead, and optionally regenerate the engagement plan.

Purpose: REANA-V20-05 (re-analyze trigger) needs the full flow from button tap to updated lead with history saved. This plan completes the re-analysis feature.
Output: Pipeline config, trigger handlers, plan update flow, TMA activity display updates.
</objective>

<execution_context>
@/Users/dmytrolevin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dmytrolevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-conversational-reanalysis/15-CONTEXT.md

# Prior plan outputs
@.planning/phases/15-conversational-reanalysis/15-01-PLAN.md
@.planning/phases/15-conversational-reanalysis/15-02-PLAN.md
@.planning/phases/15-conversational-reanalysis/15-03-PLAN.md

# Existing patterns
@bot/handlers/support.py
@data/pipelines/support.yaml
@packages/webapp/src/features/leads/components/ActivityTimeline.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create reanalysis.yaml pipeline config</name>
  <files>data/pipelines/reanalysis.yaml</files>
  <action>
Create the pipeline configuration for re-analysis. This is a simple sequential pipeline:
1. reanalysis_strategist (the new agent)
2. memory (optional, to update user memory with deal evolution)

```yaml
# Re-analysis Pipeline
# Triggered when user adds context to a lead and requests strategy re-analysis

name: reanalysis
description: Re-analyze a lead's strategy with new context

steps:
  - name: reanalysis_strategist
    agent: reanalysis_strategist
    mode: sequential
    input_mapping:
      user_message: "Re-analyze this lead with the new context"

  - name: memory
    agent: memory
    mode: background
    input_mapping:
      pipeline_result: "@reanalysis_strategist"
```
  </action>
  <verify>File exists at data/pipelines/reanalysis.yaml with reanalysis_strategist step</verify>
  <done>Pipeline config created for re-analysis flow</done>
</task>

<task type="auto">
  <name>Task 2: Add re-analysis trigger handlers to context_input.py</name>
  <files>bot/handlers/context_input.py</files>
  <action>
Add the handlers for:
1. `reanalyze:start:{lead_id}` ‚Äî Trigger re-analysis
2. `reanalyze:plan:{lead_id}` ‚Äî Update engagement plan after re-analysis
3. `reanalyze:noplan:{lead_id}` ‚Äî Skip plan update

Add necessary imports at the top:
```python
import json
from bot.pipeline.runner import PipelineRunner
from bot.pipeline.context import PipelineContext
from bot.services.llm_router import get_llm_for_user
from bot.services.knowledge import get_knowledge_base
from bot.storage.repositories import LeadAnalysisHistoryRepo
```

Add the handlers:

```python
# ‚îÄ‚îÄ‚îÄ Re-analysis Execution ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

@router.callback_query(F.data.startswith("reanalyze:start:"))
async def on_reanalyze_start(
    callback: CallbackQuery,
    state: FSMContext,
    lead_repo: LeadRegistryRepo,
    activity_repo: LeadActivityRepo,
    history_repo: LeadAnalysisHistoryRepo,
    user_repo: UserRepo,
    openrouter_api_key: str = "",
) -> None:
    """Execute re-analysis on a lead with accumulated context."""
    lead_id = int(callback.data.split(":")[2])  # type: ignore[union-attr]
    tg_id = callback.from_user.id

    lead = await lead_repo.get_by_id(lead_id)
    if not lead:
        await callback.answer("Lead not found.")
        return

    await callback.answer("üîÑ Re-analyzing strategy...")

    # Get state data (context items collected)
    data = await state.get_data()
    context_items = data.get("context_items", [])

    # Load recent activities for this lead
    recent_activities = await activity_repo.get_for_lead(lead_id, limit=10)
    new_context_items = [
        {
            "activity_type": a.activity_type,
            "content": a.content,
            "created_at": a.created_at,
            "metadata": a.metadata,
        }
        for a in recent_activities
        if a.activity_type in ("prospect_response", "meeting_notes", "context_update")
    ][:5]  # Last 5 relevant activities

    # Build prior analysis from lead fields
    prior_analysis = {}
    try:
        if lead.prospect_analysis:
            prior_analysis["analysis"] = json.loads(lead.prospect_analysis) if lead.prospect_analysis.startswith("{") else {"raw": lead.prospect_analysis}
        if lead.closing_strategy:
            prior_analysis["strategy"] = json.loads(lead.closing_strategy) if lead.closing_strategy.startswith("{") else {"raw": lead.closing_strategy}
        if lead.engagement_tactics:
            prior_analysis["engagement_tactics"] = json.loads(lead.engagement_tactics) if lead.engagement_tactics.startswith("{") else {"raw": lead.engagement_tactics}
    except (json.JSONDecodeError, TypeError):
        pass

    # Build lead info
    lead_info = {
        "name": _lead_display_name(lead),
        "company": lead.prospect_company,
        "title": lead.prospect_title,
        "geography": lead.prospect_geography,
    }

    # Get LLM and knowledge base
    user = await user_repo.get_by_telegram_id(tg_id)
    llm = await get_llm_for_user(user, openrouter_api_key)
    knowledge_base = await get_knowledge_base()

    # Build pipeline context
    from bot.agents.reanalysis_strategist import ReanalysisStrategistAgent
    from bot.agents.base import AgentInput

    agent = ReanalysisStrategistAgent()

    # Create a simple pipeline context
    class SimplePipelineCtx:
        def __init__(self, llm, kb, memory):
            self.llm = llm
            self.knowledge_base = kb
            self.user_memory = memory
            self.image_b64 = None

        def get_result(self, name):
            return None

    # Load user memory
    from bot.storage.repositories import UserMemoryRepo
    from bot.storage.insforge_client import InsForgeClient
    from bot.config import settings

    client = InsForgeClient(settings.insforge_url, settings.insforge_service_key)
    memory_repo = UserMemoryRepo(client)
    user_memory_model = await memory_repo.get(tg_id)
    user_memory = user_memory_model.memory_data if user_memory_model else {}

    pipeline_ctx = SimplePipelineCtx(llm, knowledge_base, user_memory)

    # Run the agent
    agent_input = AgentInput(
        user_message="Re-analyze this lead with new context",
        context={
            "prior_analysis": prior_analysis,
            "new_context_items": new_context_items,
            "lead_info": lead_info,
        },
    )

    status_msg = await callback.message.reply(  # type: ignore[union-attr]
        "üîÑ *Re-analyzing strategy...*\n\n"
        "Reviewing new context and updating analysis.",
        parse_mode="Markdown",
    )

    result = await agent.run(agent_input, pipeline_ctx)

    if not result.success:
        await status_msg.edit_text(
            f"‚ùå Re-analysis failed: {result.error[:200] if result.error else 'Unknown error'}"
        )
        await state.clear()
        return

    # Parse result
    result_data = result.data or {}
    changes_summary = result_data.get("changes_summary", {})
    updated_analysis = result_data.get("updated_analysis", {})
    updated_strategy = result_data.get("updated_strategy", {})
    updated_tactics = result_data.get("updated_engagement_tactics", {})
    updated_draft = result_data.get("updated_draft", {})
    field_diff = result_data.get("field_diff", {})
    recommended_action = result_data.get("recommended_next_action", "")

    # Save to lead_analysis_history
    analysis_snapshot = {
        "analysis": updated_analysis,
        "strategy": updated_strategy,
        "engagement_tactics": updated_tactics,
        "draft": updated_draft,
    }

    headline = changes_summary.get("headline", "Strategy updated")
    details = changes_summary.get("details", [])
    narrative = f"{headline}\n" + "\n".join(f"‚Ä¢ {d}" for d in details[:5])

    # Find triggering activity ID (most recent)
    triggering_id = None
    if context_items:
        triggering_id = context_items[-1].get("activity_id")

    await history_repo.save_version(
        lead_id=lead_id,
        telegram_id=tg_id,
        analysis_snapshot=analysis_snapshot,
        changes_summary=narrative,
        field_diff=field_diff,
        triggered_by="context_update",
        triggering_activity_id=triggering_id,
    )

    # Update lead with new analysis
    updates = {}
    if updated_analysis:
        updates["prospect_analysis"] = json.dumps(updated_analysis)
    if updated_strategy:
        updates["closing_strategy"] = json.dumps(updated_strategy)
    if updated_tactics:
        updates["engagement_tactics"] = json.dumps(updated_tactics)
    if updated_draft:
        updates["draft_response"] = json.dumps(updated_draft)

    # Remove pending re-analysis note
    if lead.notes and "[Pending re-analysis]" in lead.notes:
        updates["notes"] = lead.notes.replace("[Pending re-analysis]", "").strip()

    if updates:
        await lead_repo.update_lead(lead_id, **updates)

    # Log re-analysis activity
    await activity_repo.create(
        LeadActivityModel(
            lead_id=lead_id,
            telegram_id=tg_id,
            activity_type="re_analysis",
            content=narrative[:1000],
            metadata={
                "headline": headline,
                "changes_count": len(details),
                "has_field_diff": bool(field_diff),
            },
        )
    )

    # Format response with changes summary first
    name = _sanitize(_lead_display_name(lead))
    response = f"üîÑ *Strategy Re-analyzed ‚Äî {name}*\n\n"
    response += f"üìä *WHAT CHANGED*\n"
    response += f"_{_sanitize(headline)}_\n\n"

    if details:
        for detail in details[:5]:
            response += f"‚Ä¢ {_sanitize(detail)}\n"
        response += "\n"

    if recommended_action:
        response += f"üéØ *Next Action:* {_sanitize(recommended_action)}\n\n"

    # Store for plan update decision
    await state.update_data(
        reanalysis_result=result_data,
        reanalysis_lead_id=lead_id,
    )
    await state.set_state(ReanalysisState.updating_plan)

    await status_msg.edit_text(
        truncate_message(response) +
        "\nWould you like me to update the engagement plan based on this new analysis?",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [
                InlineKeyboardButton(
                    text="üìã Yes, Update Plan",
                    callback_data=f"reanalyze:plan:{lead_id}",
                ),
                InlineKeyboardButton(
                    text="‚è≠ No, Keep Current",
                    callback_data=f"reanalyze:noplan:{lead_id}",
                ),
            ],
            [
                InlineKeyboardButton(
                    text="üìã View Lead",
                    callback_data=f"lead:view:{lead_id}",
                ),
            ],
        ]),
    )


@router.callback_query(F.data.startswith("reanalyze:plan:"))
async def on_reanalyze_update_plan(
    callback: CallbackQuery,
    state: FSMContext,
    lead_repo: LeadRegistryRepo,
    reminder_repo: ScheduledReminderRepo,
) -> None:
    """Regenerate engagement plan after re-analysis."""
    lead_id = int(callback.data.split(":")[2])  # type: ignore[union-attr]

    lead = await lead_repo.get_by_id(lead_id)
    if not lead:
        await callback.answer("Lead not found.")
        await state.clear()
        return

    await callback.answer("üìã Updating engagement plan...")

    # For now, we'll clear the old plan and let the scheduler regenerate
    # In a full implementation, we'd call a plan generation agent here
    # This is a simplification that works with the existing flow

    # Cancel existing pending reminders
    await reminder_repo.cancel_pending_for_lead(lead_id)

    # Mark that plan needs regeneration (via notes or a flag)
    current_notes = lead.notes or ""
    if "[Plan update pending]" not in current_notes:
        new_notes = f"[Plan update pending] {current_notes}".strip()
        await lead_repo.update_lead(lead_id, notes=new_notes[:1000])

    name = _sanitize(_lead_display_name(lead))
    await callback.message.edit_text(  # type: ignore[union-attr]
        f"‚úÖ *Engagement plan will be updated for {name}*\n\n"
        f"The old plan has been cleared. A new plan will be generated "
        f"based on the updated analysis.\n\n"
        f"Use /leads to view the lead and check back for the new plan.",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="üìã View Lead", callback_data=f"lead:view:{lead_id}")],
        ]),
    )
    await state.clear()


@router.callback_query(F.data.startswith("reanalyze:noplan:"))
async def on_reanalyze_skip_plan(
    callback: CallbackQuery,
    state: FSMContext,
    lead_repo: LeadRegistryRepo,
) -> None:
    """Keep existing engagement plan after re-analysis."""
    lead_id = int(callback.data.split(":")[2])  # type: ignore[union-attr]

    lead = await lead_repo.get_by_id(lead_id)
    name = _sanitize(_lead_display_name(lead)) if lead else f"Lead #{lead_id}"

    await callback.message.edit_text(  # type: ignore[union-attr]
        f"‚úÖ *Re-analysis complete for {name}*\n\n"
        f"The strategy has been updated. The existing engagement plan "
        f"has been kept as-is.\n\n"
        f"Use /leads to view the updated lead.",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="üìã View Lead", callback_data=f"lead:view:{lead_id}")],
        ]),
    )
    await state.clear()
    await callback.answer()
```

Also add the missing import at the top of the file:
```python
from bot.storage.repositories import ScheduledReminderRepo
```

And add `ScheduledReminderRepo` to the DI parameters where needed.
  </action>
  <verify>grep for "on_reanalyze_start" and "reanalyze:plan" in bot/handlers/context_input.py</verify>
  <done>Re-analysis trigger handlers implemented with history saving and plan update flow</done>
</task>

<task type="auto">
  <name>Task 3: Update leads.py to show re-analyze button for pending leads</name>
  <files>bot/handlers/leads.py</files>
  <action>
Update the lead detail view to show a "Re-analyze Strategy" button when a lead has pending re-analysis (indicated by "[Pending re-analysis]" in notes).

In `_lead_detail_keyboard` function, add a re-analyze button row when appropriate:

```python
def _lead_detail_keyboard(
    lead_id: int,
    current_status: str,
    has_plan: bool = False,
    has_draft: bool = False,
    has_research: bool = False,
    research_version_count: int = 0,
    has_pending_reanalysis: bool = False,  # ADD THIS PARAMETER
) -> InlineKeyboardMarkup:
    """Build expanded lead detail keyboard with engagement actions."""
    buttons = []

    # Pending re-analysis row (if applicable)
    if has_pending_reanalysis:
        buttons.append([
            InlineKeyboardButton(
                text="üîÑ Re-analyze Strategy (Pending)",
                callback_data=f"reanalyze:start:{lead_id}",
            ),
        ])

    # ... rest of the existing buttons
```

Update `on_lead_view` to pass this parameter:

```python
has_pending_reanalysis = bool(lead.notes and "[Pending re-analysis]" in lead.notes)

await callback.message.edit_text(
    truncate_message(text),
    parse_mode="Markdown",
    reply_markup=_lead_detail_keyboard(
        lead_id, lead.status, has_plan, has_draft, has_research, research_version_count,
        has_pending_reanalysis,  # ADD THIS
    ),
    disable_web_page_preview=True,
)
```

Also update the "Add Update" button callback to use the context_input flow:
Change from `lead:context:{lead_id}` to `context:add:{lead_id}` (if not already).

This ensures the context input flow from Plan 02 is used.
  </action>
  <verify>grep for "has_pending_reanalysis" and "reanalyze:start" in bot/handlers/leads.py</verify>
  <done>Lead detail shows re-analyze button for pending re-analysis leads</done>
</task>

<task type="auto">
  <name>Task 4: Update TMA ActivityTimeline for new activity types</name>
  <files>packages/webapp/src/features/leads/components/ActivityTimeline.tsx</files>
  <action>
Update the ActivityTimeline component to display the new activity types with appropriate icons and formatting:
- `prospect_response` ‚Äî Show with a message/reply icon
- `meeting_notes` ‚Äî Show with a notes/clipboard icon
- `re_analysis` ‚Äî Show with a refresh/analysis icon

Find the part of the component that maps activity_type to display format and add cases for the new types.

Look for an icon mapping or switch statement like:
```typescript
const getActivityIcon = (type: string) => {
  switch (type) {
    case 'context_update':
      return 'üìù';
    // ... existing cases
  }
};
```

Add:
```typescript
case 'prospect_response':
  return 'üí¨';  // Speech bubble for prospect messages
case 'meeting_notes':
  return 'üìã';  // Clipboard for meeting notes
case 're_analysis':
  return 'üîÑ';  // Refresh for re-analysis
```

Also update any activity type label mapping:
```typescript
case 'prospect_response':
  return 'Prospect Response';
case 'meeting_notes':
  return 'Meeting Notes';
case 're_analysis':
  return 'Strategy Re-analyzed';
```

If the component shows expandable content, ensure re_analysis entries show the changes summary from metadata:
```typescript
if (activity.activity_type === 're_analysis' && activity.metadata?.headline) {
  // Show the headline prominently
}
```
  </action>
  <verify>grep for "prospect_response" and "re_analysis" in packages/webapp/src/features/leads/components/ActivityTimeline.tsx</verify>
  <done>TMA ActivityTimeline displays new activity types with appropriate icons and labels</done>
</task>

</tasks>

<verification>
1. Pipeline config: `ls data/pipelines/reanalysis.yaml`
2. Trigger handlers: `grep -E "(on_reanalyze_start|reanalyze:plan)" bot/handlers/context_input.py`
3. History saving: `grep "history_repo.save_version" bot/handlers/context_input.py`
4. Lead detail button: `grep "has_pending_reanalysis" bot/handlers/leads.py`
5. TMA types: `grep -E "(prospect_response|re_analysis)" packages/webapp/src/features/leads/components/ActivityTimeline.tsx`
</verification>

<success_criteria>
- reanalysis.yaml pipeline config exists
- "Re-analyze Strategy?" button triggers on_reanalyze_start handler
- Re-analysis calls ReanalysisStrategistAgent and parses result
- Changes summary is displayed first in response
- Analysis version is saved to lead_analysis_history via repo
- "Update engagement plan too?" prompt appears after re-analysis
- Yes/No buttons trigger plan update or skip
- re_analysis activity is logged with metadata
- TMA ActivityTimeline shows prospect_response, meeting_notes, re_analysis with icons
- Leads with "[Pending re-analysis]" note show re-analyze button
</success_criteria>

<output>
After completion, create `.planning/phases/15-conversational-reanalysis/15-04-SUMMARY.md`
</output>
