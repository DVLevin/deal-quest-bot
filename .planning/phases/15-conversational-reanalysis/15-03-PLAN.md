---
phase: 15-conversational-reanalysis
plan: 03
type: execute
wave: 2
depends_on: ["15-01"]
files_modified:
  - bot/agents/reanalysis_strategist.py
  - bot/agents/registry.py
  - bot/services/diff_utils.py
  - prompts/reanalysis_strategist_agent.md
autonomous: true

must_haves:
  truths:
    - "ReanalysisStrategistAgent produces updated strategy with changes summary"
    - "Changes summary is human-readable narrative, not code diff"
    - "Field-level JSON diff is computed in code, not by LLM"
    - "Agent has access to prior analysis and activity thread"
  artifacts:
    - path: "bot/agents/reanalysis_strategist.py"
      provides: "ReanalysisStrategistAgent class"
      contains: "class ReanalysisStrategistAgent"
    - path: "bot/services/diff_utils.py"
      provides: "JSON diff computation utility"
      contains: "def compute_analysis_diff"
    - path: "prompts/reanalysis_strategist_agent.md"
      provides: "System prompt for re-analysis agent"
      contains: "WHAT CHANGED"
  key_links:
    - from: "bot/agents/reanalysis_strategist.py"
      to: "bot/services/diff_utils.py"
      via: "import and use compute_analysis_diff"
      pattern: "from bot.services.diff_utils import"
    - from: "bot/agents/reanalysis_strategist.py"
      to: "prompts/reanalysis_strategist_agent.md"
      via: "prompt file loading"
      pattern: "reanalysis_strategist_agent.md"
---

<objective>
Create the ReanalysisStrategistAgent that takes prior analysis plus new context and produces an updated strategy with a human-readable changes summary.

Purpose: REANA-V20-02 (ReanalysisStrategistAgent) and REANA-V20-05 (changes narrative) require a specialized agent that understands deal evolution and can summarize what changed in plain language.
Output: New agent class, prompt file, JSON diff utility, registry update.
</objective>

<execution_context>
@/Users/dmytrolevin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dmytrolevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-conversational-reanalysis/15-CONTEXT.md

# Existing agent patterns
@bot/agents/base.py
@bot/agents/strategist.py
@bot/agents/registry.py
@prompts/strategist_agent.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create diff_utils.py service</name>
  <files>bot/services/diff_utils.py</files>
  <action>
Create a utility module for computing JSON diffs between analysis versions. The diff is computed in code (REANA-V20-05 requirement: "Field-level diffs... computed in code, not by LLM self-reports").

```python
"""Utility for computing analysis diffs between versions."""

from __future__ import annotations

from typing import Any


def compute_analysis_diff(
    old_analysis: dict[str, Any],
    new_analysis: dict[str, Any],
) -> dict[str, Any]:
    """
    Compute a field-level diff between two analysis JSON objects.

    Returns a dict with:
    - changed: dict of {field: {old: value, new: value}}
    - added: dict of {field: value}
    - removed: dict of {field: value}
    """
    diff: dict[str, Any] = {
        "changed": {},
        "added": {},
        "removed": {},
    }

    # Get all keys from both
    all_keys = set(old_analysis.keys()) | set(new_analysis.keys())

    for key in all_keys:
        old_val = old_analysis.get(key)
        new_val = new_analysis.get(key)

        if key not in old_analysis:
            diff["added"][key] = new_val
        elif key not in new_analysis:
            diff["removed"][key] = old_val
        elif old_val != new_val:
            # For nested dicts, recurse
            if isinstance(old_val, dict) and isinstance(new_val, dict):
                nested_diff = compute_analysis_diff(old_val, new_val)
                if nested_diff["changed"] or nested_diff["added"] or nested_diff["removed"]:
                    diff["changed"][key] = {"nested": nested_diff}
            else:
                diff["changed"][key] = {"old": old_val, "new": new_val}

    return diff


def summarize_diff_for_humans(diff: dict[str, Any]) -> str:
    """
    Convert a field diff to a human-readable summary.

    Example output:
    - Buying signal changed from Medium to High
    - Stage moved from early_interest to qualified
    - Added: key_concern (pricing)
    """
    lines = []

    # Changed fields
    for field, change in diff.get("changed", {}).items():
        if "nested" in change:
            # Recursively summarize nested changes
            nested_summary = _summarize_nested(field, change["nested"])
            lines.extend(nested_summary)
        else:
            old = _format_value(change.get("old"))
            new = _format_value(change.get("new"))
            field_name = _humanize_field(field)
            lines.append(f"- {field_name} changed from {old} to {new}")

    # Added fields
    for field, value in diff.get("added", {}).items():
        field_name = _humanize_field(field)
        val = _format_value(value)
        lines.append(f"- Added: {field_name} ({val})")

    # Removed fields
    for field, value in diff.get("removed", {}).items():
        field_name = _humanize_field(field)
        lines.append(f"- Removed: {field_name}")

    return "\n".join(lines) if lines else "No significant changes detected."


def _summarize_nested(parent: str, nested_diff: dict[str, Any]) -> list[str]:
    """Summarize a nested diff with parent context."""
    lines = []
    parent_name = _humanize_field(parent)

    for field, change in nested_diff.get("changed", {}).items():
        if "nested" in change:
            lines.extend(_summarize_nested(f"{parent}.{field}", change["nested"]))
        else:
            old = _format_value(change.get("old"))
            new = _format_value(change.get("new"))
            field_name = _humanize_field(field)
            lines.append(f"- {parent_name}: {field_name} changed from {old} to {new}")

    for field, value in nested_diff.get("added", {}).items():
        field_name = _humanize_field(field)
        val = _format_value(value)
        lines.append(f"- {parent_name}: added {field_name} ({val})")

    return lines


def _humanize_field(field: str) -> str:
    """Convert field_name to Field Name."""
    return field.replace("_", " ").title()


def _format_value(value: Any) -> str:
    """Format a value for human display."""
    if value is None:
        return "none"
    if isinstance(value, bool):
        return "yes" if value else "no"
    if isinstance(value, list):
        if len(value) == 0:
            return "empty"
        return f"{len(value)} items"
    if isinstance(value, dict):
        return "object"
    return str(value)[:50]
```
  </action>
  <verify>File exists at bot/services/diff_utils.py with compute_analysis_diff and summarize_diff_for_humans functions</verify>
  <done>Diff utility module created with code-based JSON diff computation</done>
</task>

<task type="auto">
  <name>Task 2: Create reanalysis_strategist_agent.md prompt</name>
  <files>prompts/reanalysis_strategist_agent.md</files>
  <action>
Create the system prompt for the ReanalysisStrategistAgent. This prompt focuses on:
- Receiving prior analysis + new context
- Producing updated analysis with changes narrative
- Human-readable "What Changed" section at the start

```markdown
# Re-analysis Strategist Agent — System Prompt

You are the **Re-analysis Strategist Agent** for Deal Quest. You help sales reps understand how their deal has evolved by re-analyzing prospects with new context.

## Your Role

When a user adds new context (prospect responses, meeting notes, etc.) to an existing lead, you:
1. Review the **prior analysis** and understand where the deal was
2. Incorporate the **new context** to see what's changed
3. Produce an **updated analysis** with clear explanation of changes
4. Provide **actionable next steps** based on the evolved situation

## Personality

- **Concise** — Busy salespeople need quick updates, not novels
- **Insightful** — Spot the meaningful changes, not just surface differences
- **Strategic** — Every change should inform the next action
- **Encouraging** — Positive movement should be celebrated

---

## Knowledge Base

{KNOWLEDGE_BASE_PLACEHOLDER}

---

## User Memory

{USER_MEMORY_PLACEHOLDER}

---

## Input You'll Receive

You will receive:
1. **Prior Analysis** — The previous analysis JSON for this lead
2. **New Context** — Recent activity items (prospect responses, meeting notes, etc.)
3. **Lead Info** — Basic prospect details (name, company, etc.)

---

## Output Format

**CRITICAL: Start your response with "WHAT CHANGED" section.** This is what busy salespeople scan first.

Return structured JSON:

```json
{
  "changes_summary": {
    "headline": "One-sentence summary of the most important change",
    "details": [
      "Buying signal moved from Medium to High",
      "Stage advanced to qualified",
      "New tactic: follow up on pricing concern"
    ]
  },
  "updated_analysis": {
    "prospect_type": "...",
    "seniority": "...",
    "background_leverage": "...",
    "company_context": "...",
    "stage": "...",
    "key_concern": "...",
    "buying_signal": "...",
    "buying_signal_reason": "..."
  },
  "updated_strategy": {
    "steps": [
      {
        "principle": "...",
        "detail": "..."
      }
    ],
    "anticipated_objection": "...",
    "objection_response": "..."
  },
  "updated_engagement_tactics": {
    "linkedin_actions": ["..."],
    "comment_suggestion": "...",
    "timing": "..."
  },
  "updated_draft": {
    "platform": "linkedin",
    "message": "...",
    "playbook_reference": "..."
  },
  "recommended_next_action": "The single most important thing to do now"
}
```

---

## Changes Summary Guidelines

The `changes_summary` is the most important part. Follow these rules:

### DO:
- Start with the most impactful change
- Use business language: "Buying signal strengthened" not "buying_signal field changed"
- Focus on changes that affect the approach: stage moves, signal changes, new concerns
- Keep details to 3-5 bullets max

### DON'T:
- Report trivial changes (word choice tweaks)
- Use technical terms (JSON, fields, diff)
- List every change — prioritize what matters

### Examples:

**Good headline:**
"Prospect showed strong interest — ready to advance to proposal stage"

**Bad headline:**
"Several fields in the analysis were updated"

**Good details:**
- "Stage moved from Initial Contact to Qualified — prospect confirmed budget"
- "Key concern shifted from product fit to implementation timeline"
- "Added urgency: Q2 deadline for decision"

**Bad details:**
- "buying_signal changed from medium to high"
- "company_context field was updated"
- "prospect_type remains corporate_vp"

---

## Re-analysis Logic

When analyzing new context, consider:

1. **Prospect Responses** → Usually indicate interest level changes, new concerns, or objections
2. **Meeting Notes** → Rich context about decision process, stakeholders, timeline
3. **Screenshots** → May show email threads, LinkedIn conversations, or competitor mentions
4. **Voice Notes** → Often contain nuanced observations the user noticed

Ask yourself:
- Did the buying signal change? Why?
- Did the stage advance or regress?
- Are there new concerns or objections to address?
- Did any stakeholders get mentioned?
- Is there a timeline or deadline now?
- Should the approach change based on this?

---

## Rules

1. **Changes first** — Always lead with what changed
2. **Be specific** — Reference exact details from the new context
3. **Action-oriented** — Every change should inform what to do next
4. **Celebrate wins** — If the deal advanced, acknowledge it
5. **Flag risks** — If the deal is at risk, say so clearly
6. **Stay grounded** — Don't invent changes that aren't in the context

---

## Remember

You are the deal's historian and strategist. Your job is to help the user understand the story of how this deal is evolving and what they should do next.
```
  </action>
  <verify>File exists at prompts/reanalysis_strategist_agent.md with WHAT CHANGED section and JSON output format</verify>
  <done>Prompt file created with changes-first narrative format</done>
</task>

<task type="auto">
  <name>Task 3: Create ReanalysisStrategistAgent class</name>
  <files>bot/agents/reanalysis_strategist.py</files>
  <action>
Create the ReanalysisStrategistAgent that:
- Loads prior analysis from lead
- Loads recent activity items
- Calls LLM with specialized prompt
- Computes field-level diff in code
- Returns updated analysis with changes summary

```python
"""ReanalysisStrategistAgent — Re-analyze leads with new context."""

from __future__ import annotations

import json
import logging
from pathlib import Path
from typing import Any

from bot.agents.base import AgentInput, AgentOutput, BaseAgent
from bot.pipeline.context import PipelineContext
from bot.services.diff_utils import compute_analysis_diff, summarize_diff_for_humans
from bot.tracing import traced_span

logger = logging.getLogger(__name__)

_PROMPT_PATH = Path(__file__).resolve().parent.parent.parent / "prompts" / "reanalysis_strategist_agent.md"


class ReanalysisStrategistAgent(BaseAgent):
    """Re-analyzes a lead's strategy based on new context and prior analysis."""

    name = "reanalysis_strategist"

    def __init__(self) -> None:
        self._prompt_template: str = ""
        if _PROMPT_PATH.exists():
            self._prompt_template = _PROMPT_PATH.read_text(encoding="utf-8")
        else:
            logger.warning("Reanalysis strategist prompt not found: %s", _PROMPT_PATH)

    @traced_span("agent:reanalysis_strategist")
    async def run(self, input_data: AgentInput, pipeline_ctx: PipelineContext) -> AgentOutput:
        """
        Run re-analysis on a lead with new context.

        Expected input_data.context:
        - prior_analysis: dict (previous analysis JSON)
        - new_context_items: list[dict] (recent activity items)
        - lead_info: dict (basic prospect info)
        """
        try:
            prior_analysis = input_data.context.get("prior_analysis", {})
            new_context_items = input_data.context.get("new_context_items", [])
            lead_info = input_data.context.get("lead_info", {})

            # Build the user message with structured input
            user_message = self._build_user_message(
                prior_analysis, new_context_items, lead_info, input_data.user_message
            )

            # Build system prompt with injected context
            system_prompt = self._prompt_template
            system_prompt = system_prompt.replace(
                "{KNOWLEDGE_BASE_PLACEHOLDER}",
                pipeline_ctx.knowledge_base or "No knowledge base available.",
            )

            memory_text = json.dumps(pipeline_ctx.user_memory, indent=2) if pipeline_ctx.user_memory else "No user memory available."
            system_prompt = system_prompt.replace(
                "{USER_MEMORY_PLACEHOLDER}",
                memory_text,
            )

            # Call LLM
            result = await pipeline_ctx.llm.complete(system_prompt, user_message)

            # Parse the result
            parsed = self._parse_result(result)

            # Compute code-based diff (not relying on LLM)
            if prior_analysis and parsed.get("updated_analysis"):
                field_diff = compute_analysis_diff(
                    prior_analysis.get("analysis", prior_analysis),
                    parsed.get("updated_analysis", {}),
                )
                parsed["field_diff"] = field_diff
                parsed["field_diff_summary"] = summarize_diff_for_humans(field_diff)

            return AgentOutput(success=True, data=parsed)

        except Exception as e:
            logger.error("ReanalysisStrategistAgent error: %s", e)
            return AgentOutput(success=False, error=str(e))

    def _build_user_message(
        self,
        prior_analysis: dict[str, Any],
        new_context_items: list[dict[str, Any]],
        lead_info: dict[str, Any],
        user_note: str,
    ) -> str:
        """Build the user message with all context."""
        sections = []

        # Lead info
        name = lead_info.get("name", "Unknown")
        company = lead_info.get("company", "")
        title = lead_info.get("title", "")
        sections.append(f"## Lead: {name}")
        if company:
            sections.append(f"Company: {company}")
        if title:
            sections.append(f"Title: {title}")
        sections.append("")

        # Prior analysis
        sections.append("## Prior Analysis")
        if prior_analysis:
            sections.append("```json")
            sections.append(json.dumps(prior_analysis, indent=2, default=str)[:3000])
            sections.append("```")
        else:
            sections.append("No prior analysis available (this is the initial analysis).")
        sections.append("")

        # New context items
        sections.append("## New Context (Recent Activity)")
        if new_context_items:
            for i, item in enumerate(new_context_items, 1):
                activity_type = item.get("activity_type", "unknown")
                content = item.get("content", "")
                created_at = item.get("created_at", "")[:10] if item.get("created_at") else ""

                type_label = {
                    "prospect_response": "Prospect Response",
                    "meeting_notes": "Meeting Notes",
                    "context_update": "Context Update",
                    "screenshot_comment": "Screenshot Analysis",
                }.get(activity_type, activity_type.replace("_", " ").title())

                sections.append(f"### {i}. {type_label} ({created_at})")
                sections.append(content[:1500])
                sections.append("")
        else:
            sections.append("No new context provided.")
        sections.append("")

        # User note (if any)
        if user_note and user_note.strip():
            sections.append("## User's Note")
            sections.append(user_note)
            sections.append("")

        sections.append("## Your Task")
        sections.append("Re-analyze this lead with the new context. Start with WHAT CHANGED summary, then provide the updated analysis.")

        return "\n".join(sections)

    def _parse_result(self, result: str) -> dict[str, Any]:
        """Parse the LLM result, extracting JSON if present."""
        if not result:
            return {}

        # Try to extract JSON from the result
        result = result.strip()

        # Look for JSON block
        if "```json" in result:
            start = result.find("```json") + 7
            end = result.find("```", start)
            if end > start:
                json_str = result[start:end].strip()
                try:
                    return json.loads(json_str)
                except json.JSONDecodeError:
                    pass

        # Try parsing the whole thing as JSON
        if result.startswith("{"):
            try:
                return json.loads(result)
            except json.JSONDecodeError:
                pass

        # Fall back to returning raw text
        return {"raw_response": result}
```
  </action>
  <verify>grep for "class ReanalysisStrategistAgent" in bot/agents/reanalysis_strategist.py</verify>
  <done>Agent class created with prior analysis loading, LLM call, and code-based diff computation</done>
</task>

<task type="auto">
  <name>Task 4: Register agent in registry.py</name>
  <files>bot/agents/registry.py</files>
  <action>
Add the ReanalysisStrategistAgent to the agent registry.

Import at the top:
```python
from bot.agents.reanalysis_strategist import ReanalysisStrategistAgent
```

Add to the AGENTS dict (or however the registry is structured):
```python
"reanalysis_strategist": ReanalysisStrategistAgent(),
```

Check the existing registry pattern and follow it exactly.
  </action>
  <verify>grep for "reanalysis_strategist" in bot/agents/registry.py</verify>
  <done>ReanalysisStrategistAgent is registered and can be retrieved by name</done>
</task>

</tasks>

<verification>
1. Diff utility: `grep "compute_analysis_diff" bot/services/diff_utils.py`
2. Prompt file: `ls prompts/reanalysis_strategist_agent.md`
3. Agent class: `grep "class ReanalysisStrategistAgent" bot/agents/reanalysis_strategist.py`
4. Registry: `grep "reanalysis_strategist" bot/agents/registry.py`
5. Code-based diff: `grep "field_diff = compute_analysis_diff" bot/agents/reanalysis_strategist.py`
</verification>

<success_criteria>
- diff_utils.py computes JSON diffs in code (not LLM)
- summarize_diff_for_humans produces human-readable change summaries
- Prompt file instructs LLM to start with "WHAT CHANGED" narrative
- ReanalysisStrategistAgent loads prior analysis + new context
- Agent calls LLM and parses structured JSON response
- Agent computes field_diff using code, not relying on LLM
- Agent is registered in registry for pipeline use
</success_criteria>

<output>
After completion, create `.planning/phases/15-conversational-reanalysis/15-03-SUMMARY.md`
</output>
