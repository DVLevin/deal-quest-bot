---
phase: 15-conversational-reanalysis
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - insforge/migrations/004_lead_analysis_history.sql
  - bot/storage/models.py
  - bot/storage/repositories.py
  - packages/shared/src/enums.ts
  - packages/shared/src/tables.ts
autonomous: true

must_haves:
  truths:
    - "lead_analysis_history table exists and stores analysis snapshots"
    - "LeadActivityType includes prospect_response, meeting_notes, re_analysis"
    - "LeadAnalysisHistoryModel and repo methods exist for CRUD"
    - "LeadActivityModel supports new activity types with metadata JSONB"
  artifacts:
    - path: "insforge/migrations/004_lead_analysis_history.sql"
      provides: "Database schema for analysis version history"
      contains: "CREATE TABLE IF NOT EXISTS lead_analysis_history"
    - path: "bot/storage/models.py"
      provides: "LeadAnalysisHistoryModel Pydantic model"
      contains: "class LeadAnalysisHistoryModel"
    - path: "bot/storage/repositories.py"
      provides: "LeadAnalysisHistoryRepo with save/get/prune methods"
      contains: "class LeadAnalysisHistoryRepo"
    - path: "packages/shared/src/enums.ts"
      provides: "Extended LeadActivityType enum"
      contains: "prospect_response"
  key_links:
    - from: "bot/storage/repositories.py"
      to: "insforge/migrations/004_lead_analysis_history.sql"
      via: "table name lead_analysis_history"
      pattern: "lead_analysis_history"
---

<objective>
Create the database schema and data models for analysis version history and extended activity types.

Purpose: REANA-V20-03 (analysis history table) and REANA-V20-04 (extended activity types) require new database structures before the re-analysis logic can be built.
Output: Migration SQL file, updated Pydantic models, new repository class, updated TypeScript types.

**Note on field_diff:** This plan creates the schema with field_diff column and the model with field_diff field. The actual field_diff values are:
- Computed in Plan 15-03 by diff_utils.py (code-based, not LLM)
- Saved to lead_analysis_history in Plan 15-04 via history_repo.save_version()
This plan provides the storage layer; Plans 15-03 and 15-04 provide computation and persistence.
</objective>

<execution_context>
@/Users/dmytrolevin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dmytrolevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-conversational-reanalysis/15-CONTEXT.md

# Existing models and repos
@bot/storage/models.py
@bot/storage/repositories.py
@packages/shared/src/enums.ts
@packages/shared/src/tables.ts

# Prior migration patterns
@insforge/migrations/003_web_research_versions.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lead_analysis_history migration</name>
  <files>insforge/migrations/004_lead_analysis_history.sql</files>
  <action>
Create migration SQL for the `lead_analysis_history` table. This table stores snapshots of lead analysis for version history.

Schema:
```sql
CREATE TABLE IF NOT EXISTS lead_analysis_history (
    id              SERIAL PRIMARY KEY,
    lead_id         INTEGER NOT NULL,
    telegram_id     BIGINT NOT NULL,
    version_number  INTEGER NOT NULL DEFAULT 1,
    analysis_snapshot JSONB NOT NULL,       -- Full analysis JSON at this point
    changes_summary TEXT,                    -- Human-readable "What changed" narrative
    field_diff      JSONB,                   -- Code-computed field-level diff
    triggered_by    TEXT,                    -- 'initial' | 'context_update' | 'manual'
    triggering_activity_id INTEGER,          -- FK to lead_activity_log.id (optional)
    created_at      TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

Add indexes:
- `idx_lead_analysis_history_lead` on (lead_id, version_number DESC) for fetching versions
- `idx_lead_analysis_history_telegram` on (telegram_id) for user's history

Add RLS policies following the pattern from 002_scheduled_reminders.sql:
- Service role can do everything
- Authenticated users can read their own records

Grant sequence usage to anon role for SERIAL auto-increment.
  </action>
  <verify>File exists at `insforge/migrations/004_lead_analysis_history.sql` with CREATE TABLE, indexes, and RLS policies</verify>
  <done>Migration file ready for execution on InsForge database</done>
</task>

<task type="auto">
  <name>Task 2: Add LeadAnalysisHistoryModel to models.py</name>
  <files>bot/storage/models.py</files>
  <action>
Add the `LeadAnalysisHistoryModel` Pydantic model at the end of models.py (before PipelineTraceModel):

```python
class LeadAnalysisHistoryModel(BaseModel):
    id: int | None = None
    lead_id: int
    telegram_id: int
    version_number: int = 1
    analysis_snapshot: dict[str, Any] = Field(default_factory=dict)
    changes_summary: str | None = None
    field_diff: dict[str, Any] | None = None
    triggered_by: str = "initial"  # 'initial' | 'context_update' | 'manual'
    triggering_activity_id: int | None = None
    created_at: str | None = None
```

Also update `LeadActivityModel` to include optional metadata field:

```python
class LeadActivityModel(BaseModel):
    id: int | None = None
    lead_id: int
    telegram_id: int
    activity_type: str  # context_update | screenshot_comment | ai_advice | followup_sent | prospect_response | meeting_notes | re_analysis
    content: str
    ai_response: str | None = None
    metadata: dict[str, Any] | None = None  # ADD THIS for extra structured data
    created_at: str | None = None
```
  </action>
  <verify>grep for "LeadAnalysisHistoryModel" and "metadata: dict" in bot/storage/models.py</verify>
  <done>Both models exist with correct fields</done>
</task>

<task type="auto">
  <name>Task 3: Add LeadAnalysisHistoryRepo to repositories.py</name>
  <files>bot/storage/repositories.py</files>
  <action>
Add the `LeadAnalysisHistoryRepo` class after `LeadActivityRepo` in repositories.py.

Import the model at the top:
```python
from bot.storage.models import (
    ...
    LeadAnalysisHistoryModel,
)
```

Add the repository class:

```python
class LeadAnalysisHistoryRepo:
    """Repository for lead analysis version history."""

    MAX_VERSIONS = 5  # Keep last 5 versions per lead

    def __init__(self, client: InsForgeClient) -> None:
        self.client = client
        self.table = "lead_analysis_history"

    async def save_version(
        self,
        lead_id: int,
        telegram_id: int,
        analysis_snapshot: dict[str, Any],
        changes_summary: str | None = None,
        field_diff: dict[str, Any] | None = None,
        triggered_by: str = "initial",
        triggering_activity_id: int | None = None,
    ) -> LeadAnalysisHistoryModel:
        """Save a new analysis version. Auto-increments version_number."""
        # Get current max version
        rows = await self.client.query(
            self.table,
            select="version_number",
            filters={"lead_id": lead_id},
            order="version_number.desc",
            limit=1,
        )
        next_version = 1
        if rows and isinstance(rows, list) and len(rows) > 0:
            next_version = rows[0].get("version_number", 0) + 1

        data = {
            "lead_id": lead_id,
            "telegram_id": telegram_id,
            "version_number": next_version,
            "analysis_snapshot": analysis_snapshot,
            "changes_summary": changes_summary,
            "field_diff": field_diff,
            "triggered_by": triggered_by,
            "triggering_activity_id": triggering_activity_id,
        }
        result = await self.client.create(self.table, data)

        # Prune old versions beyond MAX_VERSIONS
        await self._prune_old_versions(lead_id)

        return LeadAnalysisHistoryModel(**result) if result else LeadAnalysisHistoryModel(**data)

    async def get_versions(self, lead_id: int, limit: int = 5) -> list[LeadAnalysisHistoryModel]:
        """Get analysis versions for a lead, newest first."""
        rows = await self.client.query(
            self.table,
            filters={"lead_id": lead_id},
            order="version_number.desc",
            limit=limit,
        )
        if rows and isinstance(rows, list):
            return [LeadAnalysisHistoryModel(**r) for r in rows]
        return []

    async def get_latest(self, lead_id: int) -> LeadAnalysisHistoryModel | None:
        """Get the most recent analysis version for a lead."""
        versions = await self.get_versions(lead_id, limit=1)
        return versions[0] if versions else None

    async def _prune_old_versions(self, lead_id: int) -> None:
        """Delete versions beyond MAX_VERSIONS (keep newest)."""
        rows = await self.client.query(
            self.table,
            select="id,version_number",
            filters={"lead_id": lead_id},
            order="version_number.desc",
        )
        if not rows or not isinstance(rows, list):
            return

        # Keep MAX_VERSIONS, delete the rest
        if len(rows) > self.MAX_VERSIONS:
            to_delete = rows[self.MAX_VERSIONS:]
            for row in to_delete:
                row_id = row.get("id")
                if row_id:
                    await self.client.delete(self.table, {"id": row_id})
```

Also update `LeadActivityRepo.create` method to handle the optional metadata field:

```python
async def create(self, activity: LeadActivityModel) -> LeadActivityModel:
    data = activity.model_dump(exclude_none=True, exclude={"id", "created_at"})
    result = await self.client.create(self.table, data)
    return LeadActivityModel(**result) if result else activity
```

(This should already work since exclude_none=True handles the optional metadata field, but verify it's using model_dump correctly)
  </action>
  <verify>grep for "class LeadAnalysisHistoryRepo" in bot/storage/repositories.py</verify>
  <done>Repository class exists with save_version, get_versions, get_latest, and _prune_old_versions methods</done>
</task>

<task type="auto">
  <name>Task 4: Update shared TypeScript types</name>
  <files>packages/shared/src/enums.ts, packages/shared/src/tables.ts</files>
  <action>
1. Update `packages/shared/src/enums.ts` to extend LeadActivityType:

Change from:
```typescript
export type LeadActivityType =
  | 'context_update'
  | 'screenshot_comment'
  | 'ai_advice'
  | 'followup_sent'
  | 'status_change';
```

To:
```typescript
export type LeadActivityType =
  | 'context_update'
  | 'screenshot_comment'
  | 'ai_advice'
  | 'followup_sent'
  | 'status_change'
  | 'step_execution'
  | 'step_snooze'
  | 'step_skip'
  | 'prospect_response'
  | 'meeting_notes'
  | 're_analysis';
```

(Note: step_execution, step_snooze, step_skip were added in Phase 14 but may not be in the shared types yet - include them for completeness)

2. Update `packages/shared/src/tables.ts` to add metadata to LeadActivityRow:

Find the LeadActivityRow type and add metadata field:
```typescript
export interface LeadActivityRow {
  id: number;
  lead_id: number;
  telegram_id: number;
  activity_type: string;
  content: string;
  ai_response: string | null;
  metadata: Record<string, unknown> | null;  // ADD THIS
  created_at: string;
}
```

Also add a new type for LeadAnalysisHistoryRow:
```typescript
export interface LeadAnalysisHistoryRow {
  id: number;
  lead_id: number;
  telegram_id: number;
  version_number: number;
  analysis_snapshot: Record<string, unknown>;
  changes_summary: string | null;
  field_diff: Record<string, unknown> | null;
  triggered_by: string;
  triggering_activity_id: number | null;
  created_at: string;
}
```
  </action>
  <verify>grep for "prospect_response" in packages/shared/src/enums.ts AND grep for "LeadAnalysisHistoryRow" in packages/shared/src/tables.ts</verify>
  <done>TypeScript types include new activity types and LeadAnalysisHistoryRow interface</done>
</task>

</tasks>

<verification>
1. Migration file exists: `ls insforge/migrations/004_lead_analysis_history.sql`
2. Python models updated: `grep -E "(LeadAnalysisHistoryModel|metadata.*dict)" bot/storage/models.py`
3. Repository added: `grep "class LeadAnalysisHistoryRepo" bot/storage/repositories.py`
4. TypeScript types: `grep -E "(prospect_response|LeadAnalysisHistoryRow)" packages/shared/src/enums.ts packages/shared/src/tables.ts`
</verification>

<success_criteria>
- Migration SQL creates lead_analysis_history table with correct schema
- LeadAnalysisHistoryModel exists with all required fields
- LeadAnalysisHistoryRepo has save_version, get_versions, get_latest methods
- Repo auto-prunes to MAX_VERSIONS (5) per lead
- LeadActivityModel has optional metadata field
- TypeScript enums include prospect_response, meeting_notes, re_analysis
- LeadAnalysisHistoryRow type exists in tables.ts
</success_criteria>

<output>
After completion, create `.planning/phases/15-conversational-reanalysis/15-01-SUMMARY.md`
</output>
