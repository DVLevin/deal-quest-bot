---
phase: 15-conversational-reanalysis
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - bot/states.py
  - bot/handlers/context_input.py
  - bot/handlers/reminders.py
  - bot/handlers/leads.py
  - bot/main.py
  - bot/services/transcription.py
autonomous: true

must_haves:
  truths:
    - "User can add context to a lead via reply to reminder"
    - "User can add context via /leads menu 'Add Context' button"
    - "Text, forwarded messages, voice notes, and photos are accepted"
    - "Each context input is logged as activity with appropriate type"
    - "'Re-analyze Strategy?' button appears after context is added"
  artifacts:
    - path: "bot/handlers/context_input.py"
      provides: "Context input handlers for multimodal input"
      contains: "class ContextInputHandler"
    - path: "bot/states.py"
      provides: "FSM states for context collection"
      contains: "ReanalysisState"
  key_links:
    - from: "bot/handlers/context_input.py"
      to: "bot/storage/repositories.py"
      via: "LeadActivityRepo create"
      pattern: "activity_repo\\.create"
    - from: "bot/handlers/reminders.py"
      to: "bot/handlers/context_input.py"
      via: "callback routing to context input"
      pattern: "context:add"
    - from: "bot/handlers/leads.py"
      to: "bot/handlers/context_input.py"
      via: "Add Context button callback"
      pattern: "context:add"
---

<objective>
Create the multimodal context input flow for adding prospect responses, meeting notes, and other context to existing leads.

Purpose: REANA-V20-01 (context update flow) requires accepting text, forwarded messages, voice notes, and screenshots as new context on leads. This plan creates the input collection infrastructure.
Output: New context_input handler module, updated FSM states, reminder context callback, leads menu "Add Context" button, wired to main.py.
</objective>

<execution_context>
@/Users/dmytrolevin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dmytrolevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-conversational-reanalysis/15-CONTEXT.md

# Existing handlers for patterns
@bot/handlers/leads.py
@bot/handlers/reminders.py
@bot/states.py
@bot/services/transcription.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ReanalysisState to states.py</name>
  <files>bot/states.py</files>
  <action>
Add new FSM state group for context collection flow:

```python
class ReanalysisState(StatesGroup):
    """States for context input and re-analysis flow."""
    collecting_context = State()      # Waiting for context input (text/voice/photo/forward)
    confirming_reanalysis = State()   # Showing "Re-analyze Strategy?" button
    updating_plan = State()           # Showing "Update engagement plan too?" button
```

Add this after CommentSupportState in the file.
  </action>
  <verify>grep for "class ReanalysisState" in bot/states.py</verify>
  <done>ReanalysisState exists with collecting_context, confirming_reanalysis, updating_plan states</done>
</task>

<task type="auto">
  <name>Task 2: Create context_input.py handler module</name>
  <files>bot/handlers/context_input.py</files>
  <action>
Create a new handler module for collecting context input on leads. This module handles:
- Entry from reminder callback (reply to reminder)
- Entry from leads menu ("Add Context" button)
- Text input
- Forwarded messages
- Voice notes (transcribed)
- Photo/screenshot input

```python
"""Handler for collecting context input on leads for re-analysis."""

from __future__ import annotations

import base64
import io
import logging
from datetime import datetime, timezone

from aiogram import Bot, F, Router
from aiogram.fsm.context import FSMContext
from aiogram.types import (
    CallbackQuery,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    Message,
)

from bot.services.transcription import transcribe_audio
from bot.states import ReanalysisState
from bot.storage.models import LeadActivityModel
from bot.storage.repositories import (
    LeadActivityRepo,
    LeadRegistryRepo,
    UserRepo,
)
from bot.utils import _sanitize, truncate_message

logger = logging.getLogger(__name__)

router = Router(name="context_input")


def _lead_display_name(lead) -> str:
    """Consistent display name for a lead."""
    if lead.prospect_first_name and lead.prospect_last_name:
        return f"{lead.prospect_first_name} {lead.prospect_last_name}"
    if lead.prospect_first_name:
        return lead.prospect_first_name
    return lead.prospect_name or f"Prospect #{lead.id}"


def _reanalyze_keyboard(lead_id: int) -> InlineKeyboardMarkup:
    """Keyboard with Re-analyze Strategy? button."""
    return InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(
                text="üîÑ Re-analyze Strategy?",
                callback_data=f"reanalyze:start:{lead_id}",
            ),
        ],
        [
            InlineKeyboardButton(
                text="‚ûï Add More Context",
                callback_data=f"context:add:{lead_id}",
            ),
        ],
        [
            InlineKeyboardButton(
                text="üìã View Lead",
                callback_data=f"lead:view:{lead_id}",
            ),
        ],
    ])


# ‚îÄ‚îÄ‚îÄ Entry Points ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

@router.callback_query(F.data.startswith("context:add:"))
async def on_context_add_start(
    callback: CallbackQuery,
    state: FSMContext,
    lead_repo: LeadRegistryRepo,
) -> None:
    """Start context collection from /leads menu button or after adding context."""
    lead_id = int(callback.data.split(":")[2])  # type: ignore[union-attr]

    lead = await lead_repo.get_by_id(lead_id)
    if not lead:
        await callback.answer("Lead not found.")
        return

    await state.set_state(ReanalysisState.collecting_context)
    await state.update_data(context_lead_id=lead_id, context_items=[])

    name = _sanitize(_lead_display_name(lead))
    await callback.message.edit_text(  # type: ignore[union-attr]
        f"üìù *Add Context ‚Äî {name}*\n\n"
        "Send me any updates about this lead:\n\n"
        "‚Ä¢ üí¨ *Text* ‚Äî Type your notes or updates\n"
        "‚Ä¢ ‚Ü™Ô∏è *Forward* ‚Äî Forward a prospect's message\n"
        "‚Ä¢ üé§ *Voice* ‚Äî Record a voice note (I'll transcribe it)\n"
        "‚Ä¢ üì∏ *Photo* ‚Äî Screenshot of conversation or email\n\n"
        "When done, tap *Done* below, or I'll offer to re-analyze after each input.\n\n"
        "_Send /cancel to go back._",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="‚úÖ Done Adding Context", callback_data=f"context:done:{lead_id}")],
            [InlineKeyboardButton(text="‚óÄÔ∏è Back to Lead", callback_data=f"lead:view:{lead_id}")],
        ]),
    )
    await callback.answer()


@router.callback_query(F.data.startswith("reminder:addcontext:"))
async def on_reminder_add_context(
    callback: CallbackQuery,
    state: FSMContext,
    lead_repo: LeadRegistryRepo,
) -> None:
    """Start context collection from reminder message (reply to reminder)."""
    parts = callback.data.split(":")  # type: ignore[union-attr]
    lead_id = int(parts[2])

    lead = await lead_repo.get_by_id(lead_id)
    if not lead:
        await callback.answer("Lead not found.")
        return

    await state.set_state(ReanalysisState.collecting_context)
    await state.update_data(context_lead_id=lead_id, context_items=[])

    name = _sanitize(_lead_display_name(lead))
    await callback.message.reply(  # type: ignore[union-attr]
        f"üìù *Add Context ‚Äî {name}*\n\n"
        "Reply here with updates about this lead:\n\n"
        "‚Ä¢ Forward the prospect's reply\n"
        "‚Ä¢ Type meeting notes\n"
        "‚Ä¢ Send a voice note\n"
        "‚Ä¢ Share a screenshot\n\n"
        "_Send /cancel to go back._",
        parse_mode="Markdown",
    )
    await callback.answer("Ready for context input")


# ‚îÄ‚îÄ‚îÄ Context Input Handlers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

@router.message(ReanalysisState.collecting_context, F.text)
async def on_context_text(
    message: Message,
    state: FSMContext,
    lead_repo: LeadRegistryRepo,
    activity_repo: LeadActivityRepo,
) -> None:
    """Handle text context input."""
    text = message.text or ""

    if text.strip().lower() == "/cancel":
        await state.clear()
        await message.answer("Cancelled. Use /leads to go back.")
        return

    data = await state.get_data()
    lead_id = data.get("context_lead_id")
    if not lead_id:
        await state.clear()
        await message.answer("No active lead. Use /leads to select one.")
        return

    tg_id = message.from_user.id  # type: ignore[union-attr]
    lead = await lead_repo.get_by_id(lead_id)
    if not lead:
        await state.clear()
        await message.answer("Lead not found. Use /leads to select one.")
        return

    # Determine activity type based on content
    activity_type = "context_update"
    # Heuristic: if text looks like a prospect response (short, conversational)
    # or user explicitly says "they said/replied"
    lower_text = text.lower()
    if any(phrase in lower_text for phrase in ["they said", "they replied", "prospect said", "their response", "they wrote"]):
        activity_type = "prospect_response"
    elif any(phrase in lower_text for phrase in ["meeting notes", "call notes", "had a call", "met with", "after the meeting"]):
        activity_type = "meeting_notes"

    # Save activity
    activity = await activity_repo.create(
        LeadActivityModel(
            lead_id=lead_id,
            telegram_id=tg_id,
            activity_type=activity_type,
            content=text[:3000],
            metadata={"input_type": "text"},
        )
    )

    # Track context items in state
    context_items = data.get("context_items", [])
    context_items.append({"type": activity_type, "activity_id": activity.id})
    await state.update_data(context_items=context_items)

    name = _sanitize(_lead_display_name(lead))
    type_label = "Prospect response" if activity_type == "prospect_response" else (
        "Meeting notes" if activity_type == "meeting_notes" else "Context"
    )
    await message.answer(
        f"‚úÖ *{type_label} saved for {name}*\n\n"
        f"You can add more context, or tap below to re-analyze the strategy.",
        parse_mode="Markdown",
        reply_markup=_reanalyze_keyboard(lead_id),
    )


@router.message(ReanalysisState.collecting_context, F.voice)
async def on_context_voice(
    message: Message,
    state: FSMContext,
    bot: Bot,
    lead_repo: LeadRegistryRepo,
    activity_repo: LeadActivityRepo,
    assemblyai_api_key: str = "",
) -> None:
    """Handle voice note context input (transcribe and save)."""
    data = await state.get_data()
    lead_id = data.get("context_lead_id")
    if not lead_id:
        await state.clear()
        await message.answer("No active lead. Use /leads to select one.")
        return

    tg_id = message.from_user.id  # type: ignore[union-attr]
    lead = await lead_repo.get_by_id(lead_id)
    if not lead:
        await state.clear()
        await message.answer("Lead not found.")
        return

    status_msg = await message.answer("üé§ Transcribing voice note...")

    # Download voice file
    voice = message.voice
    if not voice:
        await status_msg.edit_text("‚ùå Could not process voice note.")
        return

    file = await bot.get_file(voice.file_id)
    file_bytes_io = io.BytesIO()
    await bot.download_file(file.file_path, file_bytes_io)  # type: ignore[arg-type]
    audio_bytes = file_bytes_io.getvalue()

    # Transcribe
    if not assemblyai_api_key:
        await status_msg.edit_text(
            "‚ùå Voice transcription not configured. Please type your notes instead."
        )
        return

    try:
        transcript = await transcribe_audio(audio_bytes, assemblyai_api_key)
    except Exception as e:
        logger.error("Voice transcription failed: %s", e)
        await status_msg.edit_text(f"‚ùå Transcription failed: {str(e)[:100]}")
        return

    if not transcript or not transcript.strip():
        await status_msg.edit_text("‚ùå Could not transcribe voice note. Please try again or type instead.")
        return

    # Save activity as meeting_notes (voice notes are typically meeting notes)
    activity = await activity_repo.create(
        LeadActivityModel(
            lead_id=lead_id,
            telegram_id=tg_id,
            activity_type="meeting_notes",
            content=transcript[:3000],
            metadata={"input_type": "voice", "duration_seconds": voice.duration},
        )
    )

    # Track context items
    context_items = data.get("context_items", [])
    context_items.append({"type": "meeting_notes", "activity_id": activity.id})
    await state.update_data(context_items=context_items)

    name = _sanitize(_lead_display_name(lead))
    await status_msg.edit_text(
        f"‚úÖ *Voice note transcribed and saved for {name}*\n\n"
        f"_\"{_sanitize(transcript[:200])}...\"_\n\n"
        f"You can add more context, or tap below to re-analyze the strategy.",
        parse_mode="Markdown",
        reply_markup=_reanalyze_keyboard(lead_id),
    )


@router.message(ReanalysisState.collecting_context, F.photo)
async def on_context_photo(
    message: Message,
    state: FSMContext,
    bot: Bot,
    lead_repo: LeadRegistryRepo,
    activity_repo: LeadActivityRepo,
) -> None:
    """Handle photo/screenshot context input."""
    data = await state.get_data()
    lead_id = data.get("context_lead_id")
    if not lead_id:
        await state.clear()
        await message.answer("No active lead. Use /leads to select one.")
        return

    tg_id = message.from_user.id  # type: ignore[union-attr]
    lead = await lead_repo.get_by_id(lead_id)
    if not lead:
        await state.clear()
        await message.answer("Lead not found.")
        return

    # Download photo
    photo = message.photo[-1] if message.photo else None  # type: ignore[index]
    if not photo:
        await message.answer("‚ùå Could not process photo.")
        return

    file = await bot.get_file(photo.file_id)
    file_bytes_io = io.BytesIO()
    await bot.download_file(file.file_path, file_bytes_io)  # type: ignore[arg-type]
    photo_b64 = base64.b64encode(file_bytes_io.getvalue()).decode("ascii")

    # Save activity with caption as content
    caption = message.caption or "[Screenshot/photo context]"

    activity = await activity_repo.create(
        LeadActivityModel(
            lead_id=lead_id,
            telegram_id=tg_id,
            activity_type="prospect_response",  # Photos are typically prospect responses
            content=caption[:3000],
            metadata={
                "input_type": "photo",
                "photo_b64_preview": photo_b64[:100] + "...",  # Just store indicator, not full image
                "has_image": True,
            },
        )
    )

    # Track context items
    context_items = data.get("context_items", [])
    context_items.append({"type": "prospect_response", "activity_id": activity.id, "has_image": True})
    await state.update_data(context_items=context_items, latest_photo_b64=photo_b64)

    name = _sanitize(_lead_display_name(lead))
    await message.answer(
        f"‚úÖ *Screenshot saved for {name}*\n\n"
        f"Caption: _{_sanitize(caption[:100])}_\n\n"
        f"You can add more context, or tap below to re-analyze the strategy.",
        parse_mode="Markdown",
        reply_markup=_reanalyze_keyboard(lead_id),
    )


@router.message(ReanalysisState.collecting_context, F.forward_date)
async def on_context_forward(
    message: Message,
    state: FSMContext,
    lead_repo: LeadRegistryRepo,
    activity_repo: LeadActivityRepo,
) -> None:
    """Handle forwarded message context input."""
    data = await state.get_data()
    lead_id = data.get("context_lead_id")
    if not lead_id:
        await state.clear()
        await message.answer("No active lead. Use /leads to select one.")
        return

    tg_id = message.from_user.id  # type: ignore[union-attr]
    lead = await lead_repo.get_by_id(lead_id)
    if not lead:
        await state.clear()
        await message.answer("Lead not found.")
        return

    # Extract forwarded content
    forward_text = message.text or message.caption or "[Forwarded message without text]"
    forward_from = None
    if message.forward_from:
        fn = message.forward_from.first_name or ""
        ln = message.forward_from.last_name or ""
        forward_from = f"{fn} {ln}".strip() or message.forward_from.username
    elif message.forward_sender_name:
        forward_from = message.forward_sender_name

    content = forward_text
    if forward_from:
        content = f"[Forwarded from {forward_from}]\n\n{forward_text}"

    # Save as prospect_response (forwarded messages are typically prospect responses)
    activity = await activity_repo.create(
        LeadActivityModel(
            lead_id=lead_id,
            telegram_id=tg_id,
            activity_type="prospect_response",
            content=content[:3000],
            metadata={
                "input_type": "forward",
                "forward_from": forward_from,
                "forward_date": message.forward_date.isoformat() if message.forward_date else None,
            },
        )
    )

    # Track context items
    context_items = data.get("context_items", [])
    context_items.append({"type": "prospect_response", "activity_id": activity.id})
    await state.update_data(context_items=context_items)

    name = _sanitize(_lead_display_name(lead))
    from_label = f" from {_sanitize(forward_from)}" if forward_from else ""
    await message.answer(
        f"‚úÖ *Forwarded message{from_label} saved for {name}*\n\n"
        f"You can add more context, or tap below to re-analyze the strategy.",
        parse_mode="Markdown",
        reply_markup=_reanalyze_keyboard(lead_id),
    )


# ‚îÄ‚îÄ‚îÄ Done / Cancel ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

@router.callback_query(F.data.startswith("context:done:"))
async def on_context_done(
    callback: CallbackQuery,
    state: FSMContext,
    lead_repo: LeadRegistryRepo,
) -> None:
    """Finish context collection, show re-analyze prompt."""
    lead_id = int(callback.data.split(":")[2])  # type: ignore[union-attr]

    data = await state.get_data()
    context_items = data.get("context_items", [])

    lead = await lead_repo.get_by_id(lead_id)
    if not lead:
        await callback.answer("Lead not found.")
        await state.clear()
        return

    name = _sanitize(_lead_display_name(lead))
    count = len(context_items)

    if count == 0:
        await callback.message.edit_text(  # type: ignore[union-attr]
            f"No context was added for *{name}*.\n\n"
            "Use /leads to view your pipeline.",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="üìã View Lead", callback_data=f"lead:view:{lead_id}")],
            ]),
        )
        await state.clear()
        await callback.answer()
        return

    # Show re-analyze prompt
    await state.set_state(ReanalysisState.confirming_reanalysis)
    await callback.message.edit_text(  # type: ignore[union-attr]
        f"‚úÖ *{count} context item(s) added for {name}*\n\n"
        f"Would you like me to re-analyze the strategy with this new context?\n\n"
        f"The re-analysis will consider all the new information and update "
        f"the prospect analysis, closing strategy, and engagement tactics.",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [
                InlineKeyboardButton(
                    text="üîÑ Re-analyze Strategy",
                    callback_data=f"reanalyze:start:{lead_id}",
                ),
            ],
            [
                InlineKeyboardButton(
                    text="‚è≠ Skip for Now",
                    callback_data=f"reanalyze:skip:{lead_id}",
                ),
            ],
        ]),
    )
    await callback.answer()


@router.callback_query(F.data.startswith("reanalyze:skip:"))
async def on_reanalyze_skip(
    callback: CallbackQuery,
    state: FSMContext,
    lead_repo: LeadRegistryRepo,
) -> None:
    """Skip re-analysis, mark lead as pending re-analysis."""
    lead_id = int(callback.data.split(":")[2])  # type: ignore[union-attr]

    lead = await lead_repo.get_by_id(lead_id)
    if lead:
        # Mark lead as having pending re-analysis (stored in notes or a flag)
        # For now, we'll add a note. Could add a dedicated field later.
        current_notes = lead.notes or ""
        if "[Pending re-analysis]" not in current_notes:
            new_notes = f"[Pending re-analysis] {current_notes}".strip()
            await lead_repo.update_lead(lead_id, notes=new_notes[:1000])

        name = _sanitize(_lead_display_name(lead))
        await callback.message.edit_text(  # type: ignore[union-attr]
            f"‚è∏ *Re-analysis skipped for {name}*\n\n"
            f"The lead is marked as pending re-analysis. "
            f"You can trigger it later from the lead detail.\n\n"
            f"Use /leads to continue.",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="üìã View Lead", callback_data=f"lead:view:{lead_id}")],
            ]),
        )

    await state.clear()
    await callback.answer()
```
  </action>
  <verify>File exists at bot/handlers/context_input.py with router and handlers for text, voice, photo, forward</verify>
  <done>Context input handler module created with all input type handlers and re-analyze prompt</done>
</task>

<task type="auto">
  <name>Task 3: Update reminders.py with Add Context button</name>
  <files>bot/handlers/reminders.py</files>
  <action>
Update the reminder message keyboards to include an "Add Context" button that allows users to add context when responding to a reminder.

In the `on_reminder_done` function, the success message keyboard should include an "Add Context" option.

Add to the success reply_markup:
```python
reply_markup=InlineKeyboardMarkup(inline_keyboard=[
    [
        InlineKeyboardButton(text="üìù Add Context", callback_data=f"context:add:{lead_id}"),
    ],
    [
        InlineKeyboardButton(text="üìã View Lead", callback_data=f"lead:view:{lead_id}"),
    ],
])
```

Similarly, update `on_reminder_snooze` and `on_reminder_skip` to include the Add Context button in their response keyboards.

Also, update `on_reminder_draft` to include the Add Context button alongside Done/Snooze buttons:
```python
reply_markup=InlineKeyboardMarkup(inline_keyboard=[
    [
        InlineKeyboardButton(text="‚úÖ Done", callback_data=f"reminder:done:{lead_id}:{step_id}"),
        InlineKeyboardButton(text="‚è∞ Snooze", callback_data=f"reminder:snooze:{lead_id}:{step_id}"),
    ],
    [
        InlineKeyboardButton(text="üìù Add Context", callback_data=f"context:add:{lead_id}"),
    ],
    [
        InlineKeyboardButton(text="üìã View Lead", callback_data=f"lead:view:{lead_id}"),
    ],
])
```
  </action>
  <verify>grep for "context:add" in bot/handlers/reminders.py</verify>
  <done>Reminder callbacks include Add Context button for entering context input flow</done>
</task>

<task type="auto">
  <name>Task 4: Update leads.py with Add Context button in lead detail</name>
  <files>bot/handlers/leads.py</files>
  <action>
Per user decision (secondary entry point: /leads menu ‚Äî user can select lead and tap "Add Context" button anytime), update the lead detail view to include an "Add Context" button for ALL leads.

In `_lead_detail_keyboard` function, update the engagement actions row to use the new `context:add:` callback pattern:

Find the current "Add Update" button:
```python
# Engagement actions
buttons.append([
    InlineKeyboardButton(
        text="üìù Add Update", callback_data=f"lead:context:{lead_id}"
    ),
    InlineKeyboardButton(
        text="üß† Get Advice", callback_data=f"lead:advice:{lead_id}"
    ),
])
```

Change to use the new context:add callback:
```python
# Engagement actions (context:add routes to new multimodal context_input handler)
buttons.append([
    InlineKeyboardButton(
        text="üìù Add Context", callback_data=f"context:add:{lead_id}"
    ),
    InlineKeyboardButton(
        text="üß† Get Advice", callback_data=f"lead:advice:{lead_id}"
    ),
])
```

This replaces the old `lead:context:` callback (which routes to LeadEngagementState.adding_context in leads.py) with the new `context:add:` callback (which routes to the multimodal context_input.py handler with ReanalysisState).

**Important:** Keep the old `lead:context:` handler in leads.py for now (don't delete it) in case any existing code references it. The new flow just uses a different callback pattern.
  </action>
  <verify>grep for "context:add" in bot/handlers/leads.py (in the _lead_detail_keyboard function)</verify>
  <done>Lead detail view has "Add Context" button using context:add callback pattern</done>
</task>

<task type="auto">
  <name>Task 5: Wire context_input router and assemblyai_api_key to main.py</name>
  <files>bot/main.py</files>
  <action>
Import and include the context_input router in main.py.

1. Add import:
```python
from bot.handlers.context_input import router as context_input_router
```

2. Add to router includes (after reminders_router):
```python
dp.include_router(context_input_router)
```

3. **CRITICAL for voice transcription:** Add assemblyai_api_key to the DI workflow_data so the on_context_voice handler can access it:

Find the dp.workflow_data.update block and add:
```python
dp.workflow_data.update(
    {
        # ... existing entries ...
        "assemblyai_api_key": cfg.assemblyai_api_key,  # ADD THIS LINE
    }
)
```

This makes the assemblyai_api_key available as a dependency-injected parameter to handlers like `on_context_voice(message, state, bot, lead_repo, activity_repo, assemblyai_api_key="")`.
  </action>
  <verify>grep for "context_input_router" in bot/main.py AND grep for "assemblyai_api_key" in bot/main.py dp.workflow_data section</verify>
  <done>Context input router is wired to the dispatcher AND assemblyai_api_key is in DI workflow_data</done>
</task>

</tasks>

<verification>
1. States exist: `grep "ReanalysisState" bot/states.py`
2. Handler module: `ls bot/handlers/context_input.py`
3. Router wired: `grep "context_input" bot/main.py`
4. AssemblyAI key in DI: `grep "assemblyai_api_key" bot/main.py`
5. Add Context button in reminders: `grep "context:add" bot/handlers/reminders.py`
6. Add Context button in leads: `grep "context:add" bot/handlers/leads.py`
7. All input types handled: `grep -E "(on_context_text|on_context_voice|on_context_photo|on_context_forward)" bot/handlers/context_input.py`
</verification>

<success_criteria>
- ReanalysisState FSM group exists with collecting_context, confirming_reanalysis, updating_plan states
- context_input.py handles text, voice, photo, and forwarded message inputs
- Each input type is saved as appropriate activity (prospect_response, meeting_notes, context_update)
- "Re-analyze Strategy?" button appears after context is added
- Reminder messages include "Add Context" button (context:add callback)
- Lead detail view includes "Add Context" button (context:add callback) - secondary entry point per user decision
- Voice notes are transcribed via AssemblyAI before saving
- Router is wired to main.py dispatcher
- assemblyai_api_key is available via DI in main.py workflow_data
</success_criteria>

<output>
After completion, create `.planning/phases/15-conversational-reanalysis/15-02-SUMMARY.md`
</output>
