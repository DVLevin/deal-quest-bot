---
phase: 13-smart-lead-creation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - bot/agents/extraction.py
  - bot/main.py
  - prompts/extraction_agent.md
autonomous: true

must_haves:
  truths:
    - "ExtractionAgent exists and extracts structured prospect data from screenshots"
    - "ExtractionAgent uses a focused OCR prompt without knowledge base injection"
    - "ExtractionAgent is registered in main.py and available via AgentRegistry"
  artifacts:
    - path: "bot/agents/extraction.py"
      provides: "ExtractionAgent class"
      exports: ["ExtractionAgent"]
      contains: "class ExtractionAgent"
    - path: "prompts/extraction_agent.md"
      provides: "Focused OCR prompt"
      contains: "first_name"
    - path: "bot/main.py"
      provides: "Agent registration"
      contains: "ExtractionAgent"
  key_links:
    - from: "bot/agents/extraction.py"
      to: "bot/agents/base.py"
      via: "BaseAgent inheritance"
      pattern: "class ExtractionAgent.*BaseAgent"
    - from: "bot/main.py"
      to: "bot/agents/extraction.py"
      via: "import and register"
      pattern: "from bot.agents.extraction import ExtractionAgent"
---

<objective>
Create the ExtractionAgent for focused OCR extraction from screenshots.

Purpose: Combining OCR extraction with strategic analysis in a single prompt produces garbled names because the model tries to do too much. A dedicated ExtractionAgent with a focused prompt (no knowledge base injection) extracts clean structured data that can then be passed to the StrategistAgent.

Output: New ExtractionAgent class, prompt file, and registration in main.py.
</objective>

<execution_context>
@/Users/dmytrolevin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dmytrolevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-smart-lead-creation/13-RESEARCH.md

# Existing agent patterns
@bot/agents/base.py
@bot/agents/strategist.py
@bot/agents/registry.py
@bot/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ExtractionAgent</name>
  <files>bot/agents/extraction.py, prompts/extraction_agent.md</files>
  <action>
1. Create the prompt file `prompts/extraction_agent.md`:

```markdown
# Extraction Agent

You are an OCR extraction specialist. Your ONLY job is to extract structured information from screenshots of LinkedIn profiles, emails, business cards, or other prospect documents.

## Instructions

1. Carefully read all visible text in the image
2. Extract ONLY the information that is clearly visible
3. Do NOT infer, guess, or make up any information
4. If a field is not visible, use null

## Output Format

Return ONLY a valid JSON object with these exact fields:

```json
{
  "first_name": "string or null",
  "last_name": "string or null",
  "title": "string or null",
  "company": "string or null",
  "geography": "string or null",
  "context": "string or null"
}
```

## Field Definitions

- **first_name**: Person's first/given name
- **last_name**: Person's last/family name
- **title**: Job title or role (e.g., "VP of Sales", "Software Engineer")
- **company**: Company or organization name
- **geography**: Location if visible (city, country, region)
- **context**: Any other relevant visible information (headline, about section summary, recent activity, etc.)

## Important

- Extract the EXACT text you see - do not correct spelling or formatting
- For names, extract what's visible even if it seems incomplete
- If you see multiple people, extract information for the PRIMARY person (usually the profile owner, not connections)
- Do NOT add analysis, strategy, or recommendations - just extract the raw data
```

2. Create `bot/agents/extraction.py`:

```python
"""Extraction Agent â€” focused OCR for prospect screenshots."""

from __future__ import annotations

import logging
from pathlib import Path

from bot.agents.base import AgentInput, AgentOutput, BaseAgent
from bot.pipeline.context import PipelineContext
from bot.tracing import traced_span

logger = logging.getLogger(__name__)

_PROMPT_PATH = Path(__file__).resolve().parent.parent.parent / "prompts" / "extraction_agent.md"


class ExtractionAgent(BaseAgent):
    """Lightweight OCR agent - extracts structured data from screenshots.

    This agent uses a focused prompt WITHOUT knowledge base injection.
    Its only job is to read the image and extract clean structured data.
    The strategic analysis happens in a separate StrategistAgent call.
    """

    name = "extraction"

    def __init__(self) -> None:
        self._prompt: str = ""
        if _PROMPT_PATH.exists():
            self._prompt = _PROMPT_PATH.read_text(encoding="utf-8")
        else:
            logger.warning("Extraction prompt not found: %s", _PROMPT_PATH)
            # Fallback minimal prompt
            self._prompt = (
                "Extract visible information from this screenshot. "
                "Return JSON with fields: first_name, last_name, title, company, geography, context. "
                "Use null for fields not visible."
            )

    @traced_span("agent:extraction")
    async def run(self, input_data: AgentInput, pipeline_ctx: PipelineContext) -> AgentOutput:
        """Extract structured data from a screenshot."""
        try:
            if not pipeline_ctx.image_b64:
                return AgentOutput(
                    success=False,
                    error="No image provided for extraction",
                )

            # Simple user message - the prompt does the heavy lifting
            user_message = (
                input_data.user_message
                or "Extract all visible prospect information from this screenshot."
            )

            result = await pipeline_ctx.llm.complete(
                self._prompt,
                user_message,
                image_b64=pipeline_ctx.image_b64,
            )

            # Validate we got the expected fields
            expected_fields = {"first_name", "last_name", "title", "company", "geography", "context"}
            if isinstance(result, dict):
                # Check if we got actual extraction data vs error
                if "raw_response" in result and len(result) == 1:
                    logger.warning("Extraction returned raw response: %s", result.get("raw_response", "")[:100])

                # Ensure all expected fields exist (with None as default)
                for field in expected_fields:
                    if field not in result:
                        result[field] = None

            return AgentOutput(success=True, data=result)

        except Exception as e:
            logger.error("ExtractionAgent error: %s", e)
            return AgentOutput(success=False, error=str(e))
```

Key implementation notes:
- Follows existing agent pattern (StrategistAgent, TrainerAgent)
- Uses @traced_span for observability
- NO knowledge base injection - keeps the prompt focused on OCR only
- Validates image exists before calling LLM
- Ensures all expected fields are present in output
  </action>
  <verify>
```bash
# Check class exists with correct inheritance
grep "class ExtractionAgent" bot/agents/extraction.py

# Check prompt file exists
ls -la prompts/extraction_agent.md

# Verify imports work
python3 -c "from bot.agents.extraction import ExtractionAgent; print(ExtractionAgent.name)"
```
  </verify>
  <done>ExtractionAgent class exists with focused OCR prompt, returns structured JSON with first_name, last_name, title, company, geography, context fields.</done>
</task>

<task type="auto">
  <name>Task 2: Register ExtractionAgent in main.py</name>
  <files>bot/main.py</files>
  <action>
Add ExtractionAgent registration to main.py alongside existing agents.

1. Add import at the top with other agent imports:
```python
from bot.agents.extraction import ExtractionAgent
```

2. Register in the agent_registry setup (look for where StrategistAgent is registered):
```python
agent_registry.register(ExtractionAgent())
```

The registration should be in the same block where other agents are registered, typically in the startup/initialization section of main.py.
  </action>
  <verify>
```bash
# Check import exists
grep "from bot.agents.extraction import ExtractionAgent" bot/main.py

# Check registration exists
grep "ExtractionAgent()" bot/main.py

# Verify bot still starts (syntax check)
python3 -c "import bot.main; print('OK')"
```
  </verify>
  <done>ExtractionAgent is imported and registered in main.py, available via agent_registry.get("extraction").</done>
</task>

</tasks>

<verification>
1. ExtractionAgent module importable:
   ```bash
   python3 -c "from bot.agents.extraction import ExtractionAgent; e = ExtractionAgent(); print(f'Agent name: {e.name}')"
   ```

2. Prompt file exists:
   ```bash
   head -5 prompts/extraction_agent.md
   ```

3. Agent registered in main.py:
   ```bash
   grep -c "ExtractionAgent" bot/main.py  # Should be >= 2 (import + register)
   ```
</verification>

<success_criteria>
- ExtractionAgent class exists in bot/agents/extraction.py
- Agent has name = "extraction"
- Agent uses focused OCR prompt from prompts/extraction_agent.md
- Agent does NOT inject knowledge base (pure OCR)
- Agent is registered in main.py
- Agent returns structured JSON with expected fields
</success_criteria>

<output>
After completion, create `.planning/phases/13-smart-lead-creation/13-02-SUMMARY.md`
</output>
