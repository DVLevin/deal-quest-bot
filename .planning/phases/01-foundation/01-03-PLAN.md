---
phase: 01-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - bot/agents/trainer.py
  - bot/agents/strategist.py
  - bot/agents/memory.py
  - bot/services/llm_router.py
autonomous: true

must_haves:
  truths:
    - "Every agent .run() call during a traced pipeline creates a span with agent name, timing, success/failure, and I/O data"
    - "LLM complete() calls create child spans under the parent agent span, capturing model name and response timing"
    - "Spans are only recorded when inside a TraceContext — outside traced context, agents run normally with zero overhead"
    - "Agent and LLM spans appear in pipeline_spans table linked to the parent trace via trace_id"
    - "No changes to PipelineRunner, pipeline configs, or handler code — instrumentation is purely at the agent/LLM call site level"
  artifacts:
    - path: "bot/agents/trainer.py"
      provides: "TrainerAgent.run() decorated with @traced_span('agent:trainer')"
      contains: "traced_span"
    - path: "bot/agents/strategist.py"
      provides: "StrategistAgent.run() decorated with @traced_span('agent:strategist')"
      contains: "traced_span"
    - path: "bot/agents/memory.py"
      provides: "MemoryAgent.run() decorated with @traced_span('agent:memory')"
      contains: "traced_span"
    - path: "bot/services/llm_router.py"
      provides: "ClaudeProvider.complete() and OpenRouterProvider.complete() decorated with @traced_span('llm:complete')"
      contains: "traced_span"
  key_links:
    - from: "bot/agents/trainer.py"
      to: "bot/tracing/context.py"
      via: "@traced_span decorator import and application"
      pattern: "traced_span"
    - from: "bot/agents/strategist.py"
      to: "bot/tracing/context.py"
      via: "@traced_span decorator import and application"
      pattern: "traced_span"
    - from: "bot/agents/memory.py"
      to: "bot/tracing/context.py"
      via: "@traced_span decorator import and application"
      pattern: "traced_span"
    - from: "bot/services/llm_router.py"
      to: "bot/tracing/context.py"
      via: "@traced_span decorator on LLM complete() methods"
      pattern: "traced_span"
---

<objective>
Apply step-level tracing instrumentation to agent methods and LLM calls.

Purpose: The tracing module (Plan 01-01) provides TraceContext and traced_span. The handler instrumentation (Plan 01-02) wraps pipeline execution with TraceContext. This plan closes the gap by instrumenting the *internals* — each agent's `.run()` method and each LLM provider's `.complete()` method — so that step-level spans are recorded within the outer trace. This fulfills TRACE-02 (step-level timing) and TRACE-04 (agent I/O capture) without modifying PipelineRunner.

Output: Agent .run() methods and LLM .complete() methods decorated with @traced_span, producing spans like `agent:trainer`, `agent:strategist`, `agent:memory`, and `llm:complete`.
</objective>

<execution_context>
@/Users/dmytrolevin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dmytrolevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-01-SUMMARY.md

@bot/agents/base.py — BaseAgent ABC with .run() signature: async def run(self, input_data: AgentInput, pipeline_ctx: Any) -> AgentOutput
@bot/agents/trainer.py — TrainerAgent.run() — calls pipeline_ctx.llm.complete(), returns AgentOutput
@bot/agents/strategist.py — StrategistAgent.run() — calls pipeline_ctx.llm.complete(), returns AgentOutput
@bot/agents/memory.py — MemoryAgent.run() — no LLM call, processes data and returns AgentOutput
@bot/services/llm_router.py — LLMProvider ABC, ClaudeProvider.complete(), OpenRouterProvider.complete()
@bot/pipeline/runner.py — PipelineRunner (DO NOT MODIFY) — calls agent.run() via _run_step, _run_parallel, _run_background
</context>

<tasks>

<task type="auto">
  <name>Task 1: Instrument agent .run() methods with @traced_span</name>
  <files>
    bot/agents/trainer.py
    bot/agents/strategist.py
    bot/agents/memory.py
  </files>
  <action>
Add `@traced_span` decorator to each agent's `.run()` method. The decorator captures timing, I/O, and success/failure as a span.

**Pattern to apply in each agent file:**

1. Add import at the top:
```python
from bot.tracing import traced_span
```

2. Decorate the `.run()` method with `@traced_span("agent:{agent_name}")`:

**bot/agents/trainer.py:**
```python
@traced_span("agent:trainer")
async def run(self, input_data: AgentInput, pipeline_ctx: PipelineContext) -> AgentOutput:
    # Existing implementation — NO changes to the method body
    ...
```

**bot/agents/strategist.py:**
```python
@traced_span("agent:strategist")
async def run(self, input_data: AgentInput, pipeline_ctx: PipelineContext) -> AgentOutput:
    # Existing implementation — NO changes to the method body
    ...
```

**bot/agents/memory.py:**
```python
@traced_span("agent:memory")
async def run(self, input_data: AgentInput, pipeline_ctx: PipelineContext) -> AgentOutput:
    # Existing implementation — NO changes to the method body
    ...
```

**Critical rules:**
- Do NOT modify the method body — only add the decorator and import
- The decorator automatically captures input_data (AgentInput Pydantic model — serialized via .model_dump()), pipeline_ctx (will be serialized as repr since it's not a simple type), and the AgentOutput return value
- When not inside a TraceContext (i.e., _trace_id ContextVar is None), the decorator is a no-op — zero overhead
- The decorator preserves the original method signature and behavior, including exception propagation
- The `@traced_span` decorator must be placed ABOVE any existing decorators but BELOW `@abstractmethod` if present (not applicable here since these are concrete methods)
  </action>
  <verify>
    - `python -c "import ast; ast.parse(open('bot/agents/trainer.py').read()); print('trainer.py OK')"` succeeds
    - `python -c "import ast; ast.parse(open('bot/agents/strategist.py').read()); print('strategist.py OK')"` succeeds
    - `python -c "import ast; ast.parse(open('bot/agents/memory.py').read()); print('memory.py OK')"` succeeds
    - grep confirms `traced_span` appears in all three agent files
    - grep confirms `from bot.tracing import traced_span` appears in all three files
  </verify>
  <done>
    - TrainerAgent.run() decorated with @traced_span("agent:trainer")
    - StrategistAgent.run() decorated with @traced_span("agent:strategist")
    - MemoryAgent.run() decorated with @traced_span("agent:memory")
    - No changes to method bodies — only decorator and import added
    - Agents run normally outside traced context (decorator is no-op when _trace_id is None)
  </done>
</task>

<task type="auto">
  <name>Task 2: Instrument LLM provider .complete() methods with @traced_span</name>
  <files>
    bot/services/llm_router.py
  </files>
  <action>
Add `@traced_span` decorator to both LLM provider `.complete()` methods in `bot/services/llm_router.py`. These spans become children of the agent span (since the agent calls llm.complete() inside its own traced run()).

1. Add import at the top:
```python
from bot.tracing import traced_span
```

2. Decorate `.complete()` methods:

**ClaudeProvider.complete()** (line ~84):
```python
@traced_span("llm:claude")
async def complete(
    self, system_prompt: str, user_message: str, *, image_b64: str | None = None,
) -> dict[str, Any]:
    # Existing implementation — NO changes to the method body
    ...
```

**OpenRouterProvider.complete()** (line ~155):
```python
@traced_span("llm:openrouter")
async def complete(
    self, system_prompt: str, user_message: str, *, image_b64: str | None = None,
) -> dict[str, Any]:
    # Existing implementation — NO changes to the method body
    ...
```

**Critical rules:**
- Do NOT modify the method body — only add the decorator and import
- The decorator captures the complete() call timing. Input serialization will capture system_prompt and user_message (as kwargs), output will capture the returned dict. This fulfills TRACE-04 (agent I/O capture).
- Note: system_prompt can be large (2-10KB). The traced_span decorator's _safe_serialize should truncate to 50KB total, which is fine for the JSONB column. If prompts are too large, the _safe_serialize in context.py handles truncation.
- Do NOT decorate validate_key() or close() — only the LLM call path
- Do NOT decorate the standalone web_research_call() function — it's not part of the pipeline execution flow
- The span hierarchy will be: TraceContext (pipeline) -> agent:trainer span -> llm:openrouter span (nested parent-child via _span_stack ContextVar)
  </action>
  <verify>
    - `python -c "import ast; ast.parse(open('bot/services/llm_router.py').read()); print('llm_router.py OK')"` succeeds
    - grep confirms `traced_span` appears in llm_router.py
    - grep confirms `@traced_span` appears exactly twice in llm_router.py (one per provider)
  </verify>
  <done>
    - ClaudeProvider.complete() decorated with @traced_span("llm:claude")
    - OpenRouterProvider.complete() decorated with @traced_span("llm:openrouter")
    - LLM call spans nest under agent spans via _span_stack ContextVar
    - No changes to LLM call logic, retry behavior, or error handling
    - validate_key(), close(), and web_research_call() are NOT instrumented
  </done>
</task>

</tasks>

<verification>
Syntax check all modified files:
```bash
cd deal-quest-bot
python -c "
import ast
for f in ['bot/agents/trainer.py', 'bot/agents/strategist.py', 'bot/agents/memory.py', 'bot/services/llm_router.py']:
    ast.parse(open(f).read())
    print(f'{f}: OK')
print('All files parse successfully')
"
```

Verify traced_span decorator is applied:
```bash
grep -n "traced_span" bot/agents/trainer.py bot/agents/strategist.py bot/agents/memory.py bot/services/llm_router.py
```
Expected: Each file has an import line and at least one @traced_span decorator.

Verify agent still works outside traced context (no-op test):
```bash
python -c "
import asyncio
from bot.agents.trainer import TrainerAgent
from bot.agents.base import AgentInput

# Agent should still be callable without a TraceContext active
agent = TrainerAgent()
print(f'TrainerAgent created: {agent.name}')
print('Agent instantiation OK — traced_span is no-op outside TraceContext')
"
```
</verification>

<success_criteria>
- All three agent .run() methods have @traced_span decorators
- Both LLM provider .complete() methods have @traced_span decorators
- No method bodies are modified — only decorators and imports added
- Agents work normally outside traced context (decorator is transparent no-op)
- All files parse without syntax errors
- Span naming convention: "agent:{name}" for agents, "llm:{provider}" for LLM calls
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
