---
phase: 01-foundation-and-auth
plan: 04
type: execute
wave: 3
depends_on: ["01-02", "01-03"]
files_modified:
  - deal-quest-bot/packages/webapp/src/app/App.tsx
  - deal-quest-bot/packages/webapp/src/app/Router.tsx
  - deal-quest-bot/packages/webapp/src/shared/hooks/useBackButton.ts
  - deal-quest-bot/packages/webapp/src/shared/hooks/useMainButton.ts
  - deal-quest-bot/packages/webapp/src/shared/hooks/useSecondaryButton.ts
  - deal-quest-bot/packages/webapp/src/shared/hooks/useSessionResilience.ts
  - deal-quest-bot/packages/webapp/src/pages/Dashboard.tsx
  - deal-quest-bot/packages/webapp/src/pages/Learn.tsx
  - deal-quest-bot/packages/webapp/src/pages/Train.tsx
  - deal-quest-bot/packages/webapp/src/pages/Support.tsx
  - deal-quest-bot/packages/webapp/src/pages/Casebook.tsx
  - deal-quest-bot/packages/webapp/src/pages/Leads.tsx
  - deal-quest-bot/packages/webapp/src/pages/Profile.tsx
  - deal-quest-bot/packages/webapp/src/pages/Admin.tsx
autonomous: false

must_haves:
  truths:
    - "All 8 page routes (Dashboard, Learn, Train, Support, Casebook, Leads, Profile, Admin) are accessible and render a page stub"
    - "Telegram BackButton shows on non-root routes and navigates back when tapped; hides on root route"
    - "MainButton hook allows any page to show/hide/configure the Telegram bottom button"
    - "SecondaryButton hook is available for scenario branching (Bot API 7.10+)"
    - "Backgrounding and reopening the TMA restores the user's session without re-authentication"
    - "The full app shell renders: AuthProvider -> QueryProvider -> BrowserRouter -> AppLayout with NavBar"
  artifacts:
    - path: "deal-quest-bot/packages/webapp/src/app/Router.tsx"
      provides: "Route definitions with lazy-loaded pages and BackButton integration"
      contains: "BrowserRouter"
    - path: "deal-quest-bot/packages/webapp/src/shared/hooks/useBackButton.ts"
      provides: "Hook that syncs Telegram BackButton with react-router location"
      contains: "backButton"
    - path: "deal-quest-bot/packages/webapp/src/shared/hooks/useMainButton.ts"
      provides: "Hook for showing/hiding/configuring Telegram MainButton"
      contains: "mainButton"
    - path: "deal-quest-bot/packages/webapp/src/shared/hooks/useSecondaryButton.ts"
      provides: "Hook for Telegram SecondaryButton (Bot API 7.10+)"
      contains: "secondaryButton"
    - path: "deal-quest-bot/packages/webapp/src/shared/hooks/useSessionResilience.ts"
      provides: "Hook for save/restore state on TMA background/activate events"
      contains: "activated"
    - path: "deal-quest-bot/packages/webapp/src/pages/Dashboard.tsx"
      provides: "Dashboard page stub"
      contains: "Dashboard"
  key_links:
    - from: "packages/webapp/src/app/Router.tsx"
      to: "packages/webapp/src/shared/hooks/useBackButton.ts"
      via: "useBackButton() called inside router context"
      pattern: "useBackButton"
    - from: "packages/webapp/src/app/App.tsx"
      to: "packages/webapp/src/app/Router.tsx"
      via: "AuthProvider -> QueryProvider -> AppRouter"
      pattern: "AppRouter|Router"
    - from: "packages/webapp/src/app/Router.tsx"
      to: "packages/webapp/src/shared/layouts/AppLayout.tsx"
      via: "Routes wrapped in AppLayout"
      pattern: "AppLayout"
    - from: "packages/webapp/src/shared/hooks/useSessionResilience.ts"
      to: "Telegram WebApp events"
      via: "activated/deactivated event listeners"
      pattern: "activated|deactivated|visibilitychange"
---

<objective>
Wire the routing shell with all 8 page stubs using react-router v7, integrate Telegram BackButton/MainButton/SecondaryButton as React hooks, implement session resilience for backgrounding, and connect everything (auth + design system + routing) into the final App.tsx provider tree.

Purpose: This is the integration plan that connects Plans 01-03 into a working app shell. After this plan, the TMA has a complete navigation structure, responsive buttons, and session resilience -- ready for feature pages in Phase 2+.
Output: A fully navigable TMA shell where all routes work, Telegram buttons respond, and state survives backgrounding.
</objective>

<execution_context>
@/Users/dmytrolevin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dmytrolevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-and-auth/01-RESEARCH.md
@.planning/phases/01-foundation-and-auth/01-02-SUMMARY.md
@.planning/phases/01-foundation-and-auth/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Telegram button hooks and session resilience hook</name>
  <files>
    deal-quest-bot/packages/webapp/src/shared/hooks/useBackButton.ts
    deal-quest-bot/packages/webapp/src/shared/hooks/useMainButton.ts
    deal-quest-bot/packages/webapp/src/shared/hooks/useSecondaryButton.ts
    deal-quest-bot/packages/webapp/src/shared/hooks/useSessionResilience.ts
  </files>
  <action>
    Create the four hooks that bridge Telegram SDK features into React:

    1. **useBackButton.ts**: Sync BackButton with react-router v7 navigation. Follow the exact pattern from research:
       ```typescript
       import { useEffect } from 'react';
       import { useLocation, useNavigate } from 'react-router';
       import { backButton } from '@telegram-apps/sdk-react';

       export function useBackButton() {
         const location = useLocation();
         const navigate = useNavigate();

         useEffect(() => {
           // Root route: hide back button
           if (location.pathname === '/') {
             if (backButton.hide.isAvailable()) {
               backButton.hide();
             }
             return;
           }

           // Non-root routes: show back button, wire click to navigate(-1)
           if (backButton.show.isAvailable()) {
             backButton.show();
           }

           const off = backButton.onClick(() => {
             navigate(-1);
           });

           return () => {
             off(); // Unsubscribe on cleanup
           };
         }, [location.pathname, navigate]);
       }
       ```
       **IMPORTANT**: Import from `react-router` NOT `react-router-dom`. Check `isAvailable()` before calling show/hide (some Telegram clients may not support it).

    2. **useMainButton.ts**: Hook for configuring the Telegram MainButton (bottom button):
       ```typescript
       import { useEffect } from 'react';
       import { mainButton } from '@telegram-apps/sdk-react';

       export function useMainButton(
         text: string,
         onClick: () => void,
         options?: { visible?: boolean; enabled?: boolean; color?: string; textColor?: string }
       ) {
         const { visible = true, enabled = true, color, textColor } = options || {};

         useEffect(() => {
           if (!mainButton.setParams.isAvailable()) return;

           mainButton.setParams({
             text,
             isVisible: visible,
             isEnabled: enabled,
             ...(color && { backgroundColor: color }),
             ...(textColor && { textColor }),
           });

           const off = mainButton.onClick(onClick);

           return () => {
             off();
             if (mainButton.setParams.isAvailable()) {
               mainButton.setParams({ isVisible: false });
             }
           };
         }, [text, onClick, visible, enabled, color, textColor]);
       }
       ```
       The hook hides the MainButton on cleanup (when the component using it unmounts). Pages that need the MainButton call this hook; pages that don't simply don't call it.

    3. **useSecondaryButton.ts**: Hook for SecondaryButton (Bot API 7.10+):
       ```typescript
       import { useEffect } from 'react';
       import { secondaryButton } from '@telegram-apps/sdk-react';

       export function useSecondaryButton(
         text: string,
         onClick: () => void,
         options?: { visible?: boolean; enabled?: boolean; position?: 'top' | 'bottom' }
       ) {
         const { visible = true, enabled = true, position = 'top' } = options || {};

         useEffect(() => {
           if (!secondaryButton.mount.isAvailable()) return;
           secondaryButton.mount();

           secondaryButton.setParams({
             text,
             isVisible: visible,
             isEnabled: enabled,
             position,
           });

           const off = secondaryButton.onClick(onClick);

           return () => {
             off();
             if (secondaryButton.setParams.isAvailable()) {
               secondaryButton.setParams({ isVisible: false });
             }
           };
         }, [text, onClick, visible, enabled, position]);
       }
       ```
       SecondaryButton is used for A/B scenario branching (TRAIN-06). Available on Bot API 7.10+. The hook gracefully no-ops on older clients via `isAvailable()` check.

    4. **useSessionResilience.ts**: Save/restore state on TMA backgrounding:
       ```typescript
       import { useEffect, useCallback } from 'react';

       export function useSessionResilience(
         saveState: () => Promise<void>,
         restoreState: () => Promise<void>
       ) {
         const handleSave = useCallback(() => {
           saveState().catch(console.error);
         }, [saveState]);

         const handleRestore = useCallback(() => {
           restoreState().catch(console.error);
         }, [restoreState]);

         useEffect(() => {
           // Telegram's native events via the raw WebApp bridge
           const webapp = (window as any).Telegram?.WebApp;

           if (webapp) {
             webapp.onEvent('activated', handleRestore);
             webapp.onEvent('deactivated', handleSave);
           }

           // Browser visibility change as fallback
           const handleVisibility = () => {
             if (document.hidden) {
               handleSave();
             } else {
               handleRestore();
             }
           };
           document.addEventListener('visibilitychange', handleVisibility);

           return () => {
             if (webapp) {
               webapp.offEvent('activated', handleRestore);
               webapp.offEvent('deactivated', handleSave);
             }
             document.removeEventListener('visibilitychange', handleVisibility);
           };
         }, [handleSave, handleRestore]);
       }
       ```
       The actual save/restore implementations are passed in by consuming pages/features. In Phase 1, the hook exists but is not actively used yet (no in-progress state to save). It will be wired in Phase 3 for training timer state, and Phase 4 for support input state.
  </action>
  <verify>
    1. `pnpm typecheck` passes
    2. All 4 hooks export correctly
    3. useBackButton imports from 'react-router' not 'react-router-dom'
    4. All Telegram SDK method calls are guarded with isAvailable() checks
    5. useSessionResilience listens to both Telegram events and visibilitychange
  </verify>
  <done>
    Four hooks are available: useBackButton (nav sync), useMainButton (primary CTA), useSecondaryButton (A/B branching), useSessionResilience (background state persistence). All gracefully degrade when Telegram features are unavailable.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create page stubs, Router, and wire App.tsx provider tree</name>
  <files>
    deal-quest-bot/packages/webapp/src/pages/Dashboard.tsx
    deal-quest-bot/packages/webapp/src/pages/Learn.tsx
    deal-quest-bot/packages/webapp/src/pages/Train.tsx
    deal-quest-bot/packages/webapp/src/pages/Support.tsx
    deal-quest-bot/packages/webapp/src/pages/Casebook.tsx
    deal-quest-bot/packages/webapp/src/pages/Leads.tsx
    deal-quest-bot/packages/webapp/src/pages/Profile.tsx
    deal-quest-bot/packages/webapp/src/pages/Admin.tsx
    deal-quest-bot/packages/webapp/src/app/Router.tsx
    deal-quest-bot/packages/webapp/src/app/App.tsx
  </files>
  <action>
    1. **Create 8 page stub components**. Each page stub should:
       - Be a default export (required for React.lazy)
       - Display the page name and a brief description
       - Use the Card component from shared/ui
       - Import useAuthStore to show the authenticated user's telegram_id (proves auth is working)
       - Be minimal (10-20 lines each)

       Example pattern for each stub:
       ```typescript
       // pages/Dashboard.tsx
       import { Card } from '@/shared/ui';
       import { useAuthStore } from '@/features/auth/store';

       export default function Dashboard() {
         const telegramId = useAuthStore((s) => s.telegramId);
         return (
           <div className="p-4 space-y-4">
             <h1 className="text-xl font-bold text-text-primary">Dashboard</h1>
             <Card>
               <p className="text-text-secondary">Welcome, User #{telegramId}</p>
               <p className="text-text-hint text-sm">XP, leaderboard, and quick actions coming in Phase 2</p>
             </Card>
           </div>
         );
       }
       ```

       Create stubs for: Dashboard, Learn, Train, Support, Casebook, Leads, Profile, Admin. Each should mention what features are coming in which phase.

    2. **Router.tsx**: Create the SPA router with lazy-loaded pages and BackButton integration:
       ```typescript
       import { BrowserRouter, Routes, Route, Navigate } from 'react-router';
       import { lazy, Suspense } from 'react';
       import { useBackButton } from '@/shared/hooks/useBackButton';
       import { AppLayout } from '@/shared/layouts/AppLayout';
       import { Skeleton } from '@/shared/ui';

       // Lazy-load all pages for code splitting
       const Dashboard = lazy(() => import('@/pages/Dashboard'));
       const Learn = lazy(() => import('@/pages/Learn'));
       const Train = lazy(() => import('@/pages/Train'));
       const Support = lazy(() => import('@/pages/Support'));
       const Casebook = lazy(() => import('@/pages/Casebook'));
       const Leads = lazy(() => import('@/pages/Leads'));
       const Profile = lazy(() => import('@/pages/Profile'));
       const Admin = lazy(() => import('@/pages/Admin'));

       function PageSkeleton() {
         return (
           <div className="p-4 space-y-4">
             <Skeleton className="h-8 w-48" />
             <Skeleton className="h-32 w-full" />
             <Skeleton className="h-32 w-full" />
           </div>
         );
       }

       function AppRoutes() {
         useBackButton(); // Sync Telegram BackButton with router

         return (
           <AppLayout>
             <Suspense fallback={<PageSkeleton />}>
               <Routes>
                 <Route path="/" element={<Dashboard />} />
                 <Route path="/learn/*" element={<Learn />} />
                 <Route path="/train/*" element={<Train />} />
                 <Route path="/support/*" element={<Support />} />
                 <Route path="/casebook" element={<Casebook />} />
                 <Route path="/leads/*" element={<Leads />} />
                 <Route path="/profile" element={<Profile />} />
                 <Route path="/admin/*" element={<Admin />} />
                 <Route path="*" element={<Navigate to="/" replace />} />
               </Routes>
             </Suspense>
           </AppLayout>
         );
       }

       export function AppRouter() {
         return (
           <BrowserRouter>
             <AppRoutes />
           </BrowserRouter>
         );
       }
       ```

       **CRITICAL**: Import everything from `react-router` (NOT `react-router-dom`). Use `React.lazy()` + `Suspense` for code splitting. `/*` suffix on routes that will have sub-routes (Learn, Train, Support, Leads, Admin). Casebook and Profile are single-page routes.

    3. **Update App.tsx** to wire the complete provider tree:
       ```typescript
       import { AuthProvider } from '@/app/providers/AuthProvider';
       import { QueryProvider } from '@/app/providers/QueryProvider';
       import { AppRouter } from '@/app/Router';

       export default function App() {
         return (
           <AuthProvider>
             <QueryProvider>
               <AppRouter />
             </QueryProvider>
           </AuthProvider>
         );
       }
       ```

       Provider order matters:
       - AuthProvider is outermost (blocks rendering until auth completes)
       - QueryProvider wraps router (data fetching available on all pages)
       - BrowserRouter is inside QueryProvider (routes can use queries)

    **NOTE**: The useSessionResilience hook is defined but NOT wired into App.tsx yet. It requires save/restore implementations that don't exist until Phase 3+ when training and support features have state worth preserving. The hook will be wired by specific feature pages when they are built. For now, its mere existence satisfies FOUND-08 at the scaffold level.
  </action>
  <verify>
    1. `pnpm typecheck` passes
    2. `pnpm build` succeeds and produces separate chunks per page (check dist/assets for multiple .js files)
    3. All 8 page routes are defined in Router.tsx
    4. App.tsx renders AuthProvider -> QueryProvider -> AppRouter
    5. Each page stub is a default export (required for React.lazy)
    6. No imports from 'react-router-dom' anywhere in the codebase
    7. BackButton hook is called inside BrowserRouter context (in AppRoutes)
  </verify>
  <done>
    All 8 routes render page stubs via lazy loading, Telegram BackButton syncs with navigation, provider tree is complete (Auth -> Query -> Router), and the app shell is fully functional.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete Phase 1 TMA shell: monorepo scaffold, Telegram auth via initData, InsForge client with JWT, RLS policies on all tables, custom branded design system with Telegram theme adaptation, routing shell with 8 pages, BackButton/MainButton/SecondaryButton hooks, and session resilience hook.
  </what-built>
  <how-to-verify>
    1. Open the TMA inside Telegram (use BotFather to set the Mini App URL to the dev server or a tunnel URL)
    2. Verify: App opens without a login screen -- authentication should be automatic and silent
    3. Verify: You see the Dashboard page stub with your Telegram user ID displayed
    4. Verify: Tap "Learn" in the bottom NavBar -- the Learn page stub loads, and the Telegram BackButton appears at the top
    5. Verify: Tap the BackButton -- you navigate back to Dashboard, and the BackButton disappears
    6. Verify: Navigate to each of the 5 NavBar items (Dashboard, Learn, Train, Support, Leads) -- all render their stubs
    7. Verify: The app uses your Telegram theme colors (dark mode users should see dark background)
    8. Verify: Bottom navigation is not cut off on iPhone (safe area handling)
    9. (Optional) Background the TMA and reopen -- verify no re-authentication prompt

    If testing in browser via web.telegram.org:
    - Visit the dev server URL (https://localhost:PORT with mkcert)
    - The mockEnv should provide a simulated Telegram environment
    - Navigation and design system should be visible even without real Telegram auth
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues found</resume-signal>
</task>

</tasks>

<verification>
1. `pnpm typecheck && pnpm build` both pass
2. Build output contains multiple JS chunks (code splitting working)
3. All 8 routes accessible
4. BackButton shows/hides correctly based on route depth
5. NavBar shows 5 items with active state
6. Auth flow: initData -> Edge Function -> JWT -> authenticated InsForge client
7. Design system: brand colors, Telegram theme adaptation, safe areas
8. No `localStorage` usage for JWT anywhere
9. No `env(safe-area-inset-*)` in any CSS
10. No `react-router-dom` imports
11. No `@telegram-apps/sdk` separate install (only sdk-react)
</verification>

<success_criteria>
- Complete navigable app shell renders inside Telegram
- Silent auth: user sees content, never a login screen
- BackButton navigates back on non-root routes, hides on Dashboard
- MainButton and SecondaryButton hooks are available for feature pages
- NavBar shows 5 main pages with active state
- Design system renders with Deal Quest branding + Telegram theme colors
- Code splitting: each page is a separate JS chunk
- Session resilience hook exists for future feature integration
- TypeScript compiles clean, build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-auth/01-04-SUMMARY.md`
</output>
