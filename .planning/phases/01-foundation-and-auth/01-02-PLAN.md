---
phase: 01-foundation-and-auth
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - deal-quest-bot/packages/webapp/src/lib/insforge.ts
  - deal-quest-bot/packages/webapp/src/features/auth/store.ts
  - deal-quest-bot/packages/webapp/src/features/auth/useAuth.ts
  - deal-quest-bot/packages/webapp/src/app/providers/AuthProvider.tsx
  - deal-quest-bot/packages/webapp/src/app/providers/QueryProvider.tsx
  - deal-quest-bot/functions/verify-telegram/index.ts
autonomous: true

user_setup:
  - service: InsForge
    why: "Edge Function deployment and environment secrets"
    env_vars:
      - name: TELEGRAM_BOT_TOKEN
        source: "Already exists in bot .env -- same token"
      - name: JWT_SECRET
        source: "InsForge Dashboard -> Settings -> API -> JWT Secret (or generate one)"
    dashboard_config:
      - task: "Deploy verify-telegram Edge Function via InsForge MCP tools"
        location: "Automated via mcp__insforge__create-function"

must_haves:
  truths:
    - "Opening the TMA inside Telegram authenticates the user automatically with no login screen"
    - "API calls to InsForge return data scoped to the authenticated user only (RLS enforced)"
    - "Invalid or expired initData is rejected with a 403 response"
    - "The InsForge client sends Authorization: Bearer {jwt} on all requests after auth"
  artifacts:
    - path: "deal-quest-bot/packages/webapp/src/lib/insforge.ts"
      provides: "InsForge client singleton with auth token management"
      contains: "createClient"
    - path: "deal-quest-bot/packages/webapp/src/features/auth/store.ts"
      provides: "Zustand auth store holding JWT, telegramId, userId"
      contains: "useAuthStore"
    - path: "deal-quest-bot/packages/webapp/src/features/auth/useAuth.ts"
      provides: "Auth hook that calls Edge Function and sets up authenticated client"
      contains: "authenticateWithTelegram"
    - path: "deal-quest-bot/packages/webapp/src/app/providers/AuthProvider.tsx"
      provides: "React provider that authenticates on mount, shows loading/error states"
      contains: "AuthProvider"
    - path: "deal-quest-bot/functions/verify-telegram/index.ts"
      provides: "InsForge Edge Function for initData HMAC-SHA256 validation and JWT minting"
      contains: "HMAC"
  key_links:
    - from: "packages/webapp/src/features/auth/useAuth.ts"
      to: "functions/verify-telegram/index.ts"
      via: "HTTP POST with initDataRaw"
      pattern: "functions.invoke.*verify-telegram"
    - from: "packages/webapp/src/features/auth/useAuth.ts"
      to: "packages/webapp/src/lib/insforge.ts"
      via: "Sets JWT on client after auth succeeds"
      pattern: "insforge|setAuth|createAuthenticatedClient"
    - from: "packages/webapp/src/app/providers/AuthProvider.tsx"
      to: "packages/webapp/src/features/auth/useAuth.ts"
      via: "Calls authenticate on mount"
      pattern: "authenticateWithTelegram|useAuth"
---

<objective>
Implement the Telegram initData authentication flow: an InsForge Edge Function validates initData HMAC-SHA256 signatures and mints JWTs, a client-side auth store manages tokens, and the InsForge client is configured to make authenticated API calls. Enable RLS on all InsForge tables with policies scoped to the authenticated user's telegram_id.

Purpose: Without working auth, no user can access the TMA. Without RLS, the anon key (shipped in the JS bundle) exposes the entire database. This plan is the security foundation.
Output: A working auth flow where Telegram initData -> Edge Function -> JWT -> authenticated InsForge client, plus RLS policies on all tables.
</objective>

<execution_context>
@/Users/dmytrolevin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dmytrolevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-and-auth/01-RESEARCH.md
@deal-quest-bot/bot/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create InsForge Edge Function for Telegram initData verification and JWT minting</name>
  <files>
    deal-quest-bot/functions/verify-telegram/index.ts
  </files>
  <action>
    Create the `verify-telegram` Edge Function following the exact pattern from the Phase 1 research doc. This function:

    1. **CORS handling**: Handle OPTIONS preflight with 204 + CORS headers. Include CORS headers on ALL responses (Access-Control-Allow-Origin: *, Access-Control-Allow-Methods: POST, OPTIONS, Access-Control-Allow-Headers: Content-Type, Authorization).

    2. **Parse request**: Extract `initDataRaw` from JSON body. Return 400 if missing.

    3. **HMAC-SHA256 validation** (follow Telegram's exact algorithm):
       a. Parse initDataRaw as URLSearchParams
       b. Extract and remove `hash` parameter
       c. Sort remaining params alphabetically by key
       d. Create data-check-string: `key=value` joined by `\n`
       e. Compute secret_key = HMAC-SHA256("WebAppData", bot_token)
       f. Compute computed_hash = HMAC-SHA256(secret_key, data_check_string)
       g. Compare computed_hash hex with the extracted hash
       h. Return 403 if mismatch

    4. **auth_date freshness check**: Reject if `auth_date` is older than 1 hour (3600 seconds). Return 403.

    5. **Extract user info**: Parse the `user` parameter as JSON to get telegram_id, username, first_name.

    6. **Upsert user in InsForge**:
       - Use `createClient` (injected by InsForge runtime) to query `users` table by `telegram_id`
       - If exists: update `username`, `first_name`, `last_active_at`, `updated_at`
       - If not exists: insert new row with `telegram_id`, `username`, `first_name`, `last_active_at`
       - Get the user's `id` from the result

    7. **Mint JWT**: Use `jose` library (works in Deno):
       - Import `SignJWT` from `jose`
       - Create JWT with claims: `{ sub: String(userId), telegram_id: telegramId, role: 'authenticated' }`
       - Sign with HS256 using `JWT_SECRET` from `Deno.env.get('JWT_SECRET')`
       - Set expiration to 1 hour
       - Set issuer to 'deal-quest-tma'

    8. **Return response**: JSON `{ jwt, user: { id, telegram_id, username, first_name } }` with 200 status.

    9. **Error handling**: Wrap everything in try/catch, return 500 with generic error on unexpected failures. Never expose stack traces or internal details.

    **Deploy the Edge Function** using `mcp__insforge__create-function` with:
    - name: `verify-telegram`
    - The function body from above
    - Ensure TELEGRAM_BOT_TOKEN and JWT_SECRET are set as environment secrets in InsForge

    **IMPORTANT**: The Edge Function uses `module.exports = async function(request) { ... }` pattern as specified by InsForge's Edge Function runtime. The `createClient` function is injected by the runtime -- do NOT import it. `Deno.env.get()` is available for secrets.

    **RLS Policies**: After the Edge Function is deployed, enable RLS on all tables and create policies. Use `mcp__insforge__run-raw-sql` to execute:

    ```sql
    -- Enable RLS on all tables
    ALTER TABLE users ENABLE ROW LEVEL SECURITY;
    ALTER TABLE attempts ENABLE ROW LEVEL SECURITY;
    ALTER TABLE track_progress ENABLE ROW LEVEL SECURITY;
    ALTER TABLE support_sessions ENABLE ROW LEVEL SECURITY;
    ALTER TABLE scenarios_seen ENABLE ROW LEVEL SECURITY;
    ALTER TABLE lead_registry ENABLE ROW LEVEL SECURITY;
    ALTER TABLE lead_activity_log ENABLE ROW LEVEL SECURITY;
    ALTER TABLE casebook ENABLE ROW LEVEL SECURITY;
    ALTER TABLE user_memory ENABLE ROW LEVEL SECURITY;

    -- Users: read/update own row
    CREATE POLICY "users_select_own" ON users FOR SELECT TO authenticated
      USING (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);
    CREATE POLICY "users_update_own" ON users FOR UPDATE TO authenticated
      USING (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);

    -- Attempts: read own, insert own
    CREATE POLICY "attempts_select_own" ON attempts FOR SELECT TO authenticated
      USING (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);
    CREATE POLICY "attempts_insert_own" ON attempts FOR INSERT TO authenticated
      WITH CHECK (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);

    -- Track progress: read/write own
    CREATE POLICY "track_progress_select_own" ON track_progress FOR SELECT TO authenticated
      USING (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);
    CREATE POLICY "track_progress_insert_own" ON track_progress FOR INSERT TO authenticated
      WITH CHECK (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);
    CREATE POLICY "track_progress_update_own" ON track_progress FOR UPDATE TO authenticated
      USING (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);

    -- Support sessions: read own, insert own
    CREATE POLICY "support_sessions_select_own" ON support_sessions FOR SELECT TO authenticated
      USING (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);
    CREATE POLICY "support_sessions_insert_own" ON support_sessions FOR INSERT TO authenticated
      WITH CHECK (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);

    -- Scenarios seen: read own, insert own
    CREATE POLICY "scenarios_seen_select_own" ON scenarios_seen FOR SELECT TO authenticated
      USING (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);
    CREATE POLICY "scenarios_seen_insert_own" ON scenarios_seen FOR INSERT TO authenticated
      WITH CHECK (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);

    -- Lead registry: full CRUD own
    CREATE POLICY "lead_registry_select_own" ON lead_registry FOR SELECT TO authenticated
      USING (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);
    CREATE POLICY "lead_registry_insert_own" ON lead_registry FOR INSERT TO authenticated
      WITH CHECK (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);
    CREATE POLICY "lead_registry_update_own" ON lead_registry FOR UPDATE TO authenticated
      USING (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);

    -- Lead activity log: read own (via lead_id join), insert own
    CREATE POLICY "lead_activity_select_own" ON lead_activity_log FOR SELECT TO authenticated
      USING (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);
    CREATE POLICY "lead_activity_insert_own" ON lead_activity_log FOR INSERT TO authenticated
      WITH CHECK (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);

    -- Casebook: read all (shared resource), insert by any authenticated user
    CREATE POLICY "casebook_select_all" ON casebook FOR SELECT TO authenticated
      USING (true);
    CREATE POLICY "casebook_insert_auth" ON casebook FOR INSERT TO authenticated
      WITH CHECK (true);

    -- User memory: read/write own
    CREATE POLICY "user_memory_select_own" ON user_memory FOR SELECT TO authenticated
      USING (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);
    CREATE POLICY "user_memory_insert_own" ON user_memory FOR INSERT TO authenticated
      WITH CHECK (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);
    CREATE POLICY "user_memory_update_own" ON user_memory FOR UPDATE TO authenticated
      USING (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);

    -- Allow anon role SELECT on users for leaderboard (top users, no sensitive fields)
    CREATE POLICY "users_select_leaderboard" ON users FOR SELECT TO anon
      USING (true);

    -- Allow anon role full access for the bot (bot uses anon key server-side)
    -- This is needed so the Python bot continues working after RLS is enabled
    CREATE POLICY "anon_full_attempts" ON attempts FOR ALL TO anon USING (true) WITH CHECK (true);
    CREATE POLICY "anon_full_track_progress" ON track_progress FOR ALL TO anon USING (true) WITH CHECK (true);
    CREATE POLICY "anon_full_support_sessions" ON support_sessions FOR ALL TO anon USING (true) WITH CHECK (true);
    CREATE POLICY "anon_full_scenarios_seen" ON scenarios_seen FOR ALL TO anon USING (true) WITH CHECK (true);
    CREATE POLICY "anon_full_lead_registry" ON lead_registry FOR ALL TO anon USING (true) WITH CHECK (true);
    CREATE POLICY "anon_full_lead_activity" ON lead_activity_log FOR ALL TO anon USING (true) WITH CHECK (true);
    CREATE POLICY "anon_full_casebook" ON casebook FOR ALL TO anon USING (true) WITH CHECK (true);
    CREATE POLICY "anon_full_user_memory" ON user_memory FOR ALL TO anon USING (true) WITH CHECK (true);
    CREATE POLICY "anon_full_users" ON users FOR ALL TO anon USING (true) WITH CHECK (true);
    ```

    **NOTE on anon policies**: The existing Python bot uses the anon key. Until the bot is migrated to a service role key, anon must retain full access. The RLS policies for `authenticated` role protect TMA users from each other. The anon full-access policies ensure the bot keeps working. This is a known compromise documented in the research open questions -- the bot should eventually migrate to a service role key in a future phase.

    **NOTE on JWT claims**: The RLS policies reference `request.jwt.claims` which is how PostgREST/Supabase-compatible systems pass JWT claims. If InsForge uses a different mechanism, the claim extraction pattern may need adjustment. Test the policies after deployment. If `current_setting('request.jwt.claims')` doesn't work, try `auth.jwt()->>'telegram_id'` or `auth.uid()` depending on InsForge's implementation.
  </action>
  <verify>
    1. Edge Function is deployed and responds to OPTIONS with 204 + CORS headers
    2. POST with valid initDataRaw returns 200 with { jwt, user }
    3. POST with tampered initDataRaw returns 403
    4. POST with expired auth_date (> 1hr) returns 403
    5. RLS is enabled on all tables: run `SELECT tablename, rowsecurity FROM pg_tables WHERE schemaname = 'public'` via SQL and verify all show `true`
  </verify>
  <done>
    Edge Function validates initData, mints JWT, upserts user. RLS enabled on all tables with authenticated-role policies scoped to telegram_id and anon-role full access for bot compatibility.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create client-side auth flow with InsForge client, Zustand store, and providers</name>
  <files>
    deal-quest-bot/packages/webapp/src/lib/insforge.ts
    deal-quest-bot/packages/webapp/src/features/auth/store.ts
    deal-quest-bot/packages/webapp/src/features/auth/useAuth.ts
    deal-quest-bot/packages/webapp/src/app/providers/AuthProvider.tsx
    deal-quest-bot/packages/webapp/src/app/providers/QueryProvider.tsx
  </files>
  <action>
    Create the client-side auth integration:

    1. **lib/insforge.ts**: Create InsForge client management:
       ```typescript
       import { createClient } from '@insforge/sdk';

       // Anon client for initial auth call (invoke Edge Function)
       export const insforgeAnon = createClient({
         baseUrl: import.meta.env.VITE_INSFORGE_URL,
         anonKey: import.meta.env.VITE_INSFORGE_ANON_KEY,
       });

       // Authenticated client -- created after JWT is obtained
       let insforgeAuth: ReturnType<typeof createClient> | null = null;

       export function createAuthenticatedClient(jwt: string) {
         insforgeAuth = createClient({
           baseUrl: import.meta.env.VITE_INSFORGE_URL,
           anonKey: jwt, // Use JWT as the auth token
         });
         return insforgeAuth;
       }

       export function getInsforge() {
         if (!insforgeAuth) {
           throw new Error('InsForge client not authenticated. Call createAuthenticatedClient first.');
         }
         return insforgeAuth;
       }
       ```

       **NOTE**: The exact mechanism for passing the JWT to InsForge SDK needs validation. The research identified this as an open question. The approach above passes the JWT as the anonKey since it's sent as `Authorization: Bearer` header. If this doesn't work, alternatives:
       - Create a wrapper that manually sets the Authorization header on each request
       - Use `insforgeAnon` with a custom fetch wrapper that injects the Bearer token
       Test during implementation and document the working pattern.

    2. **features/auth/store.ts**: Zustand auth store:
       ```typescript
       import { create } from 'zustand';

       interface AuthState {
         jwt: string | null;
         telegramId: number | null;
         userId: number | null;
         isAuthenticated: boolean;
         isLoading: boolean;
         error: string | null;
         setAuth: (jwt: string, telegramId: number, userId: number) => void;
         setLoading: (loading: boolean) => void;
         setError: (error: string | null) => void;
         clearAuth: () => void;
       }

       export const useAuthStore = create<AuthState>((set) => ({
         jwt: null,
         telegramId: null,
         userId: null,
         isAuthenticated: false,
         isLoading: true, // Start as loading
         error: null,
         setAuth: (jwt, telegramId, userId) => set({
           jwt, telegramId, userId, isAuthenticated: true, isLoading: false, error: null,
         }),
         setLoading: (isLoading) => set({ isLoading }),
         setError: (error) => set({ error, isLoading: false }),
         clearAuth: () => set({
           jwt: null, telegramId: null, userId: null, isAuthenticated: false, isLoading: false,
         }),
       }));
       ```
       JWT is stored in memory ONLY (not localStorage). On every TMA open, re-mint via Edge Function.

    3. **features/auth/useAuth.ts**: Auth hook:
       ```typescript
       import { retrieveLaunchParams } from '@telegram-apps/sdk-react';
       import { insforgeAnon, createAuthenticatedClient } from '@/lib/insforge';
       import { useAuthStore } from './store';

       export async function authenticateWithTelegram() {
         const { initDataRaw } = retrieveLaunchParams();

         if (!initDataRaw) {
           throw new Error('No initData available. Are you running inside Telegram?');
         }

         // Call Edge Function via InsForge functions API
         const { data, error } = await insforgeAnon.functions.invoke('verify-telegram', {
           body: { initDataRaw },
         });

         if (error || !data?.jwt) {
           throw new Error(error?.message || 'Authentication failed');
         }

         // Create authenticated client with the JWT
         createAuthenticatedClient(data.jwt);

         return {
           jwt: data.jwt,
           user: data.user,
         };
       }
       ```

    4. **app/providers/AuthProvider.tsx**: React provider that runs auth on mount:
       ```typescript
       import { useEffect, type ReactNode } from 'react';
       import { useAuthStore } from '@/features/auth/store';
       import { authenticateWithTelegram } from '@/features/auth/useAuth';

       export function AuthProvider({ children }: { children: ReactNode }) {
         const { isLoading, isAuthenticated, error, setAuth, setError } = useAuthStore();

         useEffect(() => {
           authenticateWithTelegram()
             .then(({ jwt, user }) => {
               setAuth(jwt, user.telegram_id, user.id);
             })
             .catch((err) => {
               console.error('Auth failed:', err);
               setError(err.message);
             });
         }, [setAuth, setError]);

         if (isLoading) {
           return <div className="flex items-center justify-center h-screen">
             <div className="text-text-hint">Authenticating...</div>
           </div>;
         }

         if (error) {
           return <div className="flex items-center justify-center h-screen">
             <div className="text-red-500">Auth error: {error}</div>
           </div>;
         }

         if (!isAuthenticated) {
           return null;
         }

         return <>{children}</>;
       }
       ```

    5. **app/providers/QueryProvider.tsx**: TanStack Query provider:
       ```typescript
       import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
       import type { ReactNode } from 'react';

       const queryClient = new QueryClient({
         defaultOptions: {
           queries: {
             staleTime: 5 * 60_000,  // 5 minutes
             retry: 1,
             refetchOnWindowFocus: false, // TMA lifecycle handled separately
           },
         },
       });

       export function QueryProvider({ children }: { children: ReactNode }) {
         return (
           <QueryClientProvider client={queryClient}>
             {children}
           </QueryClientProvider>
         );
       }
       ```

    6. **Update App.tsx** to wrap with providers in correct order:
       ```typescript
       // AuthProvider -> QueryProvider -> Router (router added in Plan 04)
       function App() {
         return (
           <AuthProvider>
             <QueryProvider>
               <div>Deal Quest TMA - Authenticated</div>
             </QueryProvider>
           </AuthProvider>
         );
       }
       ```

    **IMPORTANT**: Do NOT store JWT in localStorage. Memory only. Re-mint on every TMA open.
  </action>
  <verify>
    1. `cd deal-quest-bot && pnpm typecheck` passes
    2. `cd deal-quest-bot && pnpm build` succeeds
    3. Auth store exports are correct: useAuthStore with jwt, telegramId, userId, isAuthenticated
    4. InsForge client module exports insforgeAnon, createAuthenticatedClient, getInsforge
    5. AuthProvider renders loading state initially, then children after auth
  </verify>
  <done>
    Client-side auth flow is wired: Telegram launch -> authenticateWithTelegram() -> Edge Function -> JWT stored in Zustand -> InsForge client configured with JWT -> AuthProvider gates app rendering until auth completes.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles cleanly: `pnpm typecheck`
2. Build succeeds: `pnpm build`
3. Edge Function is deployed and reachable at InsForge URL
4. RLS is enabled on all public tables (verify via SQL query)
5. Auth store correctly initializes with loading state
6. No localStorage usage for JWT (grep confirms)
7. InsForge client singleton pattern works
</verification>

<success_criteria>
- Edge Function validates initData and returns JWT for valid Telegram users
- Edge Function rejects invalid signatures (403) and expired auth_date (403)
- RLS enabled on all 9+ tables with authenticated-role policies
- Bot continues working (anon-role full access policies)
- Client-side auth flow: launch params -> Edge Function -> JWT -> Zustand store
- Authenticated InsForge client created with JWT for all subsequent API calls
- TanStack Query provider configured with sensible defaults
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-auth/01-02-SUMMARY.md`
</output>
