---
phase: 01-foundation-and-auth
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - deal-quest-bot/packages/webapp/src/lib/insforge.ts
  - deal-quest-bot/packages/webapp/src/features/auth/store.ts
  - deal-quest-bot/packages/webapp/src/features/auth/useAuth.ts
  - deal-quest-bot/packages/webapp/src/app/providers/AuthProvider.tsx
  - deal-quest-bot/packages/webapp/src/app/providers/QueryProvider.tsx
  - deal-quest-bot/functions/verify-telegram/index.ts
  - deal-quest-bot/functions/data-proxy/index.ts  # conditional: only if Task 2b is needed
autonomous: true

user_setup:
  - service: InsForge
    why: "Edge Function deployment and environment secrets"
    env_vars:
      - name: TELEGRAM_BOT_TOKEN
        source: "Already exists in bot .env -- same token"
      - name: JWT_SECRET
        source: "InsForge Dashboard -> Settings -> API -> JWT Secret (or generate one)"
    dashboard_config:
      - task: "Deploy verify-telegram Edge Function via InsForge MCP tools"
        location: "Automated via mcp__insforge__create-function"

must_haves:
  truths:
    - "Opening the TMA inside Telegram authenticates the user automatically with no login screen"
    - "API calls to InsForge return data scoped to the authenticated user only (RLS enforced)"
    - "Invalid or expired initData is rejected with a 403 response"
    - "The InsForge client sends Authorization: Bearer {jwt} on all requests after auth"
    - "The Python bot continues to read/write all tables after RLS is enabled"
  artifacts:
    - path: "deal-quest-bot/packages/webapp/src/lib/insforge.ts"
      provides: "InsForge client singleton with auth token management"
      contains: "createClient"
    - path: "deal-quest-bot/packages/webapp/src/features/auth/store.ts"
      provides: "Zustand auth store holding JWT, telegramId, userId"
      contains: "useAuthStore"
    - path: "deal-quest-bot/packages/webapp/src/features/auth/useAuth.ts"
      provides: "Auth hook that calls Edge Function and sets up authenticated client"
      contains: "authenticateWithTelegram"
    - path: "deal-quest-bot/packages/webapp/src/app/providers/AuthProvider.tsx"
      provides: "React provider that authenticates on mount, shows loading/error states"
      contains: "AuthProvider"
    - path: "deal-quest-bot/functions/verify-telegram/index.ts"
      provides: "InsForge Edge Function for initData HMAC-SHA256 validation and JWT minting"
      contains: "HMAC"
  key_links:
    - from: "packages/webapp/src/features/auth/useAuth.ts"
      to: "functions/verify-telegram/index.ts"
      via: "HTTP POST with initDataRaw"
      pattern: "functions.invoke.*verify-telegram"
    - from: "packages/webapp/src/features/auth/useAuth.ts"
      to: "packages/webapp/src/lib/insforge.ts"
      via: "Sets JWT on client after auth succeeds"
      pattern: "insforge|setAuth|createAuthenticatedClient"
    - from: "packages/webapp/src/app/providers/AuthProvider.tsx"
      to: "packages/webapp/src/features/auth/useAuth.ts"
      via: "Calls authenticate on mount"
      pattern: "authenticateWithTelegram|useAuth"
    - from: "bot (Python)"
      to: "InsForge tables (all)"
      via: "anon key with anon-role full-access RLS policies"
      pattern: "anon_full_"
---

<objective>
Implement the Telegram initData authentication flow: an InsForge Edge Function validates initData HMAC-SHA256 signatures and mints JWTs, a client-side auth store manages tokens, and the InsForge client is configured to make authenticated API calls. Enable RLS on all InsForge tables with policies scoped to the authenticated user's telegram_id.

Purpose: Without working auth, no user can access the TMA. Without RLS, the anon key (shipped in the JS bundle) exposes the entire database. This plan is the security foundation.
Output: A working auth flow where Telegram initData -> Edge Function -> JWT -> authenticated InsForge client, plus RLS policies on all tables.
</objective>

<execution_context>
@/Users/dmytrolevin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dmytrolevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-and-auth/01-RESEARCH.md
@deal-quest-bot/bot/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1a: Create and deploy InsForge Edge Function for Telegram initData verification and JWT minting</name>
  <files>
    deal-quest-bot/functions/verify-telegram/index.ts
  </files>
  <action>
    Create the `verify-telegram` Edge Function following the exact pattern from the Phase 1 research doc. This function:

    1. **CORS handling**: Handle OPTIONS preflight with 204 + CORS headers. Include CORS headers on ALL responses (Access-Control-Allow-Origin: *, Access-Control-Allow-Methods: POST, OPTIONS, Access-Control-Allow-Headers: Content-Type, Authorization).

    2. **Parse request**: Extract `initDataRaw` from JSON body. Return 400 if missing.

    3. **HMAC-SHA256 validation** (follow Telegram's exact algorithm):
       a. Parse initDataRaw as URLSearchParams
       b. Extract and remove `hash` parameter
       c. Sort remaining params alphabetically by key
       d. Create data-check-string: `key=value` joined by `\n`
       e. Compute secret_key = HMAC-SHA256("WebAppData", bot_token)
       f. Compute computed_hash = HMAC-SHA256(secret_key, data_check_string)
       g. Compare computed_hash hex with the extracted hash
       h. Return 403 if mismatch

    4. **auth_date freshness check**: Reject if `auth_date` is older than 1 hour (3600 seconds). Return 403.

    5. **Extract user info**: Parse the `user` parameter as JSON to get telegram_id, username, first_name.

    6. **Upsert user in InsForge**:
       - Use `createClient` (injected by InsForge runtime) to query `users` table by `telegram_id`
       - If exists: update `username`, `first_name`, `last_active_at`, `updated_at`
       - If not exists: insert new row with `telegram_id`, `username`, `first_name`, `last_active_at`
       - Get the user's `id` from the result

    7. **Mint JWT**: Use `jose` library (works in Deno):
       - Import `SignJWT` from `jose`
       - Create JWT with claims: `{ sub: String(userId), telegram_id: telegramId, role: 'authenticated' }`
       - Sign with HS256 using `JWT_SECRET` from `Deno.env.get('JWT_SECRET')`
       - Set expiration to 1 hour
       - Set issuer to 'deal-quest-tma'

    8. **Return response**: JSON `{ jwt, user: { id, telegram_id, username, first_name } }` with 200 status.

    9. **Error handling**: Wrap everything in try/catch, return 500 with generic error on unexpected failures. Never expose stack traces or internal details.

    **Deploy the Edge Function** using `mcp__insforge__create-function` with:
    - name: `verify-telegram`
    - The function body from above
    - Ensure TELEGRAM_BOT_TOKEN and JWT_SECRET are set as environment secrets in InsForge

    **IMPORTANT**: The Edge Function uses `module.exports = async function(request) { ... }` pattern as specified by InsForge's Edge Function runtime. The `createClient` function is injected by the runtime -- do NOT import it. `Deno.env.get()` is available for secrets.
  </action>
  <verify>
    1. Edge Function is deployed and responds to OPTIONS with 204 + CORS headers
    2. POST with valid initDataRaw returns 200 with { jwt, user }
    3. POST with tampered initDataRaw returns 403
    4. POST with expired auth_date (> 1hr) returns 403
  </verify>
  <done>
    Edge Function validates initData, mints JWT, upserts user. Deployed and reachable at InsForge URL.
  </done>
</task>

<task type="auto">
  <name>Task 1b: Enable RLS on all tables with authenticated and anon policies</name>
  <files>
    (no local files -- SQL executed via mcp__insforge__run-raw-sql)
  </files>
  <action>
    After the Edge Function is deployed and verified in Task 1a, enable RLS on all tables and create policies. Use `mcp__insforge__run-raw-sql` to execute the following SQL statements. Execute them in two separate batches for safer rollback:

    **Batch 1: Enable RLS on all tables**
    ```sql
    ALTER TABLE users ENABLE ROW LEVEL SECURITY;
    ALTER TABLE attempts ENABLE ROW LEVEL SECURITY;
    ALTER TABLE track_progress ENABLE ROW LEVEL SECURITY;
    ALTER TABLE support_sessions ENABLE ROW LEVEL SECURITY;
    ALTER TABLE scenarios_seen ENABLE ROW LEVEL SECURITY;
    ALTER TABLE lead_registry ENABLE ROW LEVEL SECURITY;
    ALTER TABLE lead_activity_log ENABLE ROW LEVEL SECURITY;
    ALTER TABLE casebook ENABLE ROW LEVEL SECURITY;
    ALTER TABLE user_memory ENABLE ROW LEVEL SECURITY;
    ```

    **Batch 2: Create anon full-access policies FIRST (so bot keeps working immediately)**
    ```sql
    -- Allow anon role full access for the bot (bot uses anon key server-side)
    -- TODO: Migrate bot to service role key in a future phase, then remove these anon full-access policies.
    -- This is a known security compromise: anon key has full DB access until bot migration.
    CREATE POLICY "anon_full_users" ON users FOR ALL TO anon USING (true) WITH CHECK (true);
    CREATE POLICY "anon_full_attempts" ON attempts FOR ALL TO anon USING (true) WITH CHECK (true);
    CREATE POLICY "anon_full_track_progress" ON track_progress FOR ALL TO anon USING (true) WITH CHECK (true);
    CREATE POLICY "anon_full_support_sessions" ON support_sessions FOR ALL TO anon USING (true) WITH CHECK (true);
    CREATE POLICY "anon_full_scenarios_seen" ON scenarios_seen FOR ALL TO anon USING (true) WITH CHECK (true);
    CREATE POLICY "anon_full_lead_registry" ON lead_registry FOR ALL TO anon USING (true) WITH CHECK (true);
    CREATE POLICY "anon_full_lead_activity" ON lead_activity_log FOR ALL TO anon USING (true) WITH CHECK (true);
    CREATE POLICY "anon_full_casebook" ON casebook FOR ALL TO anon USING (true) WITH CHECK (true);
    CREATE POLICY "anon_full_user_memory" ON user_memory FOR ALL TO anon USING (true) WITH CHECK (true);
    ```

    **Batch 3: Create authenticated-role policies (scoped to telegram_id from JWT)**
    ```sql
    -- Users: read/update own row
    CREATE POLICY "users_select_own" ON users FOR SELECT TO authenticated
      USING (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);
    CREATE POLICY "users_update_own" ON users FOR UPDATE TO authenticated
      USING (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);

    -- Attempts: read own, insert own
    CREATE POLICY "attempts_select_own" ON attempts FOR SELECT TO authenticated
      USING (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);
    CREATE POLICY "attempts_insert_own" ON attempts FOR INSERT TO authenticated
      WITH CHECK (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);

    -- Track progress: read/write own
    CREATE POLICY "track_progress_select_own" ON track_progress FOR SELECT TO authenticated
      USING (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);
    CREATE POLICY "track_progress_insert_own" ON track_progress FOR INSERT TO authenticated
      WITH CHECK (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);
    CREATE POLICY "track_progress_update_own" ON track_progress FOR UPDATE TO authenticated
      USING (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);

    -- Support sessions: read own, insert own
    CREATE POLICY "support_sessions_select_own" ON support_sessions FOR SELECT TO authenticated
      USING (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);
    CREATE POLICY "support_sessions_insert_own" ON support_sessions FOR INSERT TO authenticated
      WITH CHECK (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);

    -- Scenarios seen: read own, insert own
    CREATE POLICY "scenarios_seen_select_own" ON scenarios_seen FOR SELECT TO authenticated
      USING (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);
    CREATE POLICY "scenarios_seen_insert_own" ON scenarios_seen FOR INSERT TO authenticated
      WITH CHECK (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);

    -- Lead registry: full CRUD own
    CREATE POLICY "lead_registry_select_own" ON lead_registry FOR SELECT TO authenticated
      USING (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);
    CREATE POLICY "lead_registry_insert_own" ON lead_registry FOR INSERT TO authenticated
      WITH CHECK (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);
    CREATE POLICY "lead_registry_update_own" ON lead_registry FOR UPDATE TO authenticated
      USING (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);

    -- Lead activity log: read own, insert own
    CREATE POLICY "lead_activity_select_own" ON lead_activity_log FOR SELECT TO authenticated
      USING (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);
    CREATE POLICY "lead_activity_insert_own" ON lead_activity_log FOR INSERT TO authenticated
      WITH CHECK (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);

    -- Casebook: read all (shared resource), insert by any authenticated user
    CREATE POLICY "casebook_select_all" ON casebook FOR SELECT TO authenticated
      USING (true);
    CREATE POLICY "casebook_insert_auth" ON casebook FOR INSERT TO authenticated
      WITH CHECK (true);

    -- User memory: read/write own
    CREATE POLICY "user_memory_select_own" ON user_memory FOR SELECT TO authenticated
      USING (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);
    CREATE POLICY "user_memory_insert_own" ON user_memory FOR INSERT TO authenticated
      WITH CHECK (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);
    CREATE POLICY "user_memory_update_own" ON user_memory FOR UPDATE TO authenticated
      USING (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);

    -- Allow anon role SELECT on users for leaderboard (top users, no sensitive fields)
    CREATE POLICY "users_select_leaderboard" ON users FOR SELECT TO anon
      USING (true);
    ```

    **NOTE on JWT claims**: The RLS policies reference `request.jwt.claims` which is how PostgREST/Supabase-compatible systems pass JWT claims. If InsForge uses a different mechanism, the claim extraction pattern may need adjustment. Test the policies after deployment. If `current_setting('request.jwt.claims')` doesn't work, try `auth.jwt()->>'telegram_id'` or `auth.uid()` depending on InsForge's implementation.

    **Rollback plan**: If RLS breaks the bot (detected in Task 3), disable RLS immediately with:
    ```sql
    ALTER TABLE users DISABLE ROW LEVEL SECURITY;
    -- (repeat for each table)
    ```
    Then debug the anon policies before re-enabling.
  </action>
  <verify>
    1. RLS is enabled on all tables: run `SELECT tablename, rowsecurity FROM pg_tables WHERE schemaname = 'public'` via SQL and verify all show `true`
    2. Verify policies exist: `SELECT tablename, policyname FROM pg_policies WHERE schemaname = 'public' ORDER BY tablename`
    3. Confirm anon full-access policies exist for all 9 tables
    4. Confirm authenticated-role policies exist scoped to telegram_id
    5. **Functional bot verification**: Run a bot-like query to confirm the system still works after RLS enablement:
       ```sql
       SET ROLE anon;
       SELECT COUNT(*) FROM users;
       RESET ROLE;
       ```
       This must return a count without error. If it fails with a permission error, the anon full-access policies are missing or incorrect -- fix before proceeding.
  </verify>
  <done>
    RLS enabled on all tables with authenticated-role policies scoped to telegram_id and anon-role full access for bot compatibility. Policies applied in safe order (anon first). Bot-like anon query verified working.
  </done>
</task>

<task type="auto">
  <name>Task 2a: Create client-side auth flow with InsForge client (primary JWT-as-anonKey approach)</name>
  <files>
    deal-quest-bot/packages/webapp/src/lib/insforge.ts
    deal-quest-bot/packages/webapp/src/features/auth/store.ts
    deal-quest-bot/packages/webapp/src/features/auth/useAuth.ts
    deal-quest-bot/packages/webapp/src/app/providers/AuthProvider.tsx
    deal-quest-bot/packages/webapp/src/app/providers/QueryProvider.tsx
  </files>
  <action>
    Create the client-side auth integration using the primary JWT-as-anonKey approach. InsForge is PostgREST-compatible, and PostgREST validates JWT Bearer tokens natively -- the SDK sends `anonKey` as `Authorization: Bearer {anonKey}`, so passing our custom JWT as the anonKey should work.

    1. **lib/insforge.ts**: Create InsForge client management:
       ```typescript
       import { createClient } from '@insforge/sdk';

       // Anon client for initial auth call (invoke Edge Function)
       export const insforgeAnon = createClient({
         baseUrl: import.meta.env.VITE_INSFORGE_URL,
         anonKey: import.meta.env.VITE_INSFORGE_ANON_KEY,
       });

       // Authenticated client -- created after JWT is obtained
       let insforgeAuth: ReturnType<typeof createClient> | null = null;

       export function createAuthenticatedClient(jwt: string) {
         // The InsForge SDK sends anonKey as Authorization: Bearer header.
         // By passing our custom JWT here, PostgREST receives it and
         // applies RLS policies based on the JWT claims.
         insforgeAuth = createClient({
           baseUrl: import.meta.env.VITE_INSFORGE_URL,
           anonKey: jwt,
         });
         return insforgeAuth;
       }

       export function getInsforge() {
         if (!insforgeAuth) {
           throw new Error('InsForge client not authenticated. Call createAuthenticatedClient first.');
         }
         return insforgeAuth;
       }
       ```

    2. **features/auth/store.ts**: Zustand auth store:
       ```typescript
       import { create } from 'zustand';

       interface AuthState {
         jwt: string | null;
         telegramId: number | null;
         userId: number | null;
         isAuthenticated: boolean;
         isLoading: boolean;
         error: string | null;
         setAuth: (jwt: string, telegramId: number, userId: number) => void;
         setLoading: (loading: boolean) => void;
         setError: (error: string | null) => void;
         clearAuth: () => void;
       }

       export const useAuthStore = create<AuthState>((set) => ({
         jwt: null,
         telegramId: null,
         userId: null,
         isAuthenticated: false,
         isLoading: true, // Start as loading
         error: null,
         setAuth: (jwt, telegramId, userId) => set({
           jwt, telegramId, userId, isAuthenticated: true, isLoading: false, error: null,
         }),
         setLoading: (isLoading) => set({ isLoading }),
         setError: (error) => set({ error, isLoading: false }),
         clearAuth: () => set({
           jwt: null, telegramId: null, userId: null, isAuthenticated: false, isLoading: false,
         }),
       }));
       ```
       JWT is stored in memory ONLY (not localStorage). On every TMA open, re-mint via Edge Function.

    3. **features/auth/useAuth.ts**: Auth hook with **mandatory validation query**:
       ```typescript
       import { retrieveLaunchParams } from '@telegram-apps/sdk-react';
       import { insforgeAnon, createAuthenticatedClient } from '@/lib/insforge';
       import { useAuthStore } from './store';

       export async function authenticateWithTelegram() {
         const { initDataRaw } = retrieveLaunchParams();

         if (!initDataRaw) {
           throw new Error('No initData available. Are you running inside Telegram?');
         }

         // Call Edge Function via InsForge functions API
         const { data, error } = await insforgeAnon.functions.invoke('verify-telegram', {
           body: { initDataRaw },
         });

         if (error || !data?.jwt) {
           throw new Error(error?.message || 'Authentication failed');
         }

         // Create authenticated client with the JWT
         const authClient = createAuthenticatedClient(data.jwt);

         // CRITICAL VALIDATION: Confirm JWT-as-anonKey actually works with RLS.
         // This query must return the authenticated user's own row only.
         const { data: testData, error: testError } = await authClient.database
           .from('users')
           .select('id, telegram_id')
           .limit(1);

         if (testError) {
           // JWT-as-anonKey FAILED. STOP here. Do NOT proceed.
           // Log the exact error for the executor to diagnose.
           console.error('[AUTH] JWT-as-anonKey validation FAILED:', testError);
           console.error('[AUTH] Executor must now proceed to Task 2b (Edge Function proxy fallback).');
           throw new Error(
             'STOP: JWT-as-anonKey not supported by InsForge. ' +
             'Execute Task 2b to implement Edge Function proxy fallback. ' +
             'Error: ' + (testError.message || JSON.stringify(testError))
           );
         }

         // Log success for debugging
         console.info('[AUTH] JWT-as-anonKey validated. RLS query returned:', testData);

         return {
           jwt: data.jwt,
           user: data.user,
         };
       }
       ```

    4. **app/providers/AuthProvider.tsx**: React provider that runs auth on mount:
       ```typescript
       import { useEffect, type ReactNode } from 'react';
       import { useAuthStore } from '@/features/auth/store';
       import { authenticateWithTelegram } from '@/features/auth/useAuth';

       export function AuthProvider({ children }: { children: ReactNode }) {
         const { isLoading, isAuthenticated, error, setAuth, setError } = useAuthStore();

         useEffect(() => {
           authenticateWithTelegram()
             .then(({ jwt, user }) => {
               setAuth(jwt, user.telegram_id, user.id);
             })
             .catch((err) => {
               console.error('Auth failed:', err);
               setError(err.message);
             });
         }, [setAuth, setError]);

         if (isLoading) {
           return <div className="flex items-center justify-center h-screen">
             <div className="text-text-hint">Authenticating...</div>
           </div>;
         }

         if (error) {
           return <div className="flex items-center justify-center h-screen">
             <div className="text-red-500">Auth error: {error}</div>
           </div>;
         }

         if (!isAuthenticated) {
           return null;
         }

         return <>{children}</>;
       }
       ```

    5. **app/providers/QueryProvider.tsx**: TanStack Query provider:
       ```typescript
       import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
       import type { ReactNode } from 'react';

       const queryClient = new QueryClient({
         defaultOptions: {
           queries: {
             staleTime: 5 * 60_000,  // 5 minutes
             retry: 1,
             refetchOnWindowFocus: false, // TMA lifecycle handled separately
           },
         },
       });

       export function QueryProvider({ children }: { children: ReactNode }) {
         return (
           <QueryClientProvider client={queryClient}>
             {children}
           </QueryClientProvider>
         );
       }
       ```

    6. **Update App.tsx** to wrap with providers in correct order:
       ```typescript
       // AuthProvider -> QueryProvider -> Router (router added in Plan 04)
       function App() {
         return (
           <AuthProvider>
             <QueryProvider>
               <div>Deal Quest TMA - Authenticated</div>
             </QueryProvider>
           </AuthProvider>
         );
       }
       ```

    **IMPORTANT**: Do NOT store JWT in localStorage. Memory only. Re-mint on every TMA open.
  </action>
  <verify>
    1. `cd deal-quest-bot && pnpm typecheck` passes
    2. `cd deal-quest-bot && pnpm build` succeeds
    3. Auth store exports are correct: useAuthStore with jwt, telegramId, userId, isAuthenticated
    4. InsForge client module exports insforgeAnon, createAuthenticatedClient, getInsforge
    5. AuthProvider renders loading state initially, then children after auth
    6. The authenticateWithTelegram() function includes the validation query against `users` table -- confirm it returns the user's own row without error
    7. If validation query fails: the error message clearly says "STOP" and directs executor to Task 2b
  </verify>
  <done>
    Client-side auth flow is wired with the primary JWT-as-anonKey approach: Telegram launch -> authenticateWithTelegram() -> Edge Function -> JWT stored in Zustand -> InsForge client configured with JWT -> validation query confirms RLS works -> AuthProvider gates app rendering. If the validation query fails, the error message explicitly stops execution and directs to Task 2b.
  </done>
</task>

<task type="auto">
  <name>Task 2b: [CONDITIONAL] Implement Edge Function proxy fallback â€” only execute if Task 2a validation failed</name>
  <files>
    deal-quest-bot/functions/data-proxy/index.ts
    deal-quest-bot/packages/webapp/src/lib/insforge.ts
  </files>
  <action>
    **SKIP this task entirely if Task 2a's validation query succeeded.** Only execute if the `authenticateWithTelegram()` validation threw the "STOP: JWT-as-anonKey not supported" error.

    If JWT-as-anonKey failed (InsForge validates the anonKey against its own registry and rejects unknown tokens), implement the Edge Function proxy pattern:

    1. **Create `functions/data-proxy/index.ts`** Edge Function:
       ```typescript
       // Edge Function that proxies authenticated data requests.
       // Client sends: { table, method, filters, body }
       // Edge Function validates JWT, then queries DB with server-side client.

       module.exports = async function(request) {
         // CORS
         if (request.method === 'OPTIONS') {
           return new Response(null, {
             status: 204,
             headers: {
               'Access-Control-Allow-Origin': '*',
               'Access-Control-Allow-Methods': 'POST, OPTIONS',
               'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Telegram-JWT',
             },
           });
         }

         const jwt = request.headers.get('X-Telegram-JWT');
         if (!jwt) {
           return new Response(JSON.stringify({ error: 'Missing JWT' }), { status: 401 });
         }

         // Verify JWT using jose
         const { jwtVerify } = await import('jose');
         const secret = new TextEncoder().encode(Deno.env.get('JWT_SECRET'));

         let claims;
         try {
           const result = await jwtVerify(jwt, secret);
           claims = result.payload;
         } catch {
           return new Response(JSON.stringify({ error: 'Invalid JWT' }), { status: 403 });
         }

         const { table, method, filters, select, body, limit } = await request.json();

         // Use the injected createClient (server-side, has full access)
         let query = createClient().database.from(table);

         if (method === 'select') {
           query = query.select(select || '*');
           // Enforce telegram_id scope for user-scoped tables
           const userScopedTables = [
             'users', 'attempts', 'track_progress', 'support_sessions',
             'scenarios_seen', 'lead_registry', 'lead_activity_log', 'user_memory'
           ];
           if (userScopedTables.includes(table)) {
             query = query.eq('telegram_id', claims.telegram_id);
           }
           if (filters) {
             for (const [key, value] of Object.entries(filters)) {
               query = query.eq(key, value);
             }
           }
           if (limit) query = query.limit(limit);
         } else if (method === 'insert') {
           query = query.insert({ ...body, telegram_id: claims.telegram_id });
         } else if (method === 'update') {
           query = query.update(body).eq('telegram_id', claims.telegram_id);
           if (filters) {
             for (const [key, value] of Object.entries(filters)) {
               query = query.eq(key, value);
             }
           }
         }

         const { data, error } = await query;

         if (error) {
           return new Response(JSON.stringify({ error: error.message }), { status: 400 });
         }

         return new Response(JSON.stringify({ data }), {
           status: 200,
           headers: {
             'Content-Type': 'application/json',
             'Access-Control-Allow-Origin': '*',
           },
         });
       };
       ```

    2. **Deploy** the `data-proxy` Edge Function using `mcp__insforge__create-function`.

    3. **Update `lib/insforge.ts`** to replace `createAuthenticatedClient` with `createProxiedClient`:
       ```typescript
       import { createClient } from '@insforge/sdk';

       export const insforgeAnon = createClient({
         baseUrl: import.meta.env.VITE_INSFORGE_URL,
         anonKey: import.meta.env.VITE_INSFORGE_ANON_KEY,
       });

       let _jwt: string | null = null;

       export function setAuthJwt(jwt: string) {
         _jwt = jwt;
       }

       // Proxied database interface that routes through Edge Function
       export function getInsforge() {
         if (!_jwt) {
           throw new Error('Not authenticated. Call setAuthJwt first.');
         }

         return {
           database: {
             from: (table: string) => createProxiedQuery(table, _jwt!),
           },
           // functions still go through insforgeAnon
           functions: insforgeAnon.functions,
         };
       }

       function createProxiedQuery(table: string, jwt: string) {
         let _select = '*';
         let _filters: Record<string, unknown> = {};
         let _limit: number | undefined;

         const query = {
           select(columns: string) { _select = columns; return query; },
           eq(key: string, value: unknown) { _filters[key] = value; return query; },
           limit(n: number) { _limit = n; return query; },
           async then(resolve: any, reject: any) {
             try {
               const { data, error } = await insforgeAnon.functions.invoke('data-proxy', {
                 body: { table, method: 'select', select: _select, filters: _filters, limit: _limit },
                 headers: { 'X-Telegram-JWT': jwt },
               });
               if (error) reject(error);
               else resolve({ data, error: null });
             } catch (e) { reject(e); }
           },
         };
         return query;
       }
       ```

    4. **Update `useAuth.ts`**: Replace `createAuthenticatedClient(data.jwt)` with `setAuthJwt(data.jwt)` and remove the validation query (the proxy handles scoping).

    **NOTE**: This fallback adds ~50ms latency per request but is guaranteed to work regardless of how InsForge validates the anonKey. Document the decision in the SUMMARY.
  </action>
  <verify>
    1. `data-proxy` Edge Function is deployed and responds to POST requests
    2. POST with valid JWT + `{ table: 'users', method: 'select' }` returns only the authenticated user's row
    3. POST without JWT returns 401
    4. POST with invalid JWT returns 403
    5. `pnpm typecheck` passes with the updated lib/insforge.ts
    6. `pnpm build` succeeds
  </verify>
  <done>
    Edge Function proxy fallback is deployed and wired. All authenticated data requests go through `data-proxy` with JWT in header. Client-side `getInsforge()` returns a proxied interface that mimics the InsForge client API. Decision documented in SUMMARY.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify bot compatibility after RLS enablement</name>
  <files>
    (no local files -- verification via bot testing and SQL queries)
  </files>
  <action>
    After Tasks 1a, 1b, and 2 are complete, verify the existing Python bot still works correctly with RLS enabled.

    1. **Test bot read operations**: Use `mcp__insforge__run-raw-sql` to simulate what the bot does (anon key queries):
       ```sql
       -- Simulate bot reading a user (uses anon role)
       SET ROLE anon;
       SELECT id, telegram_id, username, total_xp FROM users LIMIT 5;
       RESET ROLE;
       ```
       Verify rows are returned (anon full-access policy allows this).

    2. **Test bot write operations**: Use `mcp__insforge__run-raw-sql` to simulate bot inserts:
       ```sql
       SET ROLE anon;
       -- Test insert into attempts (what bot does after scoring)
       SELECT COUNT(*) FROM attempts;
       -- Test insert into track_progress
       SELECT COUNT(*) FROM track_progress;
       RESET ROLE;
       ```
       Verify no permission errors.

    3. **If bot operations fail**: The anon full-access policies from Task 1b are missing or incorrect.
       - Check: `SELECT policyname FROM pg_policies WHERE policyname LIKE 'anon_full_%'`
       - Fix: Re-run the anon policy creation SQL from Task 1b
       - If still broken: Disable RLS as a rollback (`ALTER TABLE X DISABLE ROW LEVEL SECURITY`) and investigate

    4. **Document the compromise**: Add a comment in the Edge Function file (functions/verify-telegram/index.ts) at the top:
       ```typescript
       // TODO: The Python bot currently uses the anon key which has full-access RLS policies.
       // This is a security compromise -- anon key in the JS bundle also gets full access.
       // Migration path: Bot should use a service role key (bypasses RLS) in a future phase.
       // Once migrated, remove all "anon_full_*" policies to lock down client-side access.
       ```
  </action>
  <verify>
    1. `SET ROLE anon; SELECT * FROM users LIMIT 1; RESET ROLE;` returns data without error
    2. `SET ROLE anon; SELECT * FROM attempts LIMIT 1; RESET ROLE;` returns data without error
    3. All 9 `anon_full_*` policies exist: `SELECT COUNT(*) FROM pg_policies WHERE policyname LIKE 'anon_full_%'` returns 9
    4. TODO comment exists in verify-telegram/index.ts documenting the anon compromise
  </verify>
  <done>
    Bot operations verified working after RLS enablement. Anon full-access compromise documented with TODO for future service role key migration.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles cleanly: `pnpm typecheck`
2. Build succeeds: `pnpm build`
3. Edge Function is deployed and reachable at InsForge URL
4. RLS is enabled on all public tables (verify via SQL query)
5. Auth store correctly initializes with loading state
6. No localStorage usage for JWT (grep confirms)
7. InsForge client singleton pattern works
8. Bot compatibility verified (anon role has full access to all tables)
9. JWT-as-anonKey validated with actual database query in auth flow
</verification>

<success_criteria>
- Edge Function validates initData and returns JWT for valid Telegram users
- Edge Function rejects invalid signatures (403) and expired auth_date (403)
- RLS enabled on all 9+ tables with authenticated-role policies
- Bot continues working (anon-role full access policies verified)
- Client-side auth flow: launch params -> Edge Function -> JWT -> Zustand store
- Authenticated InsForge client created with JWT, validated with a test query
- If JWT-as-anonKey fails, Edge Function proxy fallback is implemented
- TanStack Query provider configured with sensible defaults
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-auth/01-02-SUMMARY.md`
</output>
