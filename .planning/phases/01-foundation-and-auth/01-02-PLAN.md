---
phase: 01-foundation-and-auth
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - deal-quest-bot/packages/webapp/src/lib/insforge.ts
  - deal-quest-bot/packages/webapp/src/features/auth/store.ts
  - deal-quest-bot/packages/webapp/src/features/auth/useAuth.ts
  - deal-quest-bot/packages/webapp/src/app/providers/AuthProvider.tsx
  - deal-quest-bot/packages/webapp/src/app/providers/QueryProvider.tsx
  - deal-quest-bot/functions/verify-telegram/index.ts
autonomous: true

user_setup:
  - service: InsForge
    why: "Edge Function deployment and environment secrets"
    env_vars:
      - name: TELEGRAM_BOT_TOKEN
        source: "Already exists in bot .env -- same token"
      - name: JWT_SECRET
        source: "InsForge Dashboard -> Settings -> API -> JWT Secret (or generate one)"
    dashboard_config:
      - task: "Deploy verify-telegram Edge Function via InsForge MCP tools"
        location: "Automated via mcp__insforge__create-function"

must_haves:
  truths:
    - "Opening the TMA inside Telegram authenticates the user automatically with no login screen"
    - "API calls to InsForge return data scoped to the authenticated user only (RLS enforced)"
    - "Invalid or expired initData is rejected with a 403 response"
    - "The InsForge client sends Authorization: Bearer {jwt} on all requests after auth"
    - "The Python bot continues to read/write all tables after RLS is enabled"
  artifacts:
    - path: "deal-quest-bot/packages/webapp/src/lib/insforge.ts"
      provides: "InsForge client singleton with auth token management"
      contains: "createClient"
    - path: "deal-quest-bot/packages/webapp/src/features/auth/store.ts"
      provides: "Zustand auth store holding JWT, telegramId, userId"
      contains: "useAuthStore"
    - path: "deal-quest-bot/packages/webapp/src/features/auth/useAuth.ts"
      provides: "Auth hook that calls Edge Function and sets up authenticated client"
      contains: "authenticateWithTelegram"
    - path: "deal-quest-bot/packages/webapp/src/app/providers/AuthProvider.tsx"
      provides: "React provider that authenticates on mount, shows loading/error states"
      contains: "AuthProvider"
    - path: "deal-quest-bot/functions/verify-telegram/index.ts"
      provides: "InsForge Edge Function for initData HMAC-SHA256 validation and JWT minting"
      contains: "HMAC"
  key_links:
    - from: "packages/webapp/src/features/auth/useAuth.ts"
      to: "functions/verify-telegram/index.ts"
      via: "HTTP POST with initDataRaw"
      pattern: "functions.invoke.*verify-telegram"
    - from: "packages/webapp/src/features/auth/useAuth.ts"
      to: "packages/webapp/src/lib/insforge.ts"
      via: "Sets JWT on client after auth succeeds"
      pattern: "insforge|setAuth|createAuthenticatedClient"
    - from: "packages/webapp/src/app/providers/AuthProvider.tsx"
      to: "packages/webapp/src/features/auth/useAuth.ts"
      via: "Calls authenticate on mount"
      pattern: "authenticateWithTelegram|useAuth"
    - from: "bot (Python)"
      to: "InsForge tables (all)"
      via: "anon key with anon-role full-access RLS policies"
      pattern: "anon_full_"
---

<objective>
Implement the Telegram initData authentication flow: an InsForge Edge Function validates initData HMAC-SHA256 signatures and mints JWTs, a client-side auth store manages tokens, and the InsForge client is configured to make authenticated API calls. Enable RLS on all InsForge tables with policies scoped to the authenticated user's telegram_id.

Purpose: Without working auth, no user can access the TMA. Without RLS, the anon key (shipped in the JS bundle) exposes the entire database. This plan is the security foundation.
Output: A working auth flow where Telegram initData -> Edge Function -> JWT -> authenticated InsForge client, plus RLS policies on all tables.
</objective>

<execution_context>
@/Users/dmytrolevin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dmytrolevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-and-auth/01-RESEARCH.md
@deal-quest-bot/bot/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1a: Create and deploy InsForge Edge Function for Telegram initData verification and JWT minting</name>
  <files>
    deal-quest-bot/functions/verify-telegram/index.ts
  </files>
  <action>
    Create the `verify-telegram` Edge Function following the exact pattern from the Phase 1 research doc. This function:

    1. **CORS handling**: Handle OPTIONS preflight with 204 + CORS headers. Include CORS headers on ALL responses (Access-Control-Allow-Origin: *, Access-Control-Allow-Methods: POST, OPTIONS, Access-Control-Allow-Headers: Content-Type, Authorization).

    2. **Parse request**: Extract `initDataRaw` from JSON body. Return 400 if missing.

    3. **HMAC-SHA256 validation** (follow Telegram's exact algorithm):
       a. Parse initDataRaw as URLSearchParams
       b. Extract and remove `hash` parameter
       c. Sort remaining params alphabetically by key
       d. Create data-check-string: `key=value` joined by `\n`
       e. Compute secret_key = HMAC-SHA256("WebAppData", bot_token)
       f. Compute computed_hash = HMAC-SHA256(secret_key, data_check_string)
       g. Compare computed_hash hex with the extracted hash
       h. Return 403 if mismatch

    4. **auth_date freshness check**: Reject if `auth_date` is older than 1 hour (3600 seconds). Return 403.

    5. **Extract user info**: Parse the `user` parameter as JSON to get telegram_id, username, first_name.

    6. **Upsert user in InsForge**:
       - Use `createClient` (injected by InsForge runtime) to query `users` table by `telegram_id`
       - If exists: update `username`, `first_name`, `last_active_at`, `updated_at`
       - If not exists: insert new row with `telegram_id`, `username`, `first_name`, `last_active_at`
       - Get the user's `id` from the result

    7. **Mint JWT**: Use `jose` library (works in Deno):
       - Import `SignJWT` from `jose`
       - Create JWT with claims: `{ sub: String(userId), telegram_id: telegramId, role: 'authenticated' }`
       - Sign with HS256 using `JWT_SECRET` from `Deno.env.get('JWT_SECRET')`
       - Set expiration to 1 hour
       - Set issuer to 'deal-quest-tma'

    8. **Return response**: JSON `{ jwt, user: { id, telegram_id, username, first_name } }` with 200 status.

    9. **Error handling**: Wrap everything in try/catch, return 500 with generic error on unexpected failures. Never expose stack traces or internal details.

    **Deploy the Edge Function** using `mcp__insforge__create-function` with:
    - name: `verify-telegram`
    - The function body from above
    - Ensure TELEGRAM_BOT_TOKEN and JWT_SECRET are set as environment secrets in InsForge

    **IMPORTANT**: The Edge Function uses `module.exports = async function(request) { ... }` pattern as specified by InsForge's Edge Function runtime. The `createClient` function is injected by the runtime -- do NOT import it. `Deno.env.get()` is available for secrets.
  </action>
  <verify>
    1. Edge Function is deployed and responds to OPTIONS with 204 + CORS headers
    2. POST with valid initDataRaw returns 200 with { jwt, user }
    3. POST with tampered initDataRaw returns 403
    4. POST with expired auth_date (> 1hr) returns 403
  </verify>
  <done>
    Edge Function validates initData, mints JWT, upserts user. Deployed and reachable at InsForge URL.
  </done>
</task>

<task type="auto">
  <name>Task 1b: Enable RLS on all tables with authenticated and anon policies</name>
  <files>
    (no local files -- SQL executed via mcp__insforge__run-raw-sql)
  </files>
  <action>
    After the Edge Function is deployed and verified in Task 1a, enable RLS on all tables and create policies. Use `mcp__insforge__run-raw-sql` to execute the following SQL statements. Execute them in two separate batches for safer rollback:

    **Batch 1: Enable RLS on all tables**
    ```sql
    ALTER TABLE users ENABLE ROW LEVEL SECURITY;
    ALTER TABLE attempts ENABLE ROW LEVEL SECURITY;
    ALTER TABLE track_progress ENABLE ROW LEVEL SECURITY;
    ALTER TABLE support_sessions ENABLE ROW LEVEL SECURITY;
    ALTER TABLE scenarios_seen ENABLE ROW LEVEL SECURITY;
    ALTER TABLE lead_registry ENABLE ROW LEVEL SECURITY;
    ALTER TABLE lead_activity_log ENABLE ROW LEVEL SECURITY;
    ALTER TABLE casebook ENABLE ROW LEVEL SECURITY;
    ALTER TABLE user_memory ENABLE ROW LEVEL SECURITY;
    ```

    **Batch 2: Create anon full-access policies FIRST (so bot keeps working immediately)**
    ```sql
    -- Allow anon role full access for the bot (bot uses anon key server-side)
    -- TODO: Migrate bot to service role key in a future phase, then remove these anon full-access policies.
    -- This is a known security compromise: anon key has full DB access until bot migration.
    CREATE POLICY "anon_full_users" ON users FOR ALL TO anon USING (true) WITH CHECK (true);
    CREATE POLICY "anon_full_attempts" ON attempts FOR ALL TO anon USING (true) WITH CHECK (true);
    CREATE POLICY "anon_full_track_progress" ON track_progress FOR ALL TO anon USING (true) WITH CHECK (true);
    CREATE POLICY "anon_full_support_sessions" ON support_sessions FOR ALL TO anon USING (true) WITH CHECK (true);
    CREATE POLICY "anon_full_scenarios_seen" ON scenarios_seen FOR ALL TO anon USING (true) WITH CHECK (true);
    CREATE POLICY "anon_full_lead_registry" ON lead_registry FOR ALL TO anon USING (true) WITH CHECK (true);
    CREATE POLICY "anon_full_lead_activity" ON lead_activity_log FOR ALL TO anon USING (true) WITH CHECK (true);
    CREATE POLICY "anon_full_casebook" ON casebook FOR ALL TO anon USING (true) WITH CHECK (true);
    CREATE POLICY "anon_full_user_memory" ON user_memory FOR ALL TO anon USING (true) WITH CHECK (true);
    ```

    **Batch 3: Create authenticated-role policies (scoped to telegram_id from JWT)**
    ```sql
    -- Users: read/update own row
    CREATE POLICY "users_select_own" ON users FOR SELECT TO authenticated
      USING (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);
    CREATE POLICY "users_update_own" ON users FOR UPDATE TO authenticated
      USING (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);

    -- Attempts: read own, insert own
    CREATE POLICY "attempts_select_own" ON attempts FOR SELECT TO authenticated
      USING (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);
    CREATE POLICY "attempts_insert_own" ON attempts FOR INSERT TO authenticated
      WITH CHECK (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);

    -- Track progress: read/write own
    CREATE POLICY "track_progress_select_own" ON track_progress FOR SELECT TO authenticated
      USING (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);
    CREATE POLICY "track_progress_insert_own" ON track_progress FOR INSERT TO authenticated
      WITH CHECK (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);
    CREATE POLICY "track_progress_update_own" ON track_progress FOR UPDATE TO authenticated
      USING (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);

    -- Support sessions: read own, insert own
    CREATE POLICY "support_sessions_select_own" ON support_sessions FOR SELECT TO authenticated
      USING (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);
    CREATE POLICY "support_sessions_insert_own" ON support_sessions FOR INSERT TO authenticated
      WITH CHECK (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);

    -- Scenarios seen: read own, insert own
    CREATE POLICY "scenarios_seen_select_own" ON scenarios_seen FOR SELECT TO authenticated
      USING (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);
    CREATE POLICY "scenarios_seen_insert_own" ON scenarios_seen FOR INSERT TO authenticated
      WITH CHECK (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);

    -- Lead registry: full CRUD own
    CREATE POLICY "lead_registry_select_own" ON lead_registry FOR SELECT TO authenticated
      USING (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);
    CREATE POLICY "lead_registry_insert_own" ON lead_registry FOR INSERT TO authenticated
      WITH CHECK (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);
    CREATE POLICY "lead_registry_update_own" ON lead_registry FOR UPDATE TO authenticated
      USING (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);

    -- Lead activity log: read own, insert own
    CREATE POLICY "lead_activity_select_own" ON lead_activity_log FOR SELECT TO authenticated
      USING (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);
    CREATE POLICY "lead_activity_insert_own" ON lead_activity_log FOR INSERT TO authenticated
      WITH CHECK (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);

    -- Casebook: read all (shared resource), insert by any authenticated user
    CREATE POLICY "casebook_select_all" ON casebook FOR SELECT TO authenticated
      USING (true);
    CREATE POLICY "casebook_insert_auth" ON casebook FOR INSERT TO authenticated
      WITH CHECK (true);

    -- User memory: read/write own
    CREATE POLICY "user_memory_select_own" ON user_memory FOR SELECT TO authenticated
      USING (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);
    CREATE POLICY "user_memory_insert_own" ON user_memory FOR INSERT TO authenticated
      WITH CHECK (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);
    CREATE POLICY "user_memory_update_own" ON user_memory FOR UPDATE TO authenticated
      USING (telegram_id = (current_setting('request.jwt.claims', true)::json->>'telegram_id')::bigint);

    -- Allow anon role SELECT on users for leaderboard (top users, no sensitive fields)
    CREATE POLICY "users_select_leaderboard" ON users FOR SELECT TO anon
      USING (true);
    ```

    **NOTE on JWT claims**: The RLS policies reference `request.jwt.claims` which is how PostgREST/Supabase-compatible systems pass JWT claims. If InsForge uses a different mechanism, the claim extraction pattern may need adjustment. Test the policies after deployment. If `current_setting('request.jwt.claims')` doesn't work, try `auth.jwt()->>'telegram_id'` or `auth.uid()` depending on InsForge's implementation.

    **Rollback plan**: If RLS breaks the bot (detected in Task 3), disable RLS immediately with:
    ```sql
    ALTER TABLE users DISABLE ROW LEVEL SECURITY;
    -- (repeat for each table)
    ```
    Then debug the anon policies before re-enabling.
  </action>
  <verify>
    1. RLS is enabled on all tables: run `SELECT tablename, rowsecurity FROM pg_tables WHERE schemaname = 'public'` via SQL and verify all show `true`
    2. Verify policies exist: `SELECT tablename, policyname FROM pg_policies WHERE schemaname = 'public' ORDER BY tablename`
    3. Confirm anon full-access policies exist for all 9 tables
    4. Confirm authenticated-role policies exist scoped to telegram_id
  </verify>
  <done>
    RLS enabled on all tables with authenticated-role policies scoped to telegram_id and anon-role full access for bot compatibility. Policies applied in safe order (anon first).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create client-side auth flow with InsForge client, Zustand store, and providers</name>
  <files>
    deal-quest-bot/packages/webapp/src/lib/insforge.ts
    deal-quest-bot/packages/webapp/src/features/auth/store.ts
    deal-quest-bot/packages/webapp/src/features/auth/useAuth.ts
    deal-quest-bot/packages/webapp/src/app/providers/AuthProvider.tsx
    deal-quest-bot/packages/webapp/src/app/providers/QueryProvider.tsx
  </files>
  <action>
    Create the client-side auth integration:

    1. **lib/insforge.ts**: Create InsForge client management with a **concrete, validated JWT injection strategy**:

       **Primary approach** -- pass JWT as `anonKey` (the SDK sends `anonKey` as `Authorization: Bearer {anonKey}` on all requests, which is exactly how PostgREST/InsForge authenticates JWTs):
       ```typescript
       import { createClient } from '@insforge/sdk';

       // Anon client for initial auth call (invoke Edge Function)
       export const insforgeAnon = createClient({
         baseUrl: import.meta.env.VITE_INSFORGE_URL,
         anonKey: import.meta.env.VITE_INSFORGE_ANON_KEY,
       });

       // Authenticated client -- created after JWT is obtained
       let insforgeAuth: ReturnType<typeof createClient> | null = null;

       export function createAuthenticatedClient(jwt: string) {
         // The InsForge SDK sends anonKey as Authorization: Bearer header.
         // By passing our custom JWT here, PostgREST receives it and
         // applies RLS policies based on the JWT claims.
         insforgeAuth = createClient({
           baseUrl: import.meta.env.VITE_INSFORGE_URL,
           anonKey: jwt,
         });
         return insforgeAuth;
       }

       export function getInsforge() {
         if (!insforgeAuth) {
           throw new Error('InsForge client not authenticated. Call createAuthenticatedClient first.');
         }
         return insforgeAuth;
       }
       ```

       **Validation step (MUST do during implementation)**: After creating the authenticated client, immediately test it by running:
       ```typescript
       const { data, error } = await insforgeAuth.database.from('users').select('id, telegram_id').limit(1);
       ```
       - If this returns the authenticated user's row only (RLS filtering works) -> primary approach confirmed.
       - If this returns ALL users or an auth error -> primary approach failed, use fallback.

       **Guaranteed fallback** -- if JWT-as-anonKey does NOT work (InsForge validates the anonKey against its own registry and rejects unknown tokens), implement an Edge Function proxy pattern:
       ```typescript
       // Instead of direct database calls from the client, ALL authenticated
       // data requests go through Edge Functions:
       //   insforgeAnon.functions.invoke('data-proxy', {
       //     body: { table: 'users', method: 'select', filters: {...} },
       //     headers: { 'X-Telegram-JWT': jwt }
       //   })
       // The Edge Function validates the JWT, then uses the server-side client
       // (with service key or edgeFunctionToken) to query the database.
       // This adds ~50ms latency but is guaranteed to work.
       ```
       If the fallback is needed, create a `data-proxy` Edge Function and a `createProxiedClient()` wrapper that mimics the InsForge client API surface but routes through the proxy. Document the decision in the SUMMARY.

    2. **features/auth/store.ts**: Zustand auth store:
       ```typescript
       import { create } from 'zustand';

       interface AuthState {
         jwt: string | null;
         telegramId: number | null;
         userId: number | null;
         isAuthenticated: boolean;
         isLoading: boolean;
         error: string | null;
         setAuth: (jwt: string, telegramId: number, userId: number) => void;
         setLoading: (loading: boolean) => void;
         setError: (error: string | null) => void;
         clearAuth: () => void;
       }

       export const useAuthStore = create<AuthState>((set) => ({
         jwt: null,
         telegramId: null,
         userId: null,
         isAuthenticated: false,
         isLoading: true, // Start as loading
         error: null,
         setAuth: (jwt, telegramId, userId) => set({
           jwt, telegramId, userId, isAuthenticated: true, isLoading: false, error: null,
         }),
         setLoading: (isLoading) => set({ isLoading }),
         setError: (error) => set({ error, isLoading: false }),
         clearAuth: () => set({
           jwt: null, telegramId: null, userId: null, isAuthenticated: false, isLoading: false,
         }),
       }));
       ```
       JWT is stored in memory ONLY (not localStorage). On every TMA open, re-mint via Edge Function.

    3. **features/auth/useAuth.ts**: Auth hook:
       ```typescript
       import { retrieveLaunchParams } from '@telegram-apps/sdk-react';
       import { insforgeAnon, createAuthenticatedClient } from '@/lib/insforge';
       import { useAuthStore } from './store';

       export async function authenticateWithTelegram() {
         const { initDataRaw } = retrieveLaunchParams();

         if (!initDataRaw) {
           throw new Error('No initData available. Are you running inside Telegram?');
         }

         // Call Edge Function via InsForge functions API
         const { data, error } = await insforgeAnon.functions.invoke('verify-telegram', {
           body: { initDataRaw },
         });

         if (error || !data?.jwt) {
           throw new Error(error?.message || 'Authentication failed');
         }

         // Create authenticated client with the JWT
         const authClient = createAuthenticatedClient(data.jwt);

         // Validate the authenticated client actually works with RLS
         const { error: testError } = await authClient.database
           .from('users')
           .select('id')
           .limit(1);

         if (testError) {
           console.error('JWT-as-anonKey approach failed:', testError);
           // If this fails, the executor must implement the Edge Function proxy fallback
           // described in lib/insforge.ts. Throw a descriptive error.
           throw new Error(
             'InsForge client auth validation failed. JWT-as-anonKey may not be supported. ' +
             'Implement Edge Function proxy fallback (see lib/insforge.ts comments).'
           );
         }

         return {
           jwt: data.jwt,
           user: data.user,
         };
       }
       ```

    4. **app/providers/AuthProvider.tsx**: React provider that runs auth on mount:
       ```typescript
       import { useEffect, type ReactNode } from 'react';
       import { useAuthStore } from '@/features/auth/store';
       import { authenticateWithTelegram } from '@/features/auth/useAuth';

       export function AuthProvider({ children }: { children: ReactNode }) {
         const { isLoading, isAuthenticated, error, setAuth, setError } = useAuthStore();

         useEffect(() => {
           authenticateWithTelegram()
             .then(({ jwt, user }) => {
               setAuth(jwt, user.telegram_id, user.id);
             })
             .catch((err) => {
               console.error('Auth failed:', err);
               setError(err.message);
             });
         }, [setAuth, setError]);

         if (isLoading) {
           return <div className="flex items-center justify-center h-screen">
             <div className="text-text-hint">Authenticating...</div>
           </div>;
         }

         if (error) {
           return <div className="flex items-center justify-center h-screen">
             <div className="text-red-500">Auth error: {error}</div>
           </div>;
         }

         if (!isAuthenticated) {
           return null;
         }

         return <>{children}</>;
       }
       ```

    5. **app/providers/QueryProvider.tsx**: TanStack Query provider:
       ```typescript
       import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
       import type { ReactNode } from 'react';

       const queryClient = new QueryClient({
         defaultOptions: {
           queries: {
             staleTime: 5 * 60_000,  // 5 minutes
             retry: 1,
             refetchOnWindowFocus: false, // TMA lifecycle handled separately
           },
         },
       });

       export function QueryProvider({ children }: { children: ReactNode }) {
         return (
           <QueryClientProvider client={queryClient}>
             {children}
           </QueryClientProvider>
         );
       }
       ```

    6. **Update App.tsx** to wrap with providers in correct order:
       ```typescript
       // AuthProvider -> QueryProvider -> Router (router added in Plan 04)
       function App() {
         return (
           <AuthProvider>
             <QueryProvider>
               <div>Deal Quest TMA - Authenticated</div>
             </QueryProvider>
           </AuthProvider>
         );
       }
       ```

    **IMPORTANT**: Do NOT store JWT in localStorage. Memory only. Re-mint on every TMA open.
  </action>
  <verify>
    1. `cd deal-quest-bot && pnpm typecheck` passes
    2. `cd deal-quest-bot && pnpm build` succeeds
    3. Auth store exports are correct: useAuthStore with jwt, telegramId, userId, isAuthenticated
    4. InsForge client module exports insforgeAnon, createAuthenticatedClient, getInsforge
    5. AuthProvider renders loading state initially, then children after auth
    6. The authenticateWithTelegram() function includes the validation query against `users` table to confirm JWT-as-anonKey works
  </verify>
  <done>
    Client-side auth flow is wired: Telegram launch -> authenticateWithTelegram() -> Edge Function -> JWT stored in Zustand -> InsForge client configured with JWT -> validation query confirms RLS works -> AuthProvider gates app rendering until auth completes. If JWT-as-anonKey fails, executor implements the documented Edge Function proxy fallback.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify bot compatibility after RLS enablement</name>
  <files>
    (no local files -- verification via bot testing and SQL queries)
  </files>
  <action>
    After Tasks 1a, 1b, and 2 are complete, verify the existing Python bot still works correctly with RLS enabled.

    1. **Test bot read operations**: Use `mcp__insforge__run-raw-sql` to simulate what the bot does (anon key queries):
       ```sql
       -- Simulate bot reading a user (uses anon role)
       SET ROLE anon;
       SELECT id, telegram_id, username, total_xp FROM users LIMIT 5;
       RESET ROLE;
       ```
       Verify rows are returned (anon full-access policy allows this).

    2. **Test bot write operations**: Use `mcp__insforge__run-raw-sql` to simulate bot inserts:
       ```sql
       SET ROLE anon;
       -- Test insert into attempts (what bot does after scoring)
       SELECT COUNT(*) FROM attempts;
       -- Test insert into track_progress
       SELECT COUNT(*) FROM track_progress;
       RESET ROLE;
       ```
       Verify no permission errors.

    3. **If bot operations fail**: The anon full-access policies from Task 1b are missing or incorrect.
       - Check: `SELECT policyname FROM pg_policies WHERE policyname LIKE 'anon_full_%'`
       - Fix: Re-run the anon policy creation SQL from Task 1b
       - If still broken: Disable RLS as a rollback (`ALTER TABLE X DISABLE ROW LEVEL SECURITY`) and investigate

    4. **Document the compromise**: Add a comment in the Edge Function file (functions/verify-telegram/index.ts) at the top:
       ```typescript
       // TODO: The Python bot currently uses the anon key which has full-access RLS policies.
       // This is a security compromise -- anon key in the JS bundle also gets full access.
       // Migration path: Bot should use a service role key (bypasses RLS) in a future phase.
       // Once migrated, remove all "anon_full_*" policies to lock down client-side access.
       ```
  </action>
  <verify>
    1. `SET ROLE anon; SELECT * FROM users LIMIT 1; RESET ROLE;` returns data without error
    2. `SET ROLE anon; SELECT * FROM attempts LIMIT 1; RESET ROLE;` returns data without error
    3. All 9 `anon_full_*` policies exist: `SELECT COUNT(*) FROM pg_policies WHERE policyname LIKE 'anon_full_%'` returns 9
    4. TODO comment exists in verify-telegram/index.ts documenting the anon compromise
  </verify>
  <done>
    Bot operations verified working after RLS enablement. Anon full-access compromise documented with TODO for future service role key migration.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles cleanly: `pnpm typecheck`
2. Build succeeds: `pnpm build`
3. Edge Function is deployed and reachable at InsForge URL
4. RLS is enabled on all public tables (verify via SQL query)
5. Auth store correctly initializes with loading state
6. No localStorage usage for JWT (grep confirms)
7. InsForge client singleton pattern works
8. Bot compatibility verified (anon role has full access to all tables)
9. JWT-as-anonKey validated with actual database query in auth flow
</verification>

<success_criteria>
- Edge Function validates initData and returns JWT for valid Telegram users
- Edge Function rejects invalid signatures (403) and expired auth_date (403)
- RLS enabled on all 9+ tables with authenticated-role policies
- Bot continues working (anon-role full access policies verified)
- Client-side auth flow: launch params -> Edge Function -> JWT -> Zustand store
- Authenticated InsForge client created with JWT, validated with a test query
- If JWT-as-anonKey fails, Edge Function proxy fallback is implemented
- TanStack Query provider configured with sensible defaults
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-auth/01-02-SUMMARY.md`
</output>
