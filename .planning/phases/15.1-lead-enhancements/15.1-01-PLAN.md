---
phase: 15.1-lead-enhancements
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - insforge/migrations/003_web_research_versions.sql
  - bot/storage/models.py
  - bot/storage/repositories.py
  - bot/handlers/leads.py
  - bot/states.py
autonomous: true

must_haves:
  truths:
    - "User can trigger web research re-generation from bot lead menu"
    - "User can optionally provide URL for more accurate results"
    - "Previous research versions are preserved in JSONB array"
    - "User can delete irrelevant research versions"
  artifacts:
    - path: "insforge/migrations/003_web_research_versions.sql"
      provides: "Schema migration for web_research_versions JSONB column"
      contains: "web_research_versions"
    - path: "bot/storage/models.py"
      provides: "LeadRegistryModel with web_research_versions field"
      contains: "web_research_versions"
    - path: "bot/handlers/leads.py"
      provides: "Re-research callback handlers and delete version handlers"
      contains: "lead:reresearch"
  key_links:
    - from: "bot/handlers/leads.py"
      to: "bot/storage/repositories.py"
      via: "lead_repo.update_lead(lead_id, web_research_versions=...)"
      pattern: "web_research_versions"
    - from: "bot/handlers/leads.py"
      to: "bot/services/llm_router.py"
      via: "web_research_call for re-research"
      pattern: "web_research_call"
---

<objective>
Add web research versioning with re-run capability to the lead management system.

Purpose: Users can re-generate web research when initial research is incomplete or outdated, optionally providing a URL (LinkedIn profile, company website) for more accurate results. Version history is preserved so users can compare results and delete irrelevant versions.

Output:
- Migration SQL for web_research_versions JSONB column
- Updated LeadRegistryModel with new field
- Repository methods for version management
- Bot handlers for re-research flow and version deletion
</objective>

<execution_context>
@/Users/dmytrolevin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dmytrolevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15.1-lead-enhancements/15.1-RESEARCH.md

# Existing implementation to extend
@bot/handlers/leads.py
@bot/storage/models.py
@bot/storage/repositories.py
@bot/services/llm_router.py
@bot/states.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Schema migration and model updates</name>
  <files>
    insforge/migrations/003_web_research_versions.sql
    bot/storage/models.py
    bot/storage/repositories.py
  </files>
  <action>
1. Create migration `insforge/migrations/003_web_research_versions.sql`:
   - Add `web_research_versions JSONB DEFAULT NULL` column to lead_registry
   - Add comment explaining structure: `{"versions": [...], "current_version_id": N}`
   - Each version: `{version_id, created_at, query_used, url_provided, content, active}`
   - DO NOT drop or alter existing `web_research TEXT` column (keep for backward compat)

2. Update `bot/storage/models.py` LeadRegistryModel:
   - Add field: `web_research_versions: list[dict[str, Any]] | None = None`
   - Technically this stores `{"versions": [...], "current_version_id": N}` as the top-level object,
     but Pydantic will accept it as dict or list based on DB content

3. Update `bot/storage/repositories.py` LeadRegistryRepo:
   - Add method `async def add_research_version(self, lead_id: int, query: str, url: str | None, content: str) -> None`:
     * Fetch existing web_research_versions or init empty structure
     * Append new version with auto-incremented version_id
     * Set current_version_id to new version
     * Also update legacy `web_research` field with new content (backward compat)
   - Add method `async def delete_research_version(self, lead_id: int, version_id: int) -> None`:
     * Filter out version with matching version_id
     * If deleted version was current, set current to most recent remaining (or None)
     * Update legacy `web_research` to current version content or empty

Note: Keep migration as a separate file. User will run it manually per existing pattern.
  </action>
  <verify>
    - File exists: `ls insforge/migrations/003_web_research_versions.sql`
    - Model has field: `grep "web_research_versions" bot/storage/models.py`
    - Repo has methods: `grep "add_research_version\|delete_research_version" bot/storage/repositories.py`
  </verify>
  <done>
    - Migration SQL ready for user to run on InsForge
    - LeadRegistryModel has web_research_versions field
    - Repository has add_research_version and delete_research_version methods
  </done>
</task>

<task type="auto">
  <name>Task 2: Re-research flow handlers</name>
  <files>
    bot/states.py
    bot/handlers/leads.py
  </files>
  <action>
1. Update `bot/states.py`:
   - Add to LeadEngagementState: `reresearch_input = State()`

2. Update `bot/handlers/leads.py`:

Add re-research button to `_lead_detail_keyboard()`:
   - In the top_row after "View Plan" button, add:
     `InlineKeyboardButton(text="ðŸ”¬ Re-research", callback_data=f"lead:reresearch:{lead_id}")`
   - Only show if lead has web_research (can re-run) OR doesn't have it (initial run)

Add callback handler `@router.callback_query(F.data.startswith("lead:reresearch:"))`:
   - Set FSM state to `LeadEngagementState.reresearch_input`
   - Store lead_id in state data
   - Send message:
     "Re-running web research for this lead.\n\n"
     "Optionally, provide a URL (LinkedIn profile, company page) for more accurate results.\n"
     "Or send 'go' to re-run with existing info.\n\n"
     "_Send /cancel to go back._"

Add message handler `@router.message(LeadEngagementState.reresearch_input, F.text)`:
   - Check for /cancel -> clear state, return to lead view
   - If text is "go" (case insensitive), url = None
   - Otherwise, extract URL from text (simple check for http/https or linkedin.com)
   - Send status message "Generating web research..."
   - Call `web_research_call(openrouter_key, query)` where query includes:
     * Lead name, company, geography
     * URL if provided (append to query: "Focus on this profile: {url}")
   - Call `lead_repo.add_research_version(lead_id, query, url, research_content)`
   - Clear state, show success message with button to view lead

Add "View Research Versions" button and handler if multiple versions exist:
   - In lead detail, if `web_research_versions` has >1 version, show "View Versions" button
   - Handler shows numbered list of versions with created_at timestamps
   - Each version has a "Delete" button: `lead:delversion:{lead_id}:{version_id}`

Add delete version handler `@router.callback_query(F.data.startswith("lead:delversion:"))`:
   - Extract lead_id and version_id from callback data
   - Call `lead_repo.delete_research_version(lead_id, version_id)`
   - Show confirmation and refresh versions view
  </action>
  <verify>
    - State exists: `grep "reresearch_input" bot/states.py`
    - Handlers exist: `grep "lead:reresearch\|lead:delversion" bot/handlers/leads.py`
    - Re-research flow works with: bot test using /leads -> select lead -> Re-research -> "go"
  </verify>
  <done>
    - Re-research button appears in lead detail
    - User can send URL or "go" to trigger re-research
    - Version history is preserved
    - User can view and delete individual versions
  </done>
</task>

</tasks>

<verification>
1. Schema migration file exists and is syntactically valid SQL
2. Model and repository updates don't break existing lead operations
3. Re-research flow in bot:
   - User opens lead detail
   - Taps "Re-research" button
   - Can send URL or type "go"
   - Research is generated and saved as new version
   - Can view multiple versions if they exist
   - Can delete a specific version
</verification>

<success_criteria>
- Migration SQL file ready for user to apply
- LeadRegistryModel includes web_research_versions field
- Repository has version management methods
- Bot handlers implement re-research flow with URL input
- Bot handlers implement version viewing and deletion
- Existing lead functionality (status changes, plan toggle, etc.) remains unaffected
</success_criteria>

<output>
After completion, create `.planning/phases/15.1-lead-enhancements/15.1-01-SUMMARY.md`
</output>
