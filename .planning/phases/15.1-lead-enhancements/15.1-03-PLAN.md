---
phase: 15.1-lead-enhancements
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - bot/states.py
  - bot/handlers/comment.py
  - bot/main.py
  - prompts/standalone_comment.md
autonomous: true

must_haves:
  truths:
    - "User can send /comment to start standalone comment suggestion mode"
    - "User can send LinkedIn POST screenshot and receive comment suggestions"
    - "Comments can be regenerated with different tone without leaving conversation"
    - "Flow works independently of existing leads"
  artifacts:
    - path: "bot/handlers/comment.py"
      provides: "Standalone /comment command and flow handlers"
      exports: ["router"]
    - path: "bot/states.py"
      provides: "CommentSupportState FSM states"
      contains: "CommentSupportState"
    - path: "prompts/standalone_comment.md"
      provides: "System prompt for standalone comment generation"
      contains: "comment"
  key_links:
    - from: "bot/handlers/comment.py"
      to: "bot/services/llm_router.py"
      via: "create_provider for LLM calls"
      pattern: "create_provider"
    - from: "bot/main.py"
      to: "bot/handlers/comment.py"
      via: "router registration"
      pattern: "comment"
---

<objective>
Add a standalone /comment command for generating LinkedIn post comment suggestions.

Purpose: Users can get comment suggestions for any LinkedIn post without needing an existing lead. This is useful for general engagement or when building rapport with potential prospects before creating a full lead entry.

Output:
- New FSM state group: CommentSupportState
- New handler module: bot/handlers/comment.py
- New prompt: prompts/standalone_comment.md
- Main.py registration of new router
</objective>

<execution_context>
@/Users/dmytrolevin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dmytrolevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15.1-lead-enhancements/15.1-RESEARCH.md

# Existing patterns to follow
@bot/handlers/support.py
@bot/handlers/leads.py
@bot/services/engagement.py
@bot/states.py
@bot/main.py
@prompts/comment_generator.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: FSM states and standalone comment prompt</name>
  <files>
    bot/states.py
    prompts/standalone_comment.md
  </files>
  <action>
1. Update `bot/states.py`:
   - Add new state group after LeadEngagementState:
     ```python
     class CommentSupportState(StatesGroup):
         waiting_screenshot = State()
         refining_comment = State()
     ```

2. Create `prompts/standalone_comment.md`:
   - System prompt for generating comment suggestions on LinkedIn posts
   - Key differences from comment_generator.md (which is lead-context aware):
     * No prospect context provided (standalone mode)
     * Focus on the post content visible in screenshot
     * Generate 3 comment options with different tones:
       - Professional/Thoughtful
       - Casual/Friendly
       - Value-Adding (shares insight/asks question)
     * Each comment should:
       - Reference specific content from the post
       - Add value (not just "Great post!")
       - Be appropriate for LinkedIn professional context
       - Stay under 300 characters (LinkedIn sweet spot)

   Prompt structure:
   ```markdown
   # Standalone Comment Generator

   You are helping a sales professional engage authentically on LinkedIn.
   Generate comment suggestions for the post shown in the screenshot.

   ## Guidelines
   - Reference specific content from the post
   - Add genuine value (insight, question, perspective)
   - Avoid generic praise ("Great post!", "Love this!")
   - Stay professional but personable
   - Keep under 300 characters

   ## Output Format
   Provide exactly 3 comment options:

   **Option 1 (Professional/Thoughtful):**
   [comment text]

   **Option 2 (Casual/Friendly):**
   [comment text]

   **Option 3 (Value-Adding Question):**
   [comment text]
   ```
  </action>
  <verify>
    - State exists: `grep "CommentSupportState" bot/states.py`
    - Prompt exists: `ls prompts/standalone_comment.md`
    - Prompt has 3 options: `grep "Option 1\|Option 2\|Option 3" prompts/standalone_comment.md`
  </verify>
  <done>
    - CommentSupportState with waiting_screenshot and refining_comment states
    - Standalone comment prompt with 3-option format
  </done>
</task>

<task type="auto">
  <name>Task 2: Comment handler module with regeneration</name>
  <files>
    bot/handlers/comment.py
    bot/main.py
  </files>
  <action>
1. Create `bot/handlers/comment.py`:

```python
"""Handler for /comment -- standalone LinkedIn post comment suggestions."""

from __future__ import annotations

import base64
import io
import logging
from pathlib import Path

from aiogram import Bot, F, Router
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.types import (
    CallbackQuery,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    Message,
)

from bot.services.crypto import CryptoService
from bot.services.llm_router import create_provider
from bot.services.image_utils import pre_resize_image
from bot.states import CommentSupportState
from bot.storage.repositories import UserRepo
from bot.utils import truncate_message

logger = logging.getLogger(__name__)

router = Router(name="comment")

PROMPTS_DIR = Path(__file__).resolve().parent.parent.parent / "prompts"

def _load_prompt(name: str) -> str:
    return (PROMPTS_DIR / name).read_text(encoding="utf-8")


def _comment_actions_keyboard() -> InlineKeyboardMarkup:
    """Build comment actions keyboard for regeneration."""
    return InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text="ðŸ”„ Regenerate", callback_data="comment:regen"),
            InlineKeyboardButton(text="ðŸ”¥ Bolder", callback_data="comment:bolder"),
        ],
        [
            InlineKeyboardButton(text="ðŸ’¼ More Professional", callback_data="comment:professional"),
            InlineKeyboardButton(text="âœ… Done", callback_data="comment:done"),
        ],
    ])


@router.message(Command("comment"))
async def cmd_comment(message: Message, state: FSMContext, user_repo: UserRepo) -> None:
    """Start standalone comment suggestion mode."""
    tg_id = message.from_user.id

    user = await user_repo.get_by_telegram_id(tg_id)
    if not user or not user.encrypted_api_key:
        await message.answer("Please run /start first to set up your account.")
        return

    await message.answer(
        "ðŸ’¬ *Comment Suggestion Mode*\n\n"
        "Send me a screenshot of the LinkedIn POST you want to comment on.\n\n"
        "I'll analyze the post content and generate engaging comment options "
        "that add value without being salesy.\n\n"
        "_This works best for posts about industry topics, achievements, or insights._\n\n"
        "_Send /cancel to exit._",
        parse_mode="Markdown",
    )
    await state.set_state(CommentSupportState.waiting_screenshot)


@router.message(CommentSupportState.waiting_screenshot, F.photo)
async def on_comment_photo(
    message: Message,
    state: FSMContext,
    bot: Bot,
    user_repo: UserRepo,
    crypto: CryptoService,
) -> None:
    """Process screenshot and generate comment suggestions."""
    tg_id = message.from_user.id

    user = await user_repo.get_by_telegram_id(tg_id)
    if not user or not user.encrypted_api_key:
        await message.answer("Please run /start first.")
        return

    status_msg = await message.answer("ðŸ“¸ Analyzing post and generating comments...")

    # Download and resize photo
    photo = message.photo[-1]
    file = await bot.get_file(photo.file_id)
    file_bytes_io = io.BytesIO()
    await bot.download_file(file.file_path, file_bytes_io)
    file_bytes = pre_resize_image(file_bytes_io.getvalue())
    photo_b64 = base64.b64encode(file_bytes).decode("ascii")

    # Store for regeneration
    await state.update_data(screenshot_b64=photo_b64)

    # Generate comments
    try:
        api_key = crypto.decrypt(user.encrypted_api_key)
        if not api_key:
            await status_msg.edit_text("Failed to decrypt API key. Please update in /settings.")
            return

        model = user.openrouter_model if user.provider == "openrouter" else None
        llm = create_provider(user.provider, api_key, model)

        system_prompt = _load_prompt("standalone_comment.md")
        user_message = "Generate comment suggestions for the LinkedIn post shown in this screenshot."

        result = await llm.complete(system_prompt, user_message, image_b64=photo_b64)
        await llm.close()

        # Extract text from result
        if isinstance(result, dict):
            comment_text = result.get("raw_response", "") or str(result)
        else:
            comment_text = str(result)

        await state.update_data(last_comments=comment_text)
        await state.set_state(CommentSupportState.refining_comment)

        await status_msg.edit_text(
            f"ðŸ’¬ *Comment Suggestions:*\n\n{comment_text}\n\n"
            "_Tap to regenerate with different styles, or Done when satisfied._",
            parse_mode="Markdown",
            reply_markup=_comment_actions_keyboard(),
        )

    except Exception as e:
        logger.error("Comment generation failed: %s", e)
        await status_msg.edit_text(f"Failed to generate comments: {str(e)[:200]}")


@router.message(CommentSupportState.waiting_screenshot, F.text)
async def on_comment_cancel_check(message: Message, state: FSMContext) -> None:
    """Handle text in screenshot mode (probably /cancel)."""
    text = message.text or ""
    if text.strip().lower() == "/cancel":
        await state.clear()
        await message.answer("Comment mode cancelled.")
    else:
        await message.answer("Please send a screenshot of the LinkedIn post, or /cancel to exit.")


@router.callback_query(F.data.startswith("comment:"))
async def on_comment_action(
    callback: CallbackQuery,
    state: FSMContext,
    user_repo: UserRepo,
    crypto: CryptoService,
) -> None:
    """Handle comment regeneration actions."""
    action = callback.data.split(":")[1]

    if action == "done":
        await callback.message.edit_reply_markup(reply_markup=None)
        await callback.answer("Great! Copy your favorite comment and engage!")
        await state.clear()
        return

    data = await state.get_data()
    screenshot_b64 = data.get("screenshot_b64")

    if not screenshot_b64:
        await callback.answer("No screenshot found. Send a new one.")
        return

    tg_id = callback.from_user.id
    user = await user_repo.get_by_telegram_id(tg_id)
    if not user or not user.encrypted_api_key:
        await callback.answer("Please run /start first.")
        return

    await callback.answer("Regenerating...")

    # Build modifier based on action
    modifier = ""
    if action == "regen":
        modifier = "\n\n[Regenerate with completely fresh approaches. Different angles, different value adds.]"
    elif action == "bolder":
        modifier = "\n\n[Make the comments bolder and more confident. Take stronger positions. Be memorable.]"
    elif action == "professional":
        modifier = "\n\n[Make the comments more formal and professional. Emphasize expertise and credibility.]"

    try:
        api_key = crypto.decrypt(user.encrypted_api_key)
        if not api_key:
            await callback.answer("Key error")
            return

        model = user.openrouter_model if user.provider == "openrouter" else None
        llm = create_provider(user.provider, api_key, model)

        system_prompt = _load_prompt("standalone_comment.md")
        user_message = f"Generate comment suggestions for the LinkedIn post shown in this screenshot.{modifier}"

        result = await llm.complete(system_prompt, user_message, image_b64=screenshot_b64)
        await llm.close()

        if isinstance(result, dict):
            comment_text = result.get("raw_response", "") or str(result)
        else:
            comment_text = str(result)

        await state.update_data(last_comments=comment_text)

        await callback.message.edit_text(
            f"ðŸ’¬ *Comment Suggestions:*\n\n{comment_text}\n\n"
            "_Tap to regenerate with different styles, or Done when satisfied._",
            parse_mode="Markdown",
            reply_markup=_comment_actions_keyboard(),
        )

    except Exception as e:
        logger.error("Comment regeneration failed: %s", e)
        await callback.answer(f"Error: {str(e)[:100]}")
```

2. Update `bot/main.py`:
   - Import the new router: `from bot.handlers.comment import router as comment_router`
   - Register it with the dispatcher (after existing routers):
     `dp.include_router(comment_router)`
   - No DI needed beyond what's already injected (user_repo, crypto are existing)
  </action>
  <verify>
    - Handler file exists: `ls bot/handlers/comment.py`
    - Router exported: `grep "router = Router" bot/handlers/comment.py`
    - Main.py imports it: `grep "comment" bot/main.py`
    - Bot starts without errors: `python -c "from bot.handlers.comment import router; print('OK')"`
  </verify>
  <done>
    - /comment command starts standalone comment mode
    - User can send POST screenshot and receive 3 comment options
    - User can regenerate with different tones (Bolder, More Professional)
    - Flow is independent of leads system
    - Router registered in main.py
  </done>
</task>

</tasks>

<verification>
1. Bot starts without import errors
2. /comment command responds with instructions
3. Sending a screenshot generates 3 comment options
4. Regenerate button produces new comments
5. Bolder/Professional modifiers change comment style
6. Done button exits the flow cleanly
7. /cancel works at any point
</verification>

<success_criteria>
- CommentSupportState FSM states defined
- Standalone comment prompt created
- /comment handler module with full flow
- Regeneration with tone modifiers (regen, bolder, professional)
- Router registered in main.py
- No interference with existing /support or lead screenshot flows
</success_criteria>

<output>
After completion, create `.planning/phases/15.1-lead-enhancements/15.1-03-SUMMARY.md`
</output>
