---
phase: 16-tma-lead-experience-dashboard
plan: 03
type: execute
wave: 2
depends_on: ["16-01"]
files_modified:
  - packages/webapp/src/features/leads/hooks/useTodayActions.ts
  - packages/webapp/src/features/dashboard/components/TodayActionsCard.tsx
  - packages/webapp/src/pages/Dashboard.tsx
  - packages/webapp/src/features/leads/hooks/useUpdatePlanStep.ts
  - packages/webapp/src/lib/queries.ts
autonomous: true

must_haves:
  truths:
    - "Dashboard displays Today's Actions widget aggregating overdue and due-today steps"
    - "Tapping an action in the widget navigates to the lead detail with step highlighted"
    - "Completing a step from LeadDetail updates the Today's Actions widget"
  artifacts:
    - path: "packages/webapp/src/features/leads/hooks/useTodayActions.ts"
      provides: "Cross-lead action aggregation hook"
      exports: ["useTodayActions"]
    - path: "packages/webapp/src/features/dashboard/components/TodayActionsCard.tsx"
      provides: "Dashboard widget for today's actions"
      exports: ["TodayActionsCard"]
  key_links:
    - from: "TodayActionsCard.tsx"
      to: "useTodayActions"
      via: "hook call"
      pattern: "useTodayActions"
    - from: "useUpdatePlanStep.ts"
      to: "queryKeys.leads.todayActions"
      via: "invalidation on step complete"
      pattern: "todayActions"
---

<objective>
Create a Today's Actions dashboard widget that aggregates overdue and due-today engagement steps across all leads.

Purpose: Users see a single actionable list of what needs attention today without manually checking each lead (TMAUX-V20-04).
Output: useTodayActions hook, TodayActionsCard component integrated into Dashboard.
</objective>

<execution_context>
@/Users/dmytrolevin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dmytrolevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/16-tma-lead-experience-dashboard/16-RESEARCH.md

@packages/webapp/src/pages/Dashboard.tsx
@packages/webapp/src/features/dashboard/components/ProgressCard.tsx
@packages/webapp/src/features/dashboard/components/WeakAreasCard.tsx
@packages/webapp/src/features/leads/hooks/useUpdatePlanStep.ts
@packages/webapp/src/lib/queries.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add todayActions query key and create useTodayActions hook</name>
  <files>
    packages/webapp/src/lib/queries.ts
    packages/webapp/src/features/leads/hooks/useTodayActions.ts
  </files>
  <action>
1. Update queries.ts - add todayActions key:
   ```typescript
   leads: {
     all: ['leads'] as const,
     byUser: (telegramId: number) => ['leads', telegramId] as const,
     detail: (leadId: number) => ['leads', 'detail', leadId] as const,
     activities: (leadId: number) => ['leads', 'activities', leadId] as const,
     reminders: (telegramId: number) => ['leads', 'reminders', telegramId] as const,
     todayActions: (telegramId: number) => ['leads', 'todayActions', telegramId] as const,
   },
   ```

2. Create useTodayActions.ts:
   ```typescript
   import { useQuery } from '@tanstack/react-query';
   import { getInsforge } from '@/lib/insforge';
   import { useAuthStore } from '@/features/auth/store';
   import { queryKeys } from '@/lib/queries';

   interface TodayAction {
     id: number;
     lead_id: number;
     step_id: number;
     due_at: string;
     draft_text: string | null;
     leadName: string;
     stepDescription: string;
     isOverdue: boolean;
     isDueToday: boolean;
   }

   export function useTodayActions() {
     const telegramId = useAuthStore((s) => s.telegramId);

     return useQuery({
       queryKey: queryKeys.leads.todayActions(telegramId!),
       queryFn: async (): Promise<TodayAction[]> => {
         // Get pending/sent reminders
         const { data: reminders, error: remindersError } = await getInsforge()
           .database.from('scheduled_reminders')
           .select('id, lead_id, step_id, due_at, draft_text')
           .eq('telegram_id', telegramId!)
           .in('status', ['pending', 'sent'])
           .order('due_at', { ascending: true })
           .limit(50);

         if (remindersError) throw remindersError;
         if (!reminders || reminders.length === 0) return [];

         // Get lead names and engagement plans for step descriptions
         const leadIds = [...new Set(reminders.map((r) => r.lead_id))];
         const { data: leads, error: leadsError } = await getInsforge()
           .database.from('lead_registry')
           .select('id, prospect_name, prospect_first_name, prospect_last_name, engagement_plan')
           .in('id', leadIds);

         if (leadsError) throw leadsError;

         const now = new Date();
         const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
         const todayEnd = new Date(todayStart.getTime() + 24 * 60 * 60 * 1000);

         return reminders.map((r) => {
           const lead = leads?.find((l) => l.id === r.lead_id);
           const dueDate = new Date(r.due_at);
           const isOverdue = dueDate < now;
           const isDueToday = dueDate >= todayStart && dueDate < todayEnd;

           // Get step description from engagement_plan
           let stepDescription = `Step ${r.step_id}`;
           if (lead?.engagement_plan && Array.isArray(lead.engagement_plan)) {
             const step = lead.engagement_plan.find((s: { step_id?: number }) => s.step_id === r.step_id);
             if (step && typeof step.description === 'string') {
               stepDescription = step.description;
             }
           }

           // Build display name
           let leadName = 'Unknown';
           if (lead?.prospect_first_name && lead?.prospect_last_name) {
             leadName = `${lead.prospect_first_name} ${lead.prospect_last_name}`;
           } else if (lead?.prospect_name) {
             leadName = lead.prospect_name;
           }

           return {
             id: r.id,
             lead_id: r.lead_id,
             step_id: r.step_id,
             due_at: r.due_at,
             draft_text: r.draft_text,
             leadName,
             stepDescription,
             isOverdue,
             isDueToday,
           };
         }).filter((a) => a.isOverdue || a.isDueToday);
       },
       enabled: !!telegramId,
       refetchInterval: 60000, // Refresh every minute
     });
   }
   ```
  </action>
  <verify>
    TypeScript compilation passes: `cd packages/webapp && npx tsc --noEmit`
  </verify>
  <done>
    - queryKeys.leads.todayActions key exists
    - useTodayActions hook returns TodayAction[] with isOverdue and isDueToday flags
    - Hook filters to only overdue or due-today items
  </done>
</task>

<task type="auto">
  <name>Task 2: Create TodayActionsCard dashboard widget</name>
  <files>
    packages/webapp/src/features/dashboard/components/TodayActionsCard.tsx
  </files>
  <action>
Create TodayActionsCard component following existing dashboard widget patterns (ProgressCard, WeakAreasCard).

```typescript
import { ListTodo, ChevronRight, AlertCircle, Calendar } from 'lucide-react';
import { useNavigate } from 'react-router';
import { Card, Badge, Skeleton, ErrorCard } from '@/shared/ui';
import { useTodayActions } from '@/features/leads/hooks/useTodayActions';

export function TodayActionsCard() {
  const navigate = useNavigate();
  const { data: actions, isLoading, isError, refetch } = useTodayActions();

  if (isLoading) {
    return (
      <Card>
        <div className="flex items-center gap-2">
          <Skeleton height={20} width={20} />
          <Skeleton height={20} width="40%" />
        </div>
        <div className="mt-3 space-y-2">
          <Skeleton height={48} />
          <Skeleton height={48} />
        </div>
      </Card>
    );
  }

  if (isError) {
    return <ErrorCard message="Unable to load actions" onRetry={refetch} compact />;
  }

  if (!actions || actions.length === 0) {
    return (
      <Card>
        <div className="flex items-center gap-2 text-text-secondary">
          <ListTodo className="h-5 w-5" />
          <span className="text-sm font-medium">Today's Actions</span>
        </div>
        <p className="mt-2 text-sm text-text-hint">No actions due today. Great job!</p>
      </Card>
    );
  }

  const overdueCount = actions.filter((a) => a.isOverdue).length;
  const dueTodayCount = actions.filter((a) => a.isDueToday && !a.isOverdue).length;

  return (
    <Card>
      {/* Header */}
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-2">
          <ListTodo className="h-5 w-5 text-accent" />
          <span className="text-sm font-semibold text-text">Today's Actions</span>
        </div>
        <div className="flex gap-1">
          {overdueCount > 0 && (
            <Badge variant="error" size="sm">
              <AlertCircle className="mr-1 h-3 w-3" />
              {overdueCount} overdue
            </Badge>
          )}
          {dueTodayCount > 0 && (
            <Badge variant="info" size="sm">
              <Calendar className="mr-1 h-3 w-3" />
              {dueTodayCount} today
            </Badge>
          )}
        </div>
      </div>

      {/* Action list (show up to 5) */}
      <div className="mt-3 space-y-2">
        {actions.slice(0, 5).map((action) => (
          <button
            key={`${action.lead_id}-${action.step_id}`}
            type="button"
            onClick={() => navigate(`/leads/${action.lead_id}?step=${action.step_id}`)}
            className="flex w-full items-center gap-3 rounded-lg bg-surface-secondary/50 p-2 text-left transition-colors active:bg-surface-secondary"
          >
            <div className="min-w-0 flex-1">
              <div className="flex items-center gap-2">
                <p className="truncate text-sm font-medium text-text">
                  {action.leadName}
                </p>
                {action.isOverdue && (
                  <span className="shrink-0 text-xs text-error">overdue</span>
                )}
              </div>
              <p className="truncate text-xs text-text-secondary">
                {action.stepDescription}
              </p>
            </div>
            <ChevronRight className="h-4 w-4 shrink-0 text-text-hint" />
          </button>
        ))}
      </div>

      {/* View all link if more than 5 */}
      {actions.length > 5 && (
        <button
          type="button"
          onClick={() => navigate('/leads')}
          className="mt-2 w-full text-center text-xs text-accent"
        >
          View all {actions.length} actions
        </button>
      )}
    </Card>
  );
}
```
  </action>
  <verify>
    TypeScript compilation passes: `cd packages/webapp && npx tsc --noEmit`
  </verify>
  <done>
    - TodayActionsCard component renders loading, error, empty, and populated states
    - Shows overdue count and due-today count badges
    - Each action item navigates to lead detail with step query param
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate TodayActionsCard into Dashboard and wire cache invalidation</name>
  <files>
    packages/webapp/src/pages/Dashboard.tsx
    packages/webapp/src/features/leads/hooks/useUpdatePlanStep.ts
  </files>
  <action>
1. Update Dashboard.tsx:
   - Import TodayActionsCard: `import { TodayActionsCard } from '@/features/dashboard/components/TodayActionsCard';`
   - Add TodayActionsCard after ProgressCard, before QuickActions:
     ```tsx
     <div className="space-y-4 px-4 pt-4">
       <ProgressCard />
       <TodayActionsCard />  {/* NEW */}
       <QuickActions />
       <WeakAreasCard />
       <BadgePreview />
       <LeaderboardWidget />
     </div>
     ```

2. Update useUpdatePlanStep.ts onSettled to invalidate todayActions:
   - Add invalidation for todayActions query when step is updated:
     ```typescript
     onSettled: (_data, _err, { telegramId, leadId }) => {
       // Refetch to get true server state
       queryClient.invalidateQueries({
         queryKey: queryKeys.leads.detail(leadId),
       });
       queryClient.invalidateQueries({
         queryKey: queryKeys.leads.byUser(telegramId),
       });
       queryClient.invalidateQueries({
         queryKey: queryKeys.leads.activities(leadId),
       });
       // Invalidate today's actions so dashboard updates
       queryClient.invalidateQueries({
         queryKey: queryKeys.leads.todayActions(telegramId),
       });
       // Invalidate reminders cache (used by LeadCard progress)
       queryClient.invalidateQueries({
         queryKey: queryKeys.leads.reminders(telegramId),
       });
     },
     ```
  </action>
  <verify>
    - Run `cd packages/webapp && npm run build` to verify production build succeeds
    - Check Dashboard renders TodayActionsCard in dev mode
  </verify>
  <done>
    - Dashboard shows TodayActionsCard widget
    - Completing a step from LeadDetail invalidates todayActions cache
    - Today's Actions widget updates when navigating back to Dashboard
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. Production build succeeds
3. Dashboard shows Today's Actions widget with overdue/today counts
4. Tapping an action navigates to /leads/:id?step=:stepId
5. Completing a step and returning to Dashboard shows updated actions list
6. Empty state shows "No actions due today" message
</verification>

<success_criteria>
- Dashboard displays Today's Actions widget aggregating all overdue and due-today steps
- Each action shows lead name and step description
- Tapping an action navigates to the lead with step highlighted
- Completing a step updates both the LeadDetail and the Dashboard widget
- Widget shows empty state when no actions are due
</success_criteria>

<output>
After completion, create `.planning/phases/16-tma-lead-experience-dashboard/16-03-SUMMARY.md`
</output>
