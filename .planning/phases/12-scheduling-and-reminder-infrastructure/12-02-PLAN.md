---
phase: 12-scheduling-and-reminder-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - bot/services/plan_scheduler.py
  - bot/handlers/support.py
  - bot/handlers/leads.py
  - bot/main.py
autonomous: true

must_haves:
  truths:
    - "When a lead's engagement plan is generated in _background_enrich_lead, scheduled_reminders rows are created with concrete due_at timestamps"
    - "The timing parser computes due_at from delay_days (primary) or timing string (regex fallback) or 3-day default spacing"
    - "The polling scheduler runs every 15 minutes and sends basic Markdown notifications for due reminders"
    - "Duplicate reminders are prevented by last_reminded_at guard and optimistic update before sending"
    - "Deleting a lead also deletes its scheduled_reminders rows"
    - "Toggling a step in leads.py also updates the corresponding scheduled_reminders row"
  artifacts:
    - path: "bot/services/plan_scheduler.py"
      provides: "Timing parser, schedule_plan_reminders(), polling loop"
      contains: "parse_step_due_date"
    - path: "bot/services/plan_scheduler.py"
      provides: "Polling scheduler entry point"
      contains: "start_plan_scheduler"
    - path: "bot/handlers/support.py"
      provides: "Wiring into _background_enrich_lead"
      contains: "schedule_plan_reminders"
    - path: "bot/main.py"
      provides: "Plan scheduler background task startup"
      contains: "start_plan_scheduler"
  key_links:
    - from: "bot/handlers/support.py"
      to: "bot/services/plan_scheduler.py"
      via: "import and call schedule_plan_reminders after plan generation"
      pattern: "schedule_plan_reminders"
    - from: "bot/main.py"
      to: "bot/services/plan_scheduler.py"
      via: "import start_plan_scheduler and create_background_task"
      pattern: "start_plan_scheduler"
    - from: "bot/services/plan_scheduler.py"
      to: "bot/storage/repositories.py"
      via: "ScheduledReminderRepo for all DB operations"
      pattern: "reminder_repo"
    - from: "bot/handlers/leads.py"
      to: "bot/storage/repositories.py"
      via: "ScheduledReminderRepo for step toggle and delete cascade"
      pattern: "reminder_repo"
---

<objective>
Create the plan scheduler service (timing parser + scheduling function + polling loop), wire plan-to-reminders into the support pipeline, add cleanup hooks in leads handler, and start the scheduler in main.py.

Purpose: This completes Phase 12 by connecting the data foundation (Plan 01) to the application logic. After this plan, new engagement plans automatically create scheduled reminders, the polling loop dispatches basic notifications, and lead lifecycle events (step toggle, delete) keep reminders in sync.
Output: New bot/services/plan_scheduler.py, modified support.py, leads.py, main.py
</objective>

<execution_context>
@/Users/dmytrolevin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dmytrolevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-scheduling-and-reminder-infrastructure/12-RESEARCH.md
@.planning/phases/12-scheduling-and-reminder-infrastructure/12-01-SUMMARY.md

@bot/services/followup_scheduler.py
@bot/services/plan_scheduler.py
@bot/handlers/support.py
@bot/handlers/leads.py
@bot/main.py
@bot/storage/repositories.py
@bot/storage/models.py
@bot/task_utils.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create plan_scheduler.py with timing parser, scheduling function, and polling loop</name>
  <files>bot/services/plan_scheduler.py</files>
  <action>
Create `bot/services/plan_scheduler.py` as a new file. Follow the structure and patterns from `bot/services/followup_scheduler.py` exactly.

**Imports:**
```python
from __future__ import annotations
import asyncio
import logging
import re
from datetime import datetime, timedelta, timezone
from aiogram import Bot
from bot.storage.models import ScheduledReminderModel
from bot.storage.repositories import LeadActivityRepo, LeadRegistryRepo, ScheduledReminderRepo
```

**Constants:**
```python
PLAN_CHECK_INTERVAL = 15 * 60  # 15 minutes
DEFAULT_SPACING_DAYS = 3
```

**1. Timing parser patterns and function:**

Define `TIMING_PATTERNS` as a list of (regex_pattern, timedelta_or_callable) tuples:
- `r"(?:immediately|right away|now|day\s*0)"` -> `timedelta(hours=0)`
- `r"day\s*1\b"` -> `timedelta(days=1)`
- `r"day\s*(\d+)(?:\s*-\s*\d+)?"` -> lambda using group(1) as days
- `r"(?:after\s+)?(\d+)\s*(?:day|d)s?\s*(?:later)?"` -> lambda using group(1) as days
- `r"(?:after\s+)?(\d+)\s*(?:week|w)s?\s*(?:later)?"` -> lambda using group(1) as weeks
- `r"(?:after\s+)?(\d+)\s*(?:month|mo)s?\s*(?:later)?"` -> lambda using group(1) * 30 as days

Implement `parse_step_due_date(step: dict, base_date: datetime, step_index: int) -> datetime`:
- Primary: check `step.get("delay_days")`. If present and parseable as int, return `base_date + timedelta(days=int(delay_days))`.
- Fallback: check `step.get("timing", "")`. If non-empty, try each regex pattern. On match, compute and return `base_date + resolved_delta`.
- Last resort: return `base_date + timedelta(days=(step_index + 1) * DEFAULT_SPACING_DAYS)`.

**2. Schedule plan reminders function:**

Implement `async def schedule_plan_reminders(reminder_repo, lead_id, telegram_id, plan_steps, base_date) -> None`:
- Call `await reminder_repo.cancel_pending_for_lead(lead_id)` first (idempotency).
- Loop through `plan_steps` with `enumerate`. For each step:
  - Extract `step_id = step.get("step_id", i + 1)`
  - Compute `due_at = parse_step_due_date(step, base_date, i)`
  - Create reminder: `await reminder_repo.create(ScheduledReminderModel(lead_id=lead_id, telegram_id=telegram_id, step_id=step_id, due_at=due_at.isoformat(), status="pending", draft_text=step.get("suggested_text")))`.
- Log how many reminders were created.

**3. Process due reminders function:**

Implement `async def _process_due_plan_reminders(bot, reminder_repo, lead_repo, activity_repo) -> None`:
- Get current time: `now = datetime.now(timezone.utc)`, `now_iso = now.isoformat()`
- Query: `due_reminders = await reminder_repo.get_due_reminders(now_iso)`
- For each reminder in due_reminders:
  - **Duplicate guard:** If `reminder.last_reminded_at` is set, parse it and check if `(now - last).total_seconds() < PLAN_CHECK_INTERVAL`. If so, `continue`.
  - **Optimistic update BEFORE sending** (at-most-once): `await reminder_repo.mark_reminded(reminder.id, now_iso)`
  - **Fetch lead for context:** `lead = await lead_repo.get_by_id(reminder.lead_id)`. If no lead, update status to "skipped" and continue.
  - **Build notification text** (simple Markdown, Phase 14 will upgrade):
    ```
    name = lead.prospect_name or f"Lead #{lead.id}"
    step_desc = reminder.draft_text or f"Step {reminder.step_id} of your engagement plan"
    text = (
        f"ðŸ”” *Engagement Step Due: {name}*\n\n"
        f"ðŸ“‹ *Step {reminder.step_id}:* {step_desc[:200]}\n\n"
        f"Use /leads to view details and take action."
    )
    ```
  - **Send message:** `await bot.send_message(chat_id=reminder.telegram_id, text=text, parse_mode="Markdown")`
  - **Update status:** If `reminder.status == "pending"`, call `await reminder_repo.update_status(reminder.id, "sent")`.
  - **Rate limiting:** Add `await asyncio.sleep(0.5)` between sends to avoid Telegram rate limits.
  - Wrap each reminder processing in try/except, log errors but continue with next reminder.

**4. Start plan scheduler function:**

Implement `async def start_plan_scheduler(bot, reminder_repo, lead_repo, activity_repo) -> None`:
- Follow the exact `start_followup_scheduler` pattern.
- Log startup message with interval.
- `while True:` try process, except log error, then `await asyncio.sleep(PLAN_CHECK_INTERVAL)`.
  </action>
  <verify>
Run `python -c "from bot.services.plan_scheduler import parse_step_due_date, schedule_plan_reminders, start_plan_scheduler; print('OK')"` to confirm all exports work. Verify timing parser handles: `{"delay_days": 3}` -> 3 days, `{"timing": "Day 5"}` -> 5 days, `{}` with step_index=2 -> 9 days (3 * (2+1)).
  </verify>
  <done>
plan_scheduler.py exists with: timing parser (6 regex patterns + delay_days primary + 3-day default), schedule_plan_reminders (idempotent, creates per-step rows), polling loop (15min interval, duplicate guard, optimistic update, basic Markdown notification, 0.5s rate limiting).
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire scheduling into support.py, leads.py, and main.py</name>
  <files>
    bot/handlers/support.py
    bot/handlers/leads.py
    bot/main.py
  </files>
  <action>
**1. Wire into `bot/handlers/support.py` -- `_background_enrich_lead()`:**

Add import at top:
```python
from bot.services.plan_scheduler import schedule_plan_reminders
from bot.storage.repositories import ScheduledReminderRepo
```
(Add `ScheduledReminderRepo` to the existing import from `bot.storage.repositories`)

Add `reminder_repo: ScheduledReminderRepo | None = None` parameter to `_background_enrich_lead()` function signature (after `original_context`).

In `_background_enrich_lead()`, after the existing block that generates and saves the engagement plan (lines 464-470, the `if plan:` block), add the scheduling call:

```python
if plan:
    await lead_repo.update_lead(lead_id, engagement_plan=plan, next_followup=next_followup)
    # Schedule per-step reminders
    if reminder_repo:
        try:
            await schedule_plan_reminders(
                reminder_repo=reminder_repo,
                lead_id=lead_id,
                telegram_id=lead.telegram_id,
                plan_steps=plan,
                base_date=datetime.now(timezone.utc),
            )
        except Exception as e:
            logger.error("Failed to schedule plan reminders for lead %s: %s", lead_id, e)
```

Keep the existing `next_followup` logic for backward compatibility with the old followup scheduler.

Update the `create_background_task` call to `_background_enrich_lead` (around line 322) to pass `reminder_repo`:
```python
_background_enrich_lead(
    lead_id=saved_lead_id,
    lead_repo=lead_repo,
    engagement_service=engagement_service,
    openrouter_api_key=shared_openrouter_key,
    prospect_name=prospect_name,
    prospect_company=prospect_company,
    prospect_geography=prospect_geography,
    original_context=user_input[:300],
    reminder_repo=reminder_repo,  # NEW
),
```

For `reminder_repo` to be available, add it to the function parameters of `_run_support_pipeline()`:
```python
reminder_repo: ScheduledReminderRepo | None = None,
```

And pass it through from the handlers. The `reminder_repo` will come from `workflow_data` via DI (set up in main.py). Add `reminder_repo: ScheduledReminderRepo | None = None` parameter to each of the three support input handlers (`on_support_photo`, `on_support_voice`, `on_support_input`) and pass it to `_run_support_pipeline()`.

**2. Wire into `bot/handlers/leads.py`:**

Add import at top (add to existing repositories import):
```python
from bot.storage.repositories import ScheduledReminderRepo
```

**Step toggle (`on_lead_step_toggle`, line 496):**
Add `reminder_repo: ScheduledReminderRepo | None = None` parameter. After the existing step toggle logic (after `await lead_repo.update_lead(lead_id, engagement_plan=updated_plan)`, around line 521), add:

```python
# Sync scheduled_reminders row
if reminder_repo:
    try:
        sr = await reminder_repo.get_by_lead_and_step(lead_id, step_id)
        if sr and sr.id:
            new_sr_status = "completed" if toggled_status == "done" else "pending"
            await reminder_repo.update_status(sr.id, new_sr_status)
    except Exception as e:
        logger.error("Failed to sync reminder for lead %s step %s: %s", lead_id, step_id, e)
```

**Lead delete (`on_lead_delete_execute`, line 902):**
Add `reminder_repo: ScheduledReminderRepo | None = None` parameter. Before the `await lead_repo.delete_lead(lead_id)` call (line 917), add:

```python
# Delete associated reminders (no FK cascade, so explicit)
if reminder_repo:
    try:
        await reminder_repo.delete_for_lead(lead_id)
    except Exception as e:
        logger.error("Failed to delete reminders for lead %s: %s", lead_id, e)
```

**3. Wire into `bot/main.py`:**

Add imports:
```python
from bot.services.plan_scheduler import start_plan_scheduler
from bot.storage.repositories import ScheduledReminderRepo
```
(Add `ScheduledReminderRepo` to the existing import from `bot.storage.repositories`)

After the existing repository initialization block (after `trace_repo = TraceRepo(insforge)`, line 80), add:
```python
reminder_repo = ScheduledReminderRepo(insforge)
```

Add `reminder_repo` to `dp.workflow_data.update()` dict (line 138-164):
```python
"reminder_repo": reminder_repo,
```

After the existing followup scheduler startup (lines 179-185), add the plan scheduler startup:
```python
# Start plan step reminder scheduler in background
create_background_task(
    start_plan_scheduler(bot, reminder_repo, lead_repo, activity_repo),
    name="plan_scheduler",
)
logger.info("Plan scheduler started (15-minute interval)")
```

Place this inside the `if engagement_service:` block (or outside if you want it always running -- but inside makes sense since reminders only exist for leads with engagement plans, which require the engagement service).
  </action>
  <verify>
Run `python -c "from bot.handlers.support import _background_enrich_lead; from bot.handlers.leads import on_lead_step_toggle, on_lead_delete_execute; from bot.main import main; print('OK')"` to confirm all imports work. Verify `reminder_repo` appears in workflow_data. Verify `start_plan_scheduler` is called in main.py.
  </verify>
  <done>
- support.py: `_background_enrich_lead()` calls `schedule_plan_reminders()` after plan generation, `reminder_repo` passed through DI chain
- leads.py: step toggle syncs corresponding `scheduled_reminders` row, lead delete cascades to delete reminders
- main.py: `ScheduledReminderRepo` instantiated, added to `workflow_data`, `start_plan_scheduler` started as background task
- Both schedulers (followup + plan) run concurrently
  </done>
</task>

</tasks>

<verification>
1. `python -c "from bot.services.plan_scheduler import parse_step_due_date, schedule_plan_reminders, start_plan_scheduler; print('OK')"` succeeds
2. `python -c "from bot.main import main; print('OK')"` succeeds (all imports resolve)
3. Grep for `schedule_plan_reminders` in `support.py` confirms wiring
4. Grep for `delete_for_lead` in `leads.py` confirms cascade cleanup
5. Grep for `start_plan_scheduler` in `main.py` confirms scheduler startup
6. Grep for `reminder_repo` in `main.py` workflow_data confirms DI injection
</verification>

<success_criteria>
- New engagement plans automatically create scheduled_reminders rows with concrete due_at timestamps
- Timing parser correctly handles: delay_days integer (primary), timing string regex (fallback), 3-day default (last resort)
- Polling scheduler runs every 15 minutes, finds due reminders, sends basic Markdown notification
- Optimistic update before send prevents duplicate reminders on bot restart
- Lead deletion cascades to delete associated reminders
- Step toggle syncs scheduled_reminders status with engagement_plan JSONB
- Both followup_scheduler and plan_scheduler run concurrently without interference
</success_criteria>

<output>
After completion, create `.planning/phases/12-scheduling-and-reminder-infrastructure/12-02-SUMMARY.md`
</output>
