---
phase: 12-scheduling-and-reminder-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - insforge/migrations/002_scheduled_reminders.sql
  - bot/storage/models.py
  - bot/storage/repositories.py
  - prompts/engagement_plan.md
autonomous: true

must_haves:
  truths:
    - "ScheduledReminderModel exists with all required fields (lead_id, telegram_id, step_id, due_at, status, snooze_count, reminder_count, last_reminded_at, draft_text, completed_at)"
    - "ScheduledReminderRepo provides get_due_reminders, create, cancel_pending_for_lead, mark_reminded, update_status, delete_for_lead methods"
    - "Migration SQL creates scheduled_reminders table with polling index, lead index, telegram index, RLS policies, and grants"
    - "Engagement plan prompt includes delay_days integer field in output format with monotonically increasing rule"
  artifacts:
    - path: "insforge/migrations/002_scheduled_reminders.sql"
      provides: "Table creation with indexes, RLS, grants"
      contains: "CREATE TABLE IF NOT EXISTS scheduled_reminders"
    - path: "bot/storage/models.py"
      provides: "ScheduledReminderModel Pydantic model"
      contains: "class ScheduledReminderModel"
    - path: "bot/storage/repositories.py"
      provides: "ScheduledReminderRepo class"
      contains: "class ScheduledReminderRepo"
    - path: "prompts/engagement_plan.md"
      provides: "Updated prompt with delay_days field"
      contains: "delay_days"
  key_links:
    - from: "bot/storage/repositories.py"
      to: "bot/storage/models.py"
      via: "import ScheduledReminderModel"
      pattern: "from bot\\.storage\\.models import.*ScheduledReminderModel"
    - from: "bot/storage/repositories.py"
      to: "bot/storage/insforge_client.py"
      via: "InsForgeClient for PostgREST queries"
      pattern: "self\\.client\\.query"
---

<objective>
Create the scheduled_reminders database table, Pydantic model, repository class, and update the engagement plan prompt to include delay_days integers.

Purpose: This is the data foundation for Phase 12. The table stores per-step reminder rows, the model/repo provide data access, and the prompt update ensures new engagement plans produce the delay_days field needed for scheduling.
Output: Migration SQL, ScheduledReminderModel, ScheduledReminderRepo, updated engagement_plan.md prompt
</objective>

<execution_context>
@/Users/dmytrolevin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dmytrolevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-scheduling-and-reminder-infrastructure/12-RESEARCH.md

@bot/storage/models.py
@bot/storage/repositories.py
@bot/storage/insforge_client.py
@insforge/migrations/001_pipeline_traces.sql
@prompts/engagement_plan.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migration SQL, Pydantic model, and repository class</name>
  <files>
    insforge/migrations/002_scheduled_reminders.sql
    bot/storage/models.py
    bot/storage/repositories.py
  </files>
  <action>
1. Create `insforge/migrations/002_scheduled_reminders.sql` following the exact pattern from `001_pipeline_traces.sql`:

```sql
CREATE TABLE IF NOT EXISTS scheduled_reminders (
    id              SERIAL PRIMARY KEY,
    lead_id         INTEGER NOT NULL,
    telegram_id     BIGINT NOT NULL,
    step_id         INTEGER NOT NULL,
    due_at          TIMESTAMP WITH TIME ZONE NOT NULL,
    status          TEXT NOT NULL DEFAULT 'pending',
    snooze_count    INTEGER NOT NULL DEFAULT 0,
    reminder_count  INTEGER NOT NULL DEFAULT 0,
    last_reminded_at TIMESTAMP WITH TIME ZONE,
    draft_text      TEXT,
    completed_at    TIMESTAMP WITH TIME ZONE,
    created_at      TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at      TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

Add three indexes:
- Polling index (partial, the hot path): `idx_scheduled_reminders_due` on `(due_at)` WHERE `status IN ('pending', 'sent')`
- Lead lookup: `idx_scheduled_reminders_lead` on `(lead_id, step_id)`
- Telegram user lookup: `idx_scheduled_reminders_telegram` on `(telegram_id, status)`

Add RLS + policies + grants following the 001 pattern exactly:
- Enable RLS
- Service-role `FOR ALL USING (true) WITH CHECK (true)` policy
- Grant sequence usage to anon
- Grant ALL on table to anon
- Add authenticated policies for TMA read/update scoped to `telegram_id` from JWT claims (same pattern as the research suggests)

Do NOT add FOREIGN KEY constraints (the codebase handles referential integrity in application code).

2. Add `ScheduledReminderModel` to `bot/storage/models.py` after the `LeadActivityModel` class. Follow the exact Pydantic pattern used by all other models:

```python
class ScheduledReminderModel(BaseModel):
    id: int | None = None
    lead_id: int
    telegram_id: int
    step_id: int
    due_at: str
    status: str = "pending"
    snooze_count: int = 0
    reminder_count: int = 0
    last_reminded_at: str | None = None
    draft_text: str | None = None
    completed_at: str | None = None
    created_at: str | None = None
    updated_at: str | None = None
```

3. Add `ScheduledReminderRepo` to `bot/storage/repositories.py` after `LeadActivityRepo`. Follow the exact repository pattern. Add import of `ScheduledReminderModel` to the import block at the top.

Methods needed:

- `__init__(self, client: InsForgeClient)` -- set `self.client` and `self.table = "scheduled_reminders"`

- `async def create(self, reminder: ScheduledReminderModel) -> ScheduledReminderModel` -- exclude `id`, `created_at`, `updated_at` from dump, call `self.client.create()`

- `async def get_due_reminders(self, now_iso: str) -> list[ScheduledReminderModel]` -- query with filters `{"due_at": f"lte.{now_iso}", "status": "in.(pending,sent)"}`, order by `due_at.asc`, limit 50. Follow the same defensive pattern as `LeadRegistryRepo.get_due_followups()`: try PostgREST filter first, fall back to Python filtering if it fails. Parse models from rows.

- `async def cancel_pending_for_lead(self, lead_id: int) -> None` -- query all reminders for this lead_id with status `in.(pending,sent)`, then for each, update status to "cancelled" with `updated_at`. This ensures idempotent re-scheduling.

- `async def mark_reminded(self, reminder_id: int, now_iso: str) -> None` -- update the reminder by id: set `last_reminded_at` to now_iso, increment `reminder_count` by fetching current value first, set `updated_at`.

- `async def update_status(self, reminder_id: int, status: str) -> None` -- update status and updated_at. If status is "completed", also set `completed_at`.

- `async def delete_for_lead(self, lead_id: int) -> None` -- delete all reminders for a lead (for cascade when lead is deleted). Use `self.client.delete(self.table, {"lead_id": lead_id})`.

- `async def get_for_lead(self, lead_id: int) -> list[ScheduledReminderModel]` -- query by lead_id, order by step_id.asc. Used by step toggle to find matching reminder.

- `async def get_by_lead_and_step(self, lead_id: int, step_id: int) -> ScheduledReminderModel | None` -- query by lead_id + step_id, limit 1, return model or None.
  </action>
  <verify>
Run `python -c "from bot.storage.models import ScheduledReminderModel; from bot.storage.repositories import ScheduledReminderRepo; print('OK')"` to confirm imports work. Visually verify migration SQL has correct table structure, indexes, RLS, and grants.
  </verify>
  <done>
ScheduledReminderModel exists in models.py with all 13 fields. ScheduledReminderRepo exists in repositories.py with 8 methods (create, get_due_reminders, cancel_pending_for_lead, mark_reminded, update_status, delete_for_lead, get_for_lead, get_by_lead_and_step). Migration SQL is ready to execute on InsForge.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update engagement plan prompt with delay_days field</name>
  <files>prompts/engagement_plan.md</files>
  <action>
Update `prompts/engagement_plan.md` to include the `delay_days` integer field in the output format.

1. In the `### Output Format` JSON example, add `"delay_days": N` to each step object, between `"timing"` and `"status"`. Example:
   - Step 1: `"timing": "Day 1", "delay_days": 1`
   - Step 2: `"timing": "Day 2", "delay_days": 2`

2. Add rules 8, 9, 10 to the `## Rules` section:

```
8. **Always include `delay_days`** -- an integer representing the number of days after the plan starts when this step should be executed. Day 0 = immediately, Day 1 = tomorrow, etc.
9. **`delay_days` must be monotonically increasing** -- each step's `delay_days` should be >= the previous step's `delay_days`
10. **Typical pacing:** Steps should be spaced across 1-3 weeks. Common pattern: 0, 1, 3, 5, 7, 10, 14
```

Keep the existing rules 1-7 exactly as they are. Do not modify any other part of the prompt.
  </action>
  <verify>
Read the updated file and confirm: (1) JSON example has `delay_days` in both step objects, (2) rules 8-10 are present and correctly worded, (3) existing rules 1-7 are unchanged.
  </verify>
  <done>
Engagement plan prompt includes `delay_days` integer field in output format example and rules 8-10 enforce monotonic increasing values with typical pacing guidance.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from bot.storage.models import ScheduledReminderModel; from bot.storage.repositories import ScheduledReminderRepo; print('imports OK')"` succeeds
2. Migration file exists at `insforge/migrations/002_scheduled_reminders.sql` with CREATE TABLE, 3 indexes, RLS, grants
3. `prompts/engagement_plan.md` contains `delay_days` in both output format and rules section
</verification>

<success_criteria>
- ScheduledReminderModel has 13 fields matching the table schema
- ScheduledReminderRepo has 8 data access methods covering CRUD + specialized queries
- Migration SQL follows the exact pattern from 001_pipeline_traces.sql (RLS, grants, indexes)
- Engagement plan prompt includes delay_days with monotonic increasing rule
- No existing code is broken (all existing imports still work)
</success_criteria>

<output>
After completion, create `.planning/phases/12-scheduling-and-reminder-infrastructure/12-01-SUMMARY.md`
</output>
