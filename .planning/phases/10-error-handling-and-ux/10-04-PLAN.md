---
phase: 10-error-handling-and-ux
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - bot/utils_validation.py
  - bot/handlers/support.py
  - bot/handlers/learn.py
  - bot/handlers/train.py
autonomous: true

must_haves:
  truths:
    - "All 3 bot handlers (support, learn, train) use validate_user_input() for input validation"
    - "Empty input in any handler returns a context-specific error message"
    - "Command input (text starting with /) in any handler triggers command detection with fuzzy matching"
    - "Support handler enforces min_length=10 while learn/train handlers accept any non-empty input"
    - "All handlers enforce max_length=4000 with silent truncation"
  artifacts:
    - path: "bot/utils_validation.py"
      provides: "Shared validation utility with validate_user_input() and ValidationResult"
      exports: ["validate_user_input", "ValidationResult"]
      min_lines: 40
    - path: "bot/handlers/support.py"
      provides: "Uses validate_user_input(context='support', min_length=10)"
      contains: "validate_user_input"
    - path: "bot/handlers/learn.py"
      provides: "Uses validate_user_input(context='learn')"
      contains: "validate_user_input"
    - path: "bot/handlers/train.py"
      provides: "Uses validate_user_input(context='train')"
      contains: "validate_user_input"
  key_links:
    - from: "bot/handlers/support.py"
      to: "bot/utils_validation.py"
      via: "import validate_user_input"
      pattern: "from bot.utils_validation import"
    - from: "bot/handlers/learn.py"
      to: "bot/utils_validation.py"
      via: "import validate_user_input"
      pattern: "from bot.utils_validation import"
    - from: "bot/handlers/train.py"
      to: "bot/utils_validation.py"
      via: "import validate_user_input"
      pattern: "from bot.utils_validation import"
---

<objective>
Create a shared bot validation utility and integrate it into all 3 text input handlers (support, learn, train) for consistent input validation with context-specific error messages.

Purpose: UX-V11-04 requires shared validation across bot handlers. Currently validation is duplicated and inconsistent -- support has min_length and command detection, learn/train only check empty. This plan consolidates into one utility.
Output: New bot/utils_validation.py file, updated support.py, learn.py, and train.py handlers.
</objective>

<execution_context>
@/Users/dmytrolevin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dmytrolevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-error-handling-and-ux/10-RESEARCH.md

Key files to reference and modify:
@bot/handlers/support.py
@bot/handlers/learn.py
@bot/handlers/train.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create bot/utils_validation.py with validate_user_input()</name>
  <files>
    bot/utils_validation.py
  </files>
  <action>
    Create `bot/utils_validation.py` with the shared validation utility.

    **ValidationResult dataclass:**
    ```python
    from dataclasses import dataclass

    @dataclass
    class ValidationResult:
        is_valid: bool
        error_message: str | None = None
        cleaned_input: str | None = None
        is_command: bool = False
        suggested_command: str | None = None
    ```

    **KNOWN_COMMANDS set:**
    ```python
    KNOWN_COMMANDS = {
        "/start", "/support", "/learn", "/train", "/stats",
        "/settings", "/leads", "/admin", "/help", "/cancel",
    }
    ```

    **_edit_distance(s1, s2) function:**
    Move the existing `_edit_distance()` function from `bot/handlers/support.py` into this file. It's a standard Levenshtein distance implementation used for fuzzy command matching. Copy it exactly as-is.

    **_check_mistyped_command(text) function:**
    Move the existing `_check_mistyped_command()` function from `bot/handlers/support.py` into this file. It uses `_edit_distance()` to find the closest known command. Copy it exactly, adjusting to use the module-level `KNOWN_COMMANDS` set.

    **validate_user_input() function:**
    ```python
    def validate_user_input(
        text: str,
        *,
        min_length: int = 1,
        max_length: int = 4000,
        context: str = "general",
    ) -> ValidationResult:
        """Validate user text input with context-specific messages.

        Args:
            text: Raw user input text.
            min_length: Minimum character count after stripping. Default 1 (non-empty).
                       Support uses 10 for richer context requirement.
            max_length: Maximum character count. Input truncated silently. Default 4000.
            context: One of "support", "learn", "train", "general".
                    Controls error message wording.

        Returns:
            ValidationResult with is_valid, error_message, and cleaned_input.
        """
        stripped = text.strip()

        # 1. Empty check
        if not stripped:
            messages = {
                "support": "Please describe your prospect or send a screenshot.",
                "learn": "Please type your response to the scenario.",
                "train": "Please type your response to the scenario.",
            }
            return ValidationResult(
                is_valid=False,
                error_message=messages.get(context, "Please provide some input."),
            )

        # 2. Command detection (applies to all contexts)
        if stripped.startswith("/"):
            # Check for /cancel specifically
            if stripped.lower() == "/cancel":
                return ValidationResult(
                    is_valid=False,
                    is_command=True,
                    error_message=None,  # Caller handles cancel flow
                    suggested_command="/cancel",
                )
            # Fuzzy match against known commands
            suggested = _check_mistyped_command(stripped)
            return ValidationResult(
                is_valid=False,
                is_command=True,
                suggested_command=suggested,
                error_message=None,  # Caller formats the redirect message
            )

        # 3. Min length check (context-specific messages)
        if len(stripped) < min_length:
            messages = {
                "support": (
                    "That's quite short. Please provide more context about your prospect:\n"
                    "- Their role, company, and situation\n"
                    "- Or send a LinkedIn screenshot\n"
                    "- Or a voice message"
                ),
                "learn": "Please provide a more detailed response to the scenario.",
                "train": "Please provide a more detailed response to the scenario.",
            }
            return ValidationResult(
                is_valid=False,
                error_message=messages.get(context, "Input is too short."),
            )

        # 4. Max length truncation (silent)
        cleaned = stripped[:max_length]

        return ValidationResult(is_valid=True, cleaned_input=cleaned)
    ```

    **Module docstring:**
    ```python
    """Shared input validation for bot text handlers.

    Provides consistent validation across /support, /learn, and /train handlers
    with context-specific error messages and command detection with fuzzy matching.
    """
    ```
  </action>
  <verify>Run `cd /Users/dmytrolevin/Downloads/GD_playground && python3 -c "from bot.utils_validation import validate_user_input, ValidationResult; r = validate_user_input('', context='support'); assert not r.is_valid; assert r.error_message; r2 = validate_user_input('hello world this is valid', context='support', min_length=10); assert r2.is_valid; print('All checks passed')"` -- must print "All checks passed".</verify>
  <done>bot/utils_validation.py exists with validate_user_input(), ValidationResult, _edit_distance(), _check_mistyped_command(), and KNOWN_COMMANDS. Import works and basic validation logic is correct.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate validate_user_input() into support.py, learn.py, and train.py</name>
  <files>
    bot/handlers/support.py
    bot/handlers/learn.py
    bot/handlers/train.py
  </files>
  <action>
    **support.py** -- `on_support_input()` handler:
    1. Add import: `from bot.utils_validation import validate_user_input`
    2. Find the `on_support_input()` function (it handles text messages in the support FSM state).
    3. At the point where the handler gets `user_input` text, replace the existing inline validation logic with:
       ```python
       result = validate_user_input(user_input, context="support", min_length=10)
       if not result.is_valid:
           if result.is_command:
               if result.suggested_command == "/cancel":
                   await state.clear()
                   await message.answer("Support session cancelled.")
                   return
               # Redirect to suggested command (existing fuzzy match behavior)
               if result.suggested_command:
                   await state.clear()
                   await message.answer(
                       f"Looks like you meant {result.suggested_command}. "
                       f"I've cancelled the support session. Try the command again."
                   )
               else:
                   await state.clear()
                   await message.answer(
                       "That looks like a command. I've cancelled the support session. "
                       "Try your command again."
                   )
               return
           await message.answer(result.error_message)
           return
       user_input = result.cleaned_input
       ```
    4. Remove the old inline validation code (empty check, command detection, length check).
    5. Remove `_edit_distance()` and `_check_mistyped_command()` functions from support.py (they now live in utils_validation.py). BUT first verify no other code in support.py calls these functions. If they are only used in `on_support_input()` validation, remove them.
    6. Keep all existing behavior: the user_input truncation was at `user_input[:2000]` in storage -- now the shared utility truncates to 4000 chars (and storage still truncates to 2000 if it does). This is fine -- the shared utility is a first pass, storage is the hard limit.

    **learn.py** -- `on_learn_answer()` handler:
    1. Add import: `from bot.utils_validation import validate_user_input`
    2. Find `on_learn_answer()` (handles text messages in the learn answer FSM state).
    3. Replace the existing inline validation (cancel check + empty check) with:
       ```python
       result = validate_user_input(user_response, context="learn")
       if not result.is_valid:
           if result.is_command:
               if result.suggested_command == "/cancel":
                   await state.clear()
                   await message.answer("Learning session cancelled. Use /learn to start again.")
                   return
               # Any command: clear state and let user retry
               await state.clear()
               if result.suggested_command:
                   await message.answer(
                       f"Looks like you meant {result.suggested_command}. "
                       f"Learning session cancelled. Try the command again."
                   )
               else:
                   await message.answer(
                       "That looks like a command. Learning session cancelled. "
                       "Try your command again."
                   )
               return
           await message.answer(result.error_message)
           return
       user_response = result.cleaned_input
       ```
    4. Remove the old inline `/cancel` check and empty check.
    5. Note: learn.py previously had no min_length check (just empty). The default `min_length=1` preserves this behavior -- any non-empty input is valid.

    **train.py** -- `on_train_answer()` handler:
    1. Add import: `from bot.utils_validation import validate_user_input`
    2. Find `on_train_answer()` (handles text messages in the train answer FSM state).
    3. Apply the same pattern as learn.py:
       ```python
       result = validate_user_input(user_response, context="train")
       if not result.is_valid:
           if result.is_command:
               if result.suggested_command == "/cancel":
                   await state.clear()
                   await message.answer("Training session cancelled. Use /train to start again.")
                   return
               await state.clear()
               if result.suggested_command:
                   await message.answer(
                       f"Looks like you meant {result.suggested_command}. "
                       f"Training session cancelled. Try the command again."
                   )
               else:
                   await message.answer(
                       "That looks like a command. Training session cancelled. "
                       "Try your command again."
                   )
               return
           await message.answer(result.error_message)
           return
       user_response = result.cleaned_input
       ```
    4. Remove the old inline `/cancel` check and empty check.

    **Key behavioral changes from consolidation:**
    - learn.py and train.py now have command detection (previously only support.py had it)
    - learn.py and train.py now have fuzzy command matching (previously only checked literal `/cancel`)
    - All handlers now truncate at 4000 chars (previously no max length check, just silent storage truncation)
    - Error messages remain context-specific (same wording as before for each handler)
    - Cancel behavior preserved: clears FSM state and informs user
  </action>
  <verify>Run `cd /Users/dmytrolevin/Downloads/GD_playground && python3 -c "from bot.handlers.support import router; from bot.handlers.learn import router as lr; from bot.handlers.train import router as tr; print('All imports OK')"` -- must succeed without ImportError. Then verify that `_edit_distance` and `_check_mistyped_command` are no longer in support.py by searching the file.</verify>
  <done>All 3 handlers import and use validate_user_input(). Old inline validation removed. _edit_distance and _check_mistyped_command moved to utils_validation.py. All handlers have consistent command detection, context-specific error messages, and max length enforcement.</done>
</task>

</tasks>

<verification>
1. `python3 -c "from bot.utils_validation import validate_user_input, ValidationResult"` -- import succeeds
2. `python3 -c "from bot.handlers.support import router"` -- import succeeds (no circular imports)
3. `python3 -c "from bot.handlers.learn import router"` -- import succeeds
4. `python3 -c "from bot.handlers.train import router"` -- import succeeds
5. Grep for `validate_user_input` in all 3 handler files -- each must use it
6. Grep for `_edit_distance` in support.py -- should NOT be found (moved to utils_validation.py)
7. Grep for `_check_mistyped_command` in support.py -- should NOT be found (moved to utils_validation.py)
</verification>

<success_criteria>
- bot/utils_validation.py exists with validate_user_input(), ValidationResult, KNOWN_COMMANDS, _edit_distance(), _check_mistyped_command()
- support.py uses validate_user_input(context="support", min_length=10) -- no inline validation remains
- learn.py uses validate_user_input(context="learn") -- no inline validation remains
- train.py uses validate_user_input(context="train") -- no inline validation remains
- All 3 handlers now have command detection with fuzzy matching (previously only support had it)
- Imports work without errors or circular dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/10-error-handling-and-ux/10-04-SUMMARY.md`
</output>
