---
phase: 20-quick-wins-by-prody
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/webapp/src/features/leads/components/LeadDetail.tsx
  - packages/webapp/src/features/leads/components/OutcomeCaptureModal.tsx
  - bot/services/followup_scheduler.py
autonomous: true

must_haves:
  truths:
    - "When changing lead status to closed_won or closed_lost, a modal prompts the user to select a closure reason"
    - "Selected closure reason is stored as metadata in lead_activity_log"
    - "Bot sends a daily digest message when stale leads exist (7+ days without update)"
  artifacts:
    - path: "packages/webapp/src/features/leads/components/OutcomeCaptureModal.tsx"
      provides: "Quick-select closure reason modal with won/lost option sets"
      contains: "CLOSURE_WON_REASONS"
    - path: "packages/webapp/src/features/leads/components/LeadDetail.tsx"
      provides: "OutcomeCaptureModal integration on closed_won/closed_lost status change"
      contains: "OutcomeCaptureModal"
    - path: "bot/services/followup_scheduler.py"
      provides: "Daily stale lead digest message"
      contains: "stale"
  key_links:
    - from: "packages/webapp/src/features/leads/components/LeadDetail.tsx"
      to: "packages/webapp/src/features/leads/components/OutcomeCaptureModal.tsx"
      via: "Renders modal when closing a lead, passes reason to activity log"
      pattern: "OutcomeCaptureModal"
    - from: "bot/services/followup_scheduler.py"
      to: "lead_registry table"
      via: "Queries for stale leads (updated_at > 7 days ago)"
      pattern: "stale.*leads"
---

<objective>
Implement outcome tracking on lead closure (QW #8) and stale lead daily digest (QW #10).

Purpose: Capture closure reasons to feed back into the training loop (why deals are won/lost), and proactively alert users about pipeline decay through daily stale lead notifications.

Output: New OutcomeCaptureModal component, LeadDetail integration, and enhanced followup_scheduler with stale digest.
</objective>

<execution_context>
@/Users/dmytrolevin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dmytrolevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@packages/webapp/src/features/leads/components/LeadDetail.tsx
@packages/webapp/src/features/leads/hooks/useUpdateLeadStatus.ts
@bot/services/followup_scheduler.py
@bot/storage/repositories.py (LeadRegistryRepo)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Outcome capture modal on lead closure</name>
  <files>
    packages/webapp/src/features/leads/components/OutcomeCaptureModal.tsx
    packages/webapp/src/features/leads/components/LeadDetail.tsx
  </files>
  <action>
Create `OutcomeCaptureModal.tsx`:
1. Define closure reason constants:
   ```typescript
   const CLOSURE_WON_REASONS = ['Strong relationship', 'Right timing', 'Competitive pricing', 'Product fit', 'Champion internal', 'Other'];
   const CLOSURE_LOST_REASONS = ['Pricing', 'Timing', 'Competition', 'No budget', 'Ghosted', 'Wrong contact', 'Other'];
   ```
2. Create a simple modal/overlay component:
   ```typescript
   interface OutcomeCaptureModalProps {
     closureType: 'closed_won' | 'closed_lost';
     onConfirm: (reason: string) => void;
     onDismiss: () => void;
   }
   ```
3. Render a backdrop overlay (fixed inset-0, bg-black/40, z-50) with a centered card showing:
   - Title: "What worked?" (won) or "What went wrong?" (lost)
   - Quick-select buttons (one per reason) styled as rounded pills in a flex-wrap layout
   - Each pill on tap calls `onConfirm(reason)`
   - A "Skip" text link at the bottom that calls `onDismiss()`
4. Style the pills: `rounded-full px-4 py-2 text-sm font-medium border border-surface-secondary bg-surface-secondary/30 text-text active:bg-accent/15 active:text-accent active:border-accent/30`
5. Use Tailwind animation for entry: `animate-in fade-in slide-in-from-bottom-4` (or simple opacity + translate via a class).

In `LeadDetail.tsx`:
1. Import `OutcomeCaptureModal`.
2. Add state: `const [closurePending, setClosurePending] = useState<{ status: 'closed_won' | 'closed_lost' } | null>(null);`
3. Modify `handleStatusChange`:
   - When `newStatus === 'closed_won' || newStatus === 'closed_lost'`, instead of immediately calling `mutation.mutate()`, set `closurePending` state to capture the status and show the modal.
   - All other statuses proceed with mutation immediately (existing behavior).
4. Add a `handleClosureConfirm` function:
   ```typescript
   const handleClosureConfirm = useCallback((reason: string) => {
     if (!closurePending || !lead || !telegramId) return;
     const vars = {
       leadId: lead.id,
       newStatus: closurePending.status,
       oldStatus: lead.status,
       telegramId,
     };
     mutation.mutate(vars, {
       onSuccess: async () => {
         // Log closure reason as activity with metadata
         await getInsforge().database.from('lead_activity_log').insert({
           lead_id: lead.id,
           telegram_id: telegramId,
           activity_type: 'outcome_capture',
           content: `Closure reason: ${reason}`,
           metadata: { closure_reason: reason, closure_type: closurePending.status },
         });
         // Fire celebration if closed_won (from Plan 01)
         if (closurePending.status === 'closed_won') {
           fireLevelUpConfetti();
           toast({ type: 'success', message: 'Deal Won! +500 XP' });
         } else {
           toast({ type: 'success', message: 'Lead closed' });
         }
         setClosurePending(null);
       },
       onError: (err) => { /* existing error handling */ },
     });
     setClosurePending(null);
   }, [closurePending, lead, telegramId, mutation, toast]);
   ```
5. Add `handleClosureDismiss` that proceeds with the status change without a reason:
   ```typescript
   const handleClosureDismiss = useCallback(() => {
     if (!closurePending || !lead || !telegramId) return;
     handleStatusChange(closurePending.status); // proceed without reason
     setClosurePending(null);
   }, [closurePending, handleStatusChange]);
   ```
   Note: For the dismiss case, call the original mutation flow (which now handles non-closure statuses). You may need to refactor `handleStatusChange` slightly to allow it to bypass the closure intercept when called from dismiss.
6. Render the modal:
   ```tsx
   {closurePending && (
     <OutcomeCaptureModal
       closureType={closurePending.status}
       onConfirm={handleClosureConfirm}
       onDismiss={handleClosureDismiss}
     />
   )}
   ```
7. Import `getInsforge` from `@/lib/insforge` if not already imported.
  </action>
  <verify>
TypeScript compiles: `cd packages/webapp && npx tsc --noEmit`.
Grep confirms `OutcomeCaptureModal` in LeadDetail.tsx.
Grep confirms `CLOSURE_WON_REASONS` in OutcomeCaptureModal.tsx.
Grep confirms `outcome_capture` activity type in LeadDetail.tsx.
  </verify>
  <done>
When changing status to closed_won/closed_lost, a modal appears with quick-select closure reasons. Selected reason is stored as metadata in lead_activity_log with activity_type 'outcome_capture'. User can skip the modal to proceed without a reason.
  </done>
</task>

<task type="auto">
  <name>Task 2: Stale lead daily digest in followup_scheduler</name>
  <files>bot/services/followup_scheduler.py</files>
  <action>
Add a stale lead digest to the existing followup scheduler:

1. Add a constant `STALE_THRESHOLD_DAYS = 7` at the module level.
2. Add a new function `_send_stale_digest`:
   ```python
   async def _send_stale_digest(
       bot: Bot,
       lead_repo: LeadRegistryRepo,
   ) -> None:
       """Send daily digest of stale leads to each user who has them."""
       now = datetime.now(timezone.utc)
       stale_cutoff = (now - timedelta(days=STALE_THRESHOLD_DAYS)).isoformat()

       try:
           # Query leads not updated in 7+ days, excluding closed statuses
           stale_leads = await lead_repo.client.query(
               "lead_registry",
               params={
                   "updated_at": f"lt.{stale_cutoff}",
                   "status": "not.in.(closed_won,closed_lost)",
                   "select": "id,telegram_id,prospect_name,prospect_company,status,updated_at",
                   "order": "updated_at.asc",
               },
           )
       except Exception as e:
           logger.error("Failed to query stale leads: %s", e)
           return

       if not stale_leads:
           return

       # Group by telegram_id
       by_user: dict[int, list] = {}
       for lead in stale_leads:
           tg_id = lead.get("telegram_id")
           if tg_id:
               by_user.setdefault(tg_id, []).append(lead)

       for tg_id, leads in by_user.items():
           count = len(leads)
           # Build digest message
           lines = [f"ðŸ“Š *Stale Lead Digest*\n"]
           lines.append(f"You have *{count} lead{'s' if count != 1 else ''}* not touched in 7+ days:\n")
           for lead in leads[:5]:
               name = lead.get("prospect_name", "Unknown")
               company = lead.get("prospect_company")
               display = f"{name}"
               if company:
                   display += f" @ {company}"
               days_ago = (now - datetime.fromisoformat(lead["updated_at"].replace("Z", "+00:00"))).days
               lines.append(f"  â€¢ {display} â€” {days_ago}d ago")
           if count > 5:
               lines.append(f"\n  ... and {count - 5} more")
           lines.append("\nOpen /leads to review your pipeline.")

           try:
               await bot.send_message(
                   tg_id,
                   "\n".join(lines),
                   parse_mode="Markdown",
               )
               logger.info("Sent stale digest to user %s (%d stale leads)", tg_id, count)
           except Exception as e:
               logger.warning("Failed to send stale digest to %s: %s", tg_id, e)
   ```
3. In the main scheduler loop function (`run_followup_scheduler` or `_process_due_followups` loop), add a call to `_send_stale_digest` once per day. Since the scheduler runs every 6 hours, add a check:
   - Add a module-level variable `_last_stale_digest: datetime | None = None`
   - In the main loop iteration, check: `if _last_stale_digest is None or (now - _last_stale_digest).total_seconds() > 24 * 3600:`
   - If true, call `await _send_stale_digest(bot, lead_repo)` and update `_last_stale_digest = now`.
4. This ensures the digest is sent at most once per 24 hours, triggered by the existing 6-hour polling cycle. No new scheduler loop needed.
  </action>
  <verify>
Python syntax check: `python3 -c "import ast; ast.parse(open('bot/services/followup_scheduler.py').read()); print('OK')"`.
Grep confirms `_send_stale_digest` function in followup_scheduler.py.
Grep confirms `STALE_THRESHOLD_DAYS` constant.
  </verify>
  <done>
Bot sends a daily stale lead digest message to users who have leads not updated in 7+ days. Shows up to 5 stale leads with name, company, and days since last update. Only sends if stale count > 0, max once per 24 hours.
  </done>
</task>

</tasks>

<verification>
1. OutcomeCaptureModal.tsx exists with won/lost reason sets and quick-select pills
2. LeadDetail.tsx intercepts closed_won/closed_lost to show OutcomeCaptureModal before mutation
3. Closure reason stored in lead_activity_log with activity_type 'outcome_capture' and metadata JSONB
4. followup_scheduler.py sends daily stale digest with 7-day threshold
5. Stale digest limited to once per 24 hours
</verification>

<success_criteria>
- Closing a lead prompts for reason selection before finalizing status change
- Closure reasons stored in lead_activity_log with structured metadata
- "Skip" option available for users who don't want to provide a reason
- Daily stale lead digest sent only when stale leads exist
- No new database migrations required (uses existing metadata JSONB field)
</success_criteria>

<output>
After completion, create `.planning/phases/20-quick-wins-by-prody/20-04-SUMMARY.md`
</output>
