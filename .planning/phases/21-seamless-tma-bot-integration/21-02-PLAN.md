---
phase: 21-seamless-tma-bot-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - insforge/migrations/010_tma_events.sql
  - bot/storage/models.py
  - bot/storage/repositories.py
  - bot/services/tma_event_poller.py
  - bot/main.py
autonomous: true

must_haves:
  truths:
    - "A tma_events table exists for TMA-to-Bot real-time event communication"
    - "Bot polls tma_events and sends Telegram confirmation messages for step completion, status change, and lead assignment"
    - "Bot confirmation message includes lead name, action description, and next step due date when applicable"
    - "Processed events are marked as delivered so they are not re-sent"
  artifacts:
    - path: "insforge/migrations/010_tma_events.sql"
      provides: "tma_events table with type, payload, status columns"
      contains: "CREATE TABLE"
    - path: "bot/storage/models.py"
      provides: "TmaEventModel Pydantic model"
      contains: "TmaEventModel"
    - path: "bot/storage/repositories.py"
      provides: "TmaEventRepo with claim_next and mark_delivered"
      contains: "TmaEventRepo"
    - path: "bot/services/tma_event_poller.py"
      provides: "Background poller that processes TMA events and sends Telegram messages"
      contains: "start_tma_event_poller"
    - path: "bot/main.py"
      provides: "TmaEventRepo creation and poller startup"
      contains: "tma_event_poller"
  key_links:
    - from: "bot/services/tma_event_poller.py"
      to: "bot/storage/repositories.py"
      via: "TmaEventRepo.claim_next"
      pattern: "claim_next"
    - from: "bot/services/tma_event_poller.py"
      to: "aiogram.Bot.send_message"
      via: "Telegram confirmation messages"
      pattern: "bot.send_message"
---

<objective>
Create the TMA event bus infrastructure: a `tma_events` database table, Pydantic model, repository, and a bot-side poller that processes events from TMA and sends Telegram confirmation messages.

Purpose: SC2 requires that TMA actions (step completion, status change, lead assignment) trigger bot confirmation messages. This plan builds the foundation: the table, the model, the repo, and the poller. The next plan (21-03) will wire TMA mutations to write events.

Output: Working tma_events pipeline from table to bot poller to Telegram message.
</objective>

<execution_context>
@/Users/dmytrolevin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dmytrolevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@bot/storage/models.py
@bot/storage/repositories.py
@bot/services/draft_poller.py
@bot/services/plan_poller.py
@bot/main.py
@insforge/migrations/006_draft_requests.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tma_events migration, model, and repository</name>
  <files>
    insforge/migrations/010_tma_events.sql
    bot/storage/models.py
    bot/storage/repositories.py
  </files>
  <action>
Create `insforge/migrations/010_tma_events.sql`:
```sql
CREATE TABLE IF NOT EXISTS tma_events (
  id BIGSERIAL PRIMARY KEY,
  telegram_id BIGINT NOT NULL,
  event_type TEXT NOT NULL,          -- step_completed, step_skipped, status_changed, lead_assigned
  lead_id BIGINT,
  payload JSONB DEFAULT '{}',        -- flexible payload per event type
  status TEXT NOT NULL DEFAULT 'pending'
    CHECK (status IN ('pending', 'processing', 'delivered', 'failed')),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  delivered_at TIMESTAMPTZ
);

-- Index for poller: find pending events efficiently
CREATE INDEX IF NOT EXISTS idx_tma_events_pending
  ON tma_events (status, created_at ASC)
  WHERE status = 'pending';

-- Index for cleanup: find old delivered events
CREATE INDEX IF NOT EXISTS idx_tma_events_delivered
  ON tma_events (delivered_at)
  WHERE status = 'delivered';

-- RLS: TMA uses anon key, needs insert + select
ALTER TABLE tma_events ENABLE ROW LEVEL SECURITY;
CREATE POLICY anon_full_tma_events ON tma_events FOR ALL USING (true) WITH CHECK (true);
```

Add `TmaEventModel` to `bot/storage/models.py`:
```python
class TmaEventModel(BaseModel):
    """TMA-to-Bot event for cross-interface notifications."""
    id: int | None = None
    telegram_id: int
    event_type: str  # step_completed, step_skipped, status_changed, lead_assigned
    lead_id: int | None = None
    payload: dict[str, Any] = {}
    status: str = "pending"
    created_at: str | None = None
    delivered_at: str | None = None
```

Add `TmaEventRepo` to `bot/storage/repositories.py` following the DraftRequestRepo pattern:
- `claim_next() -> TmaEventModel | None`: Query oldest pending event, update to processing (two-step claim pattern like DraftRequestRepo.claim_next_pending)
- `mark_delivered(event_id: int) -> None`: Update status to 'delivered', set delivered_at to now
- `mark_failed(event_id: int, error: str) -> None`: Update status to 'failed'
- `reset_stale_processing(max_age_minutes: int = 2) -> int`: Reset stale 'processing' events back to 'pending' (same pattern as DraftRequestRepo)

Import TmaEventModel in repositories.py.
  </action>
  <verify>Read migration file, models.py for TmaEventModel, and repositories.py for TmaEventRepo with claim_next, mark_delivered, mark_failed, reset_stale_processing methods.</verify>
  <done>tma_events table, TmaEventModel, and TmaEventRepo exist with proven claim-and-deliver pattern matching existing draft_requests/plan_requests repos.</done>
</task>

<task type="auto">
  <name>Task 2: Create TMA event poller and wire into bot startup</name>
  <files>
    bot/services/tma_event_poller.py
    bot/main.py
  </files>
  <action>
Create `bot/services/tma_event_poller.py`:

Constants:
- POLL_INTERVAL = 3 seconds (same as draft/plan pollers)

Function `_format_confirmation_message(event_type: str, payload: dict, lead_name: str) -> str`:
- `step_completed`: "Step {step_id} marked complete for {lead_name}.{next_step_info}"
  - payload: { step_id, step_desc, next_step_desc, next_step_due }
  - If next_step_due exists: "\nNext: Step {next_step_id} — {next_step_desc} (due {relative_date})"
  - If no next step: "\nAll engagement steps complete!"
- `step_skipped`: "Step {step_id} skipped for {lead_name}."
  - payload: { step_id, step_desc, reason }
  - If reason: " Reason: {reason}"
- `status_changed`: "Lead status updated: {lead_name} → {new_status}"
  - payload: { old_status, new_status }
- `lead_assigned`: "{lead_name} assigned to {member_name}."
  - payload: { member_name }
- Default fallback for unknown types: "Action completed for {lead_name}."

Use the `_format_relative_date` helper (import from plan_scheduler if it's there, or inline a local copy).

Function `_process_tma_event(bot, event, event_repo, lead_repo)`:
- Fetch lead from lead_repo if event.lead_id exists (for name/company context)
- lead_name = lead.prospect_name if lead else payload.get("lead_name", "your lead")
- Format the confirmation message
- Send via `bot.send_message(chat_id=event.telegram_id, text=message, parse_mode="Markdown")`
- Mark event as delivered
- On send error, still mark as delivered (don't re-send on next poll -- at-most-once delivery)

Function `start_tma_event_poller(bot, event_repo, lead_repo)`:
- On startup: call reset_stale_processing (same pattern as draft/plan pollers)
- Loop: claim_next, if event exists process it, sleep POLL_INTERVAL
- Wrap iteration in try/except with logger.error

Wire into `bot/main.py`:
- Import `TmaEventRepo` in the repositories import block
- Import `start_tma_event_poller` from bot.services.tma_event_poller
- Create `tma_event_repo = TmaEventRepo(insforge)` after other repos
- Add `"tma_event_repo": tma_event_repo` to workflow_data (optional, for future use)
- Start the poller as a background task alongside existing pollers:
  ```python
  create_background_task(
      start_tma_event_poller(bot, tma_event_repo, lead_repo),
      name="tma_event_poller",
  )
  ```
- Place inside the `if engagement_service:` block where other pollers are started
  </action>
  <verify>Read tma_event_poller.py for _format_confirmation_message handling all 4 event types, _process_tma_event with at-most-once delivery, and start_tma_event_poller with stale recovery. Read main.py for repo creation and poller startup.</verify>
  <done>Bot polls tma_events table every 3s, processes events, sends Telegram confirmations for step_completed, step_skipped, status_changed, and lead_assigned events, and marks events as delivered.</done>
</task>

</tasks>

<verification>
1. Read migration SQL -- tma_events table with correct columns, indexes, and RLS
2. Read models.py -- TmaEventModel with all required fields
3. Read repositories.py -- TmaEventRepo with claim_next, mark_delivered, mark_failed, reset_stale_processing
4. Read tma_event_poller.py -- processes all 4 event types, sends Telegram messages
5. Read main.py -- TmaEventRepo created, poller started as background task
</verification>

<success_criteria>
- tma_events table provides a reliable event bus from TMA to Bot
- Bot poller processes events and sends human-readable Telegram confirmations
- At-most-once delivery prevents duplicate messages on bot restart
- Pattern matches proven draft_requests/plan_requests infrastructure
</success_criteria>

<output>
After completion, create `.planning/phases/21-seamless-tma-bot-integration/21-02-SUMMARY.md`
</output>
