---
phase: 21-seamless-tma-bot-integration
plan: 03
type: execute
wave: 2
depends_on: ["21-02"]
files_modified:
  - packages/webapp/src/features/leads/hooks/useUpdatePlanStep.ts
  - packages/webapp/src/features/leads/hooks/useUpdateLeadStatus.ts
  - packages/webapp/src/features/admin/hooks/useAssignLead.ts
  - packages/webapp/src/lib/tmaEvents.ts
  - packages/webapp/src/features/leads/hooks/useBotNotifications.ts
  - packages/webapp/src/features/leads/components/LeadDetail.tsx
  - packages/webapp/src/pages/Dashboard.tsx
  - packages/webapp/src/shared/stores/toastStore.ts
autonomous: true

must_haves:
  truths:
    - "When a user completes a step in TMA, the bot sends a confirmation message in Telegram chat"
    - "When a user changes lead status in TMA, the bot sends a confirmation message"
    - "When an admin assigns a lead in TMA, the bot sends a confirmation"
    - "When bot finishes async work (draft ready, plan ready) and TMA is open, a toast notification appears with a link"
    - "Toast notifications for bot async work include action buttons to navigate to the relevant lead"
  artifacts:
    - path: "packages/webapp/src/lib/tmaEvents.ts"
      provides: "Helper function to insert tma_events rows from TMA mutations"
      contains: "emitTmaEvent"
    - path: "packages/webapp/src/features/leads/hooks/useBotNotifications.ts"
      provides: "Polling hook that checks for bot-completed async work and shows toasts"
      contains: "useBotNotifications"
    - path: "packages/webapp/src/features/leads/hooks/useUpdatePlanStep.ts"
      provides: "Event emission on step completion"
      contains: "emitTmaEvent"
  key_links:
    - from: "packages/webapp/src/features/leads/hooks/useUpdatePlanStep.ts"
      to: "packages/webapp/src/lib/tmaEvents.ts"
      via: "emitTmaEvent call in onSuccess"
      pattern: "emitTmaEvent"
    - from: "packages/webapp/src/features/leads/hooks/useBotNotifications.ts"
      to: "packages/webapp/src/shared/stores/toastStore.ts"
      via: "addToast for bot async work completion"
      pattern: "addToast"
---

<objective>
Wire TMA mutations to emit events to the tma_events table (so the bot sends Telegram confirmations), and add a polling hook that detects bot-completed async work (draft ready, plan ready) and shows toast notifications inside TMA with navigation links.

Purpose: SC2 requires TMA actions to trigger bot confirmations. SC3 requires the TMA to show toasts when bot finishes async work. This plan connects both sides.

Output: TMA mutation hooks emit events, bot sends confirmations. TMA polls for async completion and shows toasts with links.
</objective>

<execution_context>
@/Users/dmytrolevin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dmytrolevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-seamless-tma-bot-integration/21-02-PLAN.md
@packages/webapp/src/features/leads/hooks/useUpdatePlanStep.ts
@packages/webapp/src/features/leads/hooks/useUpdateLeadStatus.ts
@packages/webapp/src/features/leads/hooks/useGenerateDraft.ts
@packages/webapp/src/features/leads/hooks/useGeneratePlan.ts
@packages/webapp/src/shared/stores/toastStore.ts
@packages/webapp/src/shared/ui/Toast.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TMA event emitter and wire into mutation hooks</name>
  <files>
    packages/webapp/src/lib/tmaEvents.ts
    packages/webapp/src/features/leads/hooks/useUpdatePlanStep.ts
    packages/webapp/src/features/leads/hooks/useUpdateLeadStatus.ts
    packages/webapp/src/features/admin/hooks/useAssignLead.ts
  </files>
  <action>
Create `packages/webapp/src/lib/tmaEvents.ts`:
```typescript
/**
 * TMA event emitter -- inserts rows into tma_events table
 * for bot-side confirmation messages.
 *
 * Fire-and-forget: errors are logged but never block the mutation.
 */
import { getInsforge } from '@/lib/insforge';

interface TmaEventPayload {
  [key: string]: unknown;
}

export async function emitTmaEvent(
  telegramId: number,
  eventType: string,
  leadId: number | null,
  payload: TmaEventPayload = {},
): Promise<void> {
  try {
    await getInsforge().database.from('tma_events').insert({
      telegram_id: telegramId,
      event_type: eventType,
      lead_id: leadId,
      payload,
      status: 'pending',
    });
  } catch (err) {
    console.warn('Failed to emit TMA event:', err);
  }
}
```

Wire into `useUpdatePlanStep.ts`:
- Import `emitTmaEvent` from `@/lib/tmaEvents`
- In `onSettled` callback (after cache invalidation), add event emission:
  - Only emit when mutation succeeded (check `_data` is not undefined and `_err` is null/undefined)
  - For 'done' status: `emitTmaEvent(telegramId, 'step_completed', leadId, { step_id: stepId, step_desc: '...' })`
  - For 'skipped' status: `emitTmaEvent(telegramId, 'step_skipped', leadId, { step_id: stepId, reason: cantPerformReason })`
  - For 'pending' (reset): don't emit (not user-facing)
  - Getting step_desc: extract from the updatedPlan in _data (the mutation returns { updatedPlan }) -- find the step by stepId and get its description
  - Also include next step info if available: find next pending step (status === 'pending') after the completed step, include next_step_id, next_step_desc. next_step_due is not easily available from TMA side (would need reminder query), so omit it -- the bot poller will look it up itself.

Wire into `useUpdateLeadStatus.ts`:
- Import `emitTmaEvent`
- In `onSettled`, if `_err` is null: `emitTmaEvent(telegramId, 'status_changed', leadId, { old_status: oldStatus, new_status: newStatus })`

Wire into `useAssignLead.ts`:
- Read the file first to understand its structure
- Import `emitTmaEvent`
- After successful assignment: `emitTmaEvent(telegramId, 'lead_assigned', leadId, { member_name: '...' })`
- This is fire-and-forget: if the event fails, the assignment still succeeded

CRITICAL: All emitTmaEvent calls are fire-and-forget. Use .catch or try/catch. Never let event emission failure break the mutation flow.
  </action>
  <verify>Read tmaEvents.ts for emitTmaEvent function. Read useUpdatePlanStep.ts for step_completed and step_skipped events. Read useUpdateLeadStatus.ts for status_changed event. Read useAssignLead.ts for lead_assigned event. Confirm all calls are fire-and-forget (errors caught).</verify>
  <done>All three TMA mutation hooks emit events to tma_events on success, enabling bot-side Telegram confirmations. Event emission is fire-and-forget and never blocks mutations.</done>
</task>

<task type="auto">
  <name>Task 2: Create bot notification polling hook and wire toasts for async work</name>
  <files>
    packages/webapp/src/features/leads/hooks/useBotNotifications.ts
    packages/webapp/src/features/leads/components/LeadDetail.tsx
    packages/webapp/src/pages/Dashboard.tsx
    packages/webapp/src/shared/stores/toastStore.ts
  </files>
  <action>
Create `packages/webapp/src/features/leads/hooks/useBotNotifications.ts`:

This hook polls for recently completed async work (draft_requests and plan_requests that transitioned to 'completed' in the last 60 seconds) and shows toast notifications when found.

```typescript
/**
 * Polls for bot-completed async work and shows toast notifications.
 *
 * Checks draft_requests and plan_requests for recently completed items
 * that haven't been seen yet. Shows a toast with a link to navigate
 * to the relevant lead.
 */
```

Implementation:
- Use `useQuery` with a 10-second refetchInterval (lighter than the 3s polling used by draft generation itself)
- Query: `draft_requests` where `status = 'completed'` and `telegram_id = telegramId` and `updated_at > 60 seconds ago`, select `id, lead_id, status, updated_at`
- Also query: `plan_requests` where `status = 'completed'` and `telegram_id = telegramId` and `updated_at > 60 seconds ago`, select `id, lead_id, status, updated_at`
- Track seen IDs in a `useRef<Set<string>>` (key: `draft:{id}` or `plan:{id}`) to prevent duplicate toasts
- When a new completed item is found (not in seen set):
  - Add to seen set
  - Show toast: `{ type: 'info', message: 'Draft ready for {lead_name}', action: { label: 'View', onClick: () => navigate('/leads/{leadId}') } }`
  - For plan: `{ type: 'success', message: 'Engagement plan ready!', action: { label: 'View', onClick: () => navigate('/leads/{leadId}') } }`
  - Duration: 6000ms (longer than default 4000ms so user notices)
- The hook takes `telegramId: number` and optionally `enabled: boolean` (default true)
- Import `useToast` from toastStore, `useNavigate` from react-router
- Export as named function `useBotNotifications`

Update Toast store (`toastStore.ts`):
- No changes needed -- already supports `action` and `duration` fields from Phase 19

Wire `useBotNotifications` into `LeadDetail.tsx`:
- Import `useBotNotifications`
- Call it near the top of the component: `useBotNotifications(telegramId)` -- this will show toasts when drafts or plans complete while the user is viewing any lead detail

Wire `useBotNotifications` into `Dashboard.tsx`:
- Import `useBotNotifications`
- Call at the top: `useBotNotifications(telegramId)` with the auth store telegramId -- shows toasts when on dashboard too

Note: The hook uses useNavigate internally, so it must be called within the router context (which both LeadDetail and Dashboard are).

Keep the query lightweight -- only fetch id/lead_id/updated_at columns, cap at 5 results, and the 60-second window keeps the result set tiny.
  </action>
  <verify>Read useBotNotifications.ts for polling logic with seen-ID dedup and toast display. Read LeadDetail.tsx and Dashboard.tsx for hook integration. Confirm toasts include action buttons with navigation.</verify>
  <done>TMA polls for bot-completed async work (drafts, plans) and shows toast notifications with "View" action buttons that navigate to the relevant lead. Toasts appear on both Dashboard and LeadDetail pages.</done>
</task>

</tasks>

<verification>
1. Read tmaEvents.ts -- emitTmaEvent helper function exists
2. Read useUpdatePlanStep.ts -- emits step_completed/step_skipped events
3. Read useUpdateLeadStatus.ts -- emits status_changed event
4. Read useAssignLead.ts -- emits lead_assigned event
5. Read useBotNotifications.ts -- polls draft_requests and plan_requests, shows toasts
6. Read LeadDetail.tsx -- useBotNotifications called
7. Read Dashboard.tsx -- useBotNotifications called
8. Confirm all event emissions are fire-and-forget (never block mutations)
</verification>

<success_criteria>
- TMA mutations trigger bot Telegram confirmation messages via tma_events table
- TMA shows toast notifications when bot finishes async draft or plan generation
- Toast notifications include "View" action that navigates to the relevant lead
- No mutation is slowed or blocked by event emission failures
</success_criteria>

<output>
After completion, create `.planning/phases/21-seamless-tma-bot-integration/21-03-SUMMARY.md`
</output>
