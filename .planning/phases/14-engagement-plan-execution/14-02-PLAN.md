---
phase: 14-engagement-plan-execution
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - bot/handlers/reminders.py
  - bot/main.py
autonomous: true

must_haves:
  truths:
    - "User can tap Done on a reminder to mark step complete and log activity"
    - "User can tap Snooze to delay the reminder 24 hours"
    - "User can tap Skip to mark step as skipped"
    - "User can tap View Full Draft to see the full suggested message"
    - "Every step action is recorded in lead_activity_log"
  artifacts:
    - path: "bot/handlers/reminders.py"
      provides: "Callback handlers for reminder actions"
      exports: ["router"]
    - path: "bot/main.py"
      provides: "Router registration for reminders handler"
      contains: "dp.include_router(reminders.router)"
  key_links:
    - from: "bot/handlers/reminders.py"
      to: "bot/storage/repositories.py"
      via: "activity_repo.create() for activity logging"
      pattern: "activity_repo\\.create"
    - from: "bot/handlers/reminders.py"
      to: "bot/storage/repositories.py"
      via: "reminder_repo.snooze() for snooze action"
      pattern: "reminder_repo\\.snooze"
    - from: "bot/main.py"
      to: "bot/handlers/reminders.py"
      via: "router registration"
      pattern: "from bot.handlers import.*reminders"
---

<objective>
Create callback handlers for reminder inline button actions (Done/Snooze/Skip/ViewDraft) and wire them into the bot.

Purpose: Plan 01 added inline buttons to reminder messages, but the buttons have no handlers yet. This plan implements the callback handlers that respond to button presses, update reminder status, sync engagement_plan JSONB, and log activity.

Output: New `bot/handlers/reminders.py` module with four callback handlers, and `main.py` updated to register the router.
</objective>

<execution_context>
@/Users/dmytrolevin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dmytrolevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-engagement-plan-execution/14-RESEARCH.md
@.planning/phases/14-engagement-plan-execution/14-01-SUMMARY.md

@bot/handlers/leads.py (callback handler patterns, lines 370-580)
@bot/main.py (router registration pattern)
@bot/storage/repositories.py
@bot/storage/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create reminders.py callback handler module</name>
  <files>bot/handlers/reminders.py</files>
  <action>
Create a new handler module `bot/handlers/reminders.py` with callback handlers for reminder actions.

**File structure:**

```python
"""Callback handlers for reminder inline button actions."""

from __future__ import annotations

import logging
from datetime import datetime, timedelta, timezone

from aiogram import F, Router
from aiogram.types import CallbackQuery, InlineKeyboardButton, InlineKeyboardMarkup

from bot.storage.models import LeadActivityModel
from bot.storage.repositories import (
    LeadActivityRepo,
    LeadRegistryRepo,
    ScheduledReminderRepo,
)

logger = logging.getLogger(__name__)
router = Router(name="reminders")
```

**Handler 1: on_reminder_done**
- Filter: `F.data.startswith("reminder:done:")`
- Parse lead_id, step_id from callback_data
- Fetch lead and reminder
- Update reminder status to "completed"
- Update engagement_plan JSONB: set step status to "done", completed_at to now
- Log activity with type "step_execution"
- Edit message to show completion confirmation with View Lead button
- Call `callback.answer("Marked as done!")`
- Wrap message edit in try/except to handle "message is not modified" error

**Handler 2: on_reminder_snooze**
- Filter: `F.data.startswith("reminder:snooze:")`
- Parse lead_id, step_id from callback_data
- Calculate new due: now + 24 hours
- Call `reminder_repo.snooze(reminder.id, new_due.isoformat())`
- Log activity with type "step_snooze"
- Edit message to show snooze confirmation
- Call `callback.answer("Snoozed for 24h")`

**Handler 3: on_reminder_skip**
- Filter: `F.data.startswith("reminder:skip:")`
- Parse lead_id, step_id from callback_data
- Update reminder status to "skipped"
- Update engagement_plan JSONB: set step status to "skipped"
- Log activity with type "step_skip"
- Edit message to show skip confirmation
- Call `callback.answer("Step skipped")`

**Handler 4: on_reminder_draft**
- Filter: `F.data.startswith("reminder:draft:")`
- Parse lead_id, step_id from callback_data
- Get draft from reminder.draft_text or step.suggested_text
- Get step description from engagement_plan
- Display full draft with action buttons (Done, Snooze, View Lead)
- Call `callback.answer()`

**Implementation patterns (from leads.py):**

1. Parse callback_data:
```python
parts = callback.data.split(":")  # type: ignore[union-attr]
lead_id = int(parts[2])
step_id = int(parts[3])
```

2. Get telegram_id:
```python
tg_id = callback.from_user.id
```

3. Handle message edit errors:
```python
try:
    await callback.message.edit_text(...)  # type: ignore[union-attr]
except Exception:
    pass  # Message already modified
```

4. Activity logging pattern:
```python
await activity_repo.create(
    LeadActivityModel(
        lead_id=lead_id,
        telegram_id=tg_id,
        activity_type="step_execution",  # or step_snooze, step_skip
        content=f"Completed: {step_desc}",
    )
)
```

5. Dual-update pattern (reminder + engagement_plan):
```python
# 1. Update scheduled_reminders (scheduling authority)
await reminder_repo.update_status(reminder.id, "completed")

# 2. Update engagement_plan JSONB (display authority)
if lead.engagement_plan:
    now_iso = datetime.now(timezone.utc).isoformat()
    updated_plan = []
    for step in lead.engagement_plan:
        if step.get("step_id") == step_id:
            step["status"] = "done"
            step["completed_at"] = now_iso
        updated_plan.append(step)
    await lead_repo.update_lead(lead_id, engagement_plan=updated_plan)
```

**Full handler implementations are in 14-RESEARCH.md Examples 3-6.**

Use Markdown parse_mode for all edit_text calls. Include View Lead button in all confirmation messages.
  </action>
  <verify>
1. File exists: `ls bot/handlers/reminders.py`
2. Contains router: grep for `router = Router`
3. Contains all 4 handlers: grep for `reminder:done:`, `reminder:snooze:`, `reminder:skip:`, `reminder:draft:`
4. Contains activity logging: grep for `activity_repo.create`
5. No syntax errors: `python -m py_compile bot/handlers/reminders.py`
  </verify>
  <done>
reminders.py module exists with Done/Snooze/Skip/ViewDraft callback handlers that update reminder status, sync engagement_plan JSONB, and log activity.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire reminders router into main.py</name>
  <files>bot/main.py</files>
  <action>
Update `bot/main.py` to register the reminders router:

1. **Add import** in the handlers import section (around line 20):
```python
from bot.handlers import admin, leads, learn, progress, reminders, settings, start, stats, support, train
```

2. **Add router registration** in the "Register routers" section (around line 181), after leads router:
```python
dp.include_router(leads.router)
dp.include_router(reminders.router)  # Add this line
dp.include_router(admin.router)
```

The order matters: reminders.router should come after leads.router since both share callback patterns for lead:view:* but reminders.router only handles reminder:* callbacks.
  </action>
  <verify>
1. grep for `from bot.handlers import.*reminders` in main.py confirms import
2. grep for `reminders.router` in main.py confirms registration
3. No syntax errors: `python -m py_compile bot/main.py`
  </verify>
  <done>
main.py imports reminders module and registers reminders.router with the dispatcher.
  </done>
</task>

</tasks>

<verification>
1. reminders.py exists with Router and 4 callback handlers
2. Each handler uses correct filter pattern (reminder:done:, etc.)
3. Done handler: updates reminder to completed, updates engagement_plan, logs step_execution
4. Snooze handler: calls reminder_repo.snooze(), logs step_snooze
5. Skip handler: updates reminder to skipped, updates engagement_plan, logs step_skip
6. Draft handler: displays full draft with action buttons
7. All handlers call callback.answer() and wrap edit_text in try/except
8. main.py imports and registers reminders.router
9. No syntax errors in either file
</verification>

<success_criteria>
- Tapping Done marks the step complete in both scheduled_reminders and engagement_plan, logs activity
- Tapping Snooze delays the reminder 24h via snooze() method, logs activity
- Tapping Skip marks the step skipped in both tables, logs activity
- Tapping View Full Draft shows the complete suggested message with action buttons
- All activity types (step_execution, step_snooze, step_skip) are logged to lead_activity_log
- Callback buttons never hang (callback.answer() always called)
- Message edit errors are silently handled
</success_criteria>

<output>
After completion, create `.planning/phases/14-engagement-plan-execution/14-02-SUMMARY.md`
</output>
