---
phase: 14-engagement-plan-execution
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - bot/handlers/reminders.py
  - bot/main.py
autonomous: true

must_haves:
  truths:
    - "User can tap Done on a reminder to mark step complete and log activity"
    - "User can tap Snooze to delay the reminder 24 hours"
    - "User can tap Skip to mark step as skipped"
    - "User can tap View Full Draft to see the full suggested message"
    - "Every step action is recorded in lead_activity_log"
  artifacts:
    - path: "bot/handlers/reminders.py"
      provides: "Callback handlers for reminder actions"
      exports: ["router"]
    - path: "bot/main.py"
      provides: "Router registration for reminders handler"
      contains: "dp.include_router(reminders.router)"
  key_links:
    - from: "bot/handlers/reminders.py"
      to: "bot/storage/repositories.py"
      via: "activity_repo.create() for activity logging"
      pattern: "activity_repo\\.create"
    - from: "bot/handlers/reminders.py"
      to: "bot/storage/repositories.py"
      via: "reminder_repo.snooze() for snooze action"
      pattern: "reminder_repo\\.snooze"
    - from: "bot/main.py"
      to: "bot/handlers/reminders.py"
      via: "router registration"
      pattern: "from bot.handlers import.*reminders"
    - from: "bot/services/plan_scheduler.py"
      to: "bot/handlers/reminders.py"
      via: "callback_data patterns for inline buttons"
      pattern: "reminder:(done|snooze|skip|draft):{lead_id}:{step_id}"
---

<objective>
Create callback handlers for reminder inline button actions (Done/Snooze/Skip/ViewDraft) and wire them into the bot.

Purpose: Plan 01 added inline buttons to reminder messages, but the buttons have no handlers yet. This plan implements the callback handlers that respond to button presses, update reminder status, sync engagement_plan JSONB, and log activity.

Output: New `bot/handlers/reminders.py` module with four callback handlers, and `main.py` updated to register the router.
</objective>

<execution_context>
@/Users/dmytrolevin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dmytrolevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-engagement-plan-execution/14-01-SUMMARY.md

@bot/handlers/leads.py (callback handler patterns, lines 370-580)
@bot/main.py (router registration pattern)
@bot/storage/repositories.py
@bot/storage/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create reminders.py callback handler module</name>
  <files>bot/handlers/reminders.py</files>
  <action>
Create a new handler module `bot/handlers/reminders.py` with callback handlers for reminder actions.

**Complete implementation:**

```python
"""Callback handlers for reminder inline button actions."""

from __future__ import annotations

import logging
from datetime import datetime, timedelta, timezone

from aiogram import F, Router
from aiogram.types import CallbackQuery, InlineKeyboardButton, InlineKeyboardMarkup

from bot.storage.models import LeadActivityModel
from bot.storage.repositories import (
    LeadActivityRepo,
    LeadRegistryRepo,
    ScheduledReminderRepo,
)

logger = logging.getLogger(__name__)
router = Router(name="reminders")


@router.callback_query(F.data.startswith("reminder:done:"))
async def on_reminder_done(
    callback: CallbackQuery,
    lead_repo: LeadRegistryRepo,
    reminder_repo: ScheduledReminderRepo,
    activity_repo: LeadActivityRepo,
) -> None:
    """Mark a step as done, update both tables, log activity."""
    parts = callback.data.split(":")  # type: ignore[union-attr]
    lead_id = int(parts[2])
    step_id = int(parts[3])
    tg_id = callback.from_user.id

    lead = await lead_repo.get_by_id(lead_id)
    reminder = await reminder_repo.get_by_lead_and_step(lead_id, step_id)

    if not lead or not reminder:
        await callback.answer("Step not found.")
        return

    step_desc = ""
    if lead.engagement_plan:
        for step in lead.engagement_plan:
            if step.get("step_id") == step_id:
                step_desc = step.get("description", f"Step {step_id}")
                break

    await reminder_repo.update_status(reminder.id, "completed")

    if lead.engagement_plan:
        now_iso = datetime.now(timezone.utc).isoformat()
        updated_plan = []
        for step in lead.engagement_plan:
            if step.get("step_id") == step_id:
                step["status"] = "done"
                step["completed_at"] = now_iso
            updated_plan.append(step)
        await lead_repo.update_lead(lead_id, engagement_plan=updated_plan)

    await activity_repo.create(
        LeadActivityModel(
            lead_id=lead_id,
            telegram_id=tg_id,
            activity_type="step_execution",
            content=f"Completed: {step_desc}",
        )
    )

    name = lead.prospect_name or f"Lead #{lead.id}"
    try:
        await callback.message.edit_text(
            f"\u2705 *Step {step_id} completed for {name}!*\n\n"
            f"{step_desc}\n\nGreat job! Keep the momentum going.",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="\U0001F4CB View Lead", callback_data=f"lead:view:{lead_id}")]
            ]),
        )
    except Exception:
        pass

    await callback.answer("Marked as done!")


@router.callback_query(F.data.startswith("reminder:snooze:"))
async def on_reminder_snooze(
    callback: CallbackQuery,
    lead_repo: LeadRegistryRepo,
    reminder_repo: ScheduledReminderRepo,
    activity_repo: LeadActivityRepo,
) -> None:
    """Snooze a reminder for 24 hours."""
    parts = callback.data.split(":")
    lead_id = int(parts[2])
    step_id = int(parts[3])
    tg_id = callback.from_user.id

    lead = await lead_repo.get_by_id(lead_id)
    reminder = await reminder_repo.get_by_lead_and_step(lead_id, step_id)

    if not lead or not reminder:
        await callback.answer("Step not found.")
        return

    new_due = datetime.now(timezone.utc) + timedelta(hours=24)
    await reminder_repo.snooze(reminder.id, new_due.isoformat())

    await activity_repo.create(
        LeadActivityModel(
            lead_id=lead_id,
            telegram_id=tg_id,
            activity_type="step_snooze",
            content=f"Snoozed step {step_id} for 24 hours",
        )
    )

    name = lead.prospect_name or f"Lead #{lead.id}"
    try:
        await callback.message.edit_text(
            f"\u23F0 *Snoozed: {name} - Step {step_id}*\n\n"
            f"I'll remind you again in 24 hours.\n\nUse /leads to view all your leads.",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="\U0001F4CB View Lead", callback_data=f"lead:view:{lead_id}")]
            ]),
        )
    except Exception:
        pass

    await callback.answer("Snoozed for 24h")


@router.callback_query(F.data.startswith("reminder:skip:"))
async def on_reminder_skip(
    callback: CallbackQuery,
    lead_repo: LeadRegistryRepo,
    reminder_repo: ScheduledReminderRepo,
    activity_repo: LeadActivityRepo,
) -> None:
    """Skip a step entirely."""
    parts = callback.data.split(":")
    lead_id = int(parts[2])
    step_id = int(parts[3])
    tg_id = callback.from_user.id

    lead = await lead_repo.get_by_id(lead_id)
    reminder = await reminder_repo.get_by_lead_and_step(lead_id, step_id)

    if not lead or not reminder:
        await callback.answer("Step not found.")
        return

    await reminder_repo.update_status(reminder.id, "skipped")

    if lead.engagement_plan:
        updated_plan = []
        for step in lead.engagement_plan:
            if step.get("step_id") == step_id:
                step["status"] = "skipped"
            updated_plan.append(step)
        await lead_repo.update_lead(lead_id, engagement_plan=updated_plan)

    await activity_repo.create(
        LeadActivityModel(
            lead_id=lead_id,
            telegram_id=tg_id,
            activity_type="step_skip",
            content=f"Skipped step {step_id}",
        )
    )

    name = lead.prospect_name or f"Lead #{lead.id}"
    try:
        await callback.message.edit_text(
            f"\u23ED *Skipped: {name} - Step {step_id}*\n\nThis step has been marked as skipped.\n\nUse /leads to continue with other steps.",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="\U0001F4CB View Lead", callback_data=f"lead:view:{lead_id}")]
            ]),
        )
    except Exception:
        pass

    await callback.answer("Step skipped")


@router.callback_query(F.data.startswith("reminder:draft:"))
async def on_reminder_draft(
    callback: CallbackQuery,
    lead_repo: LeadRegistryRepo,
    reminder_repo: ScheduledReminderRepo,
) -> None:
    """Show full draft message for the step."""
    parts = callback.data.split(":")
    lead_id = int(parts[2])
    step_id = int(parts[3])

    lead = await lead_repo.get_by_id(lead_id)
    reminder = await reminder_repo.get_by_lead_and_step(lead_id, step_id)

    if not lead:
        await callback.answer("Lead not found.")
        return

    draft_text = reminder.draft_text if reminder else None
    step_desc = ""

    if lead.engagement_plan:
        for step in lead.engagement_plan:
            if step.get("step_id") == step_id:
                step_desc = step.get("description", "")
                if not draft_text:
                    draft_text = step.get("suggested_text", "")
                break

    name = lead.prospect_name or f"Lead #{lead.id}"

    if draft_text:
        text = (
            f"\U0001F4DD *Draft for {name} - Step {step_id}*\n\n"
            f"*Action:* {step_desc}\n\n*Suggested message:*\n{draft_text}"
        )
    else:
        text = (
            f"\U0001F4DD *Draft for {name} - Step {step_id}*\n\n"
            f"*Action:* {step_desc}\n\n_No draft message available for this step._"
        )

    try:
        await callback.message.edit_text(
            text,
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [
                    InlineKeyboardButton(text="\u2705 Done", callback_data=f"reminder:done:{lead_id}:{step_id}"),
                    InlineKeyboardButton(text="\u23F0 Snooze", callback_data=f"reminder:snooze:{lead_id}:{step_id}"),
                ],
                [InlineKeyboardButton(text="\U0001F4CB View Lead", callback_data=f"lead:view:{lead_id}")],
            ]),
        )
    except Exception:
        pass

    await callback.answer()
```

**Key implementation details:**

1. **Callback data parsing:** All handlers parse `reminder:{action}:{lead_id}:{step_id}` format matching Plan 01's keyboard generation
2. **Error handling:** All handlers wrap `edit_text` in try/except to handle "message is not modified" errors
3. **Callback acknowledgment:** All handlers call `callback.answer()` to prevent button spinner
4. **Dual-update pattern:** Done and Skip handlers update both `scheduled_reminders` table and `engagement_plan` JSONB
5. **Activity logging:** Done, Snooze, and Skip handlers log to `lead_activity_log` via `activity_repo.create()`
6. **View Lead button:** All confirmation messages include View Lead button for navigation
  </action>
  <verify>
1. File exists: `ls bot/handlers/reminders.py`
2. Contains router: grep for `router = Router`
3. Contains all 4 handlers with correct filter patterns:
   - `grep -c 'F.data.startswith("reminder:done:")' bot/handlers/reminders.py` returns 1
   - `grep -c 'F.data.startswith("reminder:snooze:")' bot/handlers/reminders.py` returns 1
   - `grep -c 'F.data.startswith("reminder:skip:")' bot/handlers/reminders.py` returns 1
   - `grep -c 'F.data.startswith("reminder:draft:")' bot/handlers/reminders.py` returns 1
4. Verify callback pattern matching with Plan 01:
   - Plan 01 generates: `callback_data=f"reminder:done:{lead_id}:{step_id}"`
   - Plan 02 filters: `F.data.startswith("reminder:done:")`
   - These patterns MUST match (done, snooze, skip, draft)
5. Contains activity logging: grep for `activity_repo.create`
6. Contains callback.answer: grep for `callback.answer`
7. No syntax errors: `python -m py_compile bot/handlers/reminders.py`
  </verify>
  <done>
reminders.py module exists with Done/Snooze/Skip/ViewDraft callback handlers that:
- Use filter patterns matching Plan 01's callback_data generation
- Update reminder status and engagement_plan JSONB (dual-update pattern)
- Log activity to lead_activity_log
- Handle message edit errors gracefully
- Always call callback.answer() to prevent button spinner
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire reminders router into main.py</name>
  <files>bot/main.py</files>
  <action>
Update `bot/main.py` to register the reminders router:

1. **Add import** in the handlers import section (around line 20):
```python
from bot.handlers import admin, leads, learn, progress, reminders, settings, start, stats, support, train
```

2. **Add router registration** in the "Register routers" section (around line 181), after leads router:
```python
dp.include_router(leads.router)
dp.include_router(reminders.router)  # Add this line
dp.include_router(admin.router)
```

The order matters: reminders.router should come after leads.router since both share callback patterns for lead:view:* but reminders.router only handles reminder:* callbacks.
  </action>
  <verify>
1. grep for `from bot.handlers import.*reminders` in main.py confirms import
2. grep for `reminders.router` in main.py confirms registration
3. No syntax errors: `python -m py_compile bot/main.py`
  </verify>
  <done>
main.py imports reminders module and registers reminders.router with the dispatcher.
  </done>
</task>

</tasks>

<verification>
1. reminders.py exists with Router and 4 callback handlers
2. Each handler uses correct filter pattern matching Plan 01's callback_data generation:
   - Plan 01 keyboard: `callback_data=f"reminder:{action}:{lead_id}:{step_id}"`
   - Plan 02 filters: `F.data.startswith("reminder:{action}:")`
3. Done handler: updates reminder to completed, updates engagement_plan, logs step_execution
4. Snooze handler: calls reminder_repo.snooze(), logs step_snooze
5. Skip handler: updates reminder to skipped, updates engagement_plan, logs step_skip
6. Draft handler: displays full draft with action buttons
7. All handlers call callback.answer() and wrap edit_text in try/except
8. main.py imports and registers reminders.router
9. No syntax errors in either file
</verification>

<success_criteria>
- Tapping Done marks the step complete in both scheduled_reminders and engagement_plan, logs activity
- Tapping Snooze delays the reminder 24h via snooze() method, logs activity
- Tapping Skip marks the step skipped in both tables, logs activity
- Tapping View Full Draft shows the complete suggested message with action buttons
- All activity types (step_execution, step_snooze, step_skip) are logged to lead_activity_log
- Callback buttons never hang (callback.answer() always called)
- Message edit errors are silently handled
- Callback filter patterns in reminders.py match callback_data patterns generated by plan_scheduler.py
</success_criteria>

<output>
After completion, create `.planning/phases/14-engagement-plan-execution/14-02-SUMMARY.md`
</output>
