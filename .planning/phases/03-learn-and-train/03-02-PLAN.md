---
phase: 03-learn-and-train
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/webapp/src/features/train/data/scenarios.ts
  - packages/webapp/src/features/train/hooks/useScenarioPool.ts
  - packages/webapp/src/features/train/hooks/useCountdown.ts
  - packages/webapp/src/features/train/components/DifficultyFilter.tsx
  - packages/webapp/src/features/train/components/ScenarioCard.tsx
  - packages/webapp/src/features/train/components/TimerInput.tsx
  - packages/webapp/src/features/train/components/ABBranching.tsx
  - packages/webapp/src/pages/Train.tsx
autonomous: true

must_haves:
  truths:
    - "User can select difficulty (Easy/Medium/Hard/Random) before starting a scenario"
    - "User sees a random scenario card with persona details and situation text"
    - "User sees an advisory countdown timer during response input"
    - "User can submit their response via deep link to bot"
    - "SecondaryButton A/B branching pattern is available for scenarios with branching options"
  artifacts:
    - path: "packages/webapp/src/features/train/data/scenarios.ts"
      provides: "Static fallback train pool from scenarios.json train_pool (20 scenarios)"
      contains: "TRAIN_POOL"
    - path: "packages/webapp/src/features/train/hooks/useScenarioPool.ts"
      provides: "Hook combining DB generated_scenarios with static fallback pool, filtered by difficulty"
      exports: ["useScenarioPool"]
    - path: "packages/webapp/src/features/train/hooks/useCountdown.ts"
      provides: "Clock-based countdown timer hook immune to background drift"
      exports: ["useCountdown"]
    - path: "packages/webapp/src/features/train/components/DifficultyFilter.tsx"
      provides: "Easy/Medium/Hard/Random selector buttons"
    - path: "packages/webapp/src/features/train/components/ScenarioCard.tsx"
      provides: "Persona details, difficulty badge, situation text display"
    - path: "packages/webapp/src/features/train/components/TimerInput.tsx"
      provides: "Countdown timer display with text area and submit via MainButton"
    - path: "packages/webapp/src/features/train/components/ABBranching.tsx"
      provides: "Reusable MainButton + SecondaryButton A/B decision pattern"
    - path: "packages/webapp/src/pages/Train.tsx"
      provides: "Train page with nested sub-routes (filter, scenario, practice)"
  key_links:
    - from: "packages/webapp/src/features/train/hooks/useScenarioPool.ts"
      to: "InsForge generated_scenarios table"
      via: "PostgREST query with difficulty filter"
      pattern: "from\\('generated_scenarios'\\)"
    - from: "packages/webapp/src/features/train/hooks/useScenarioPool.ts"
      to: "packages/webapp/src/features/train/data/scenarios.ts"
      via: "fallback when DB returns 0 rows"
      pattern: "TRAIN_POOL"
    - from: "packages/webapp/src/features/train/hooks/useCountdown.ts"
      to: "Date.now()"
      via: "clock-based timer immune to background drift"
      pattern: "Date\\.now"
    - from: "packages/webapp/src/features/train/components/TimerInput.tsx"
      to: "Telegram bot"
      via: "deep link for response submission"
      pattern: "t\\.me.*start=train"
---

<objective>
Build the Train mode page with difficulty selection, random scenario cards, countdown timer, and A/B branching pattern.

Purpose: TRAIN-01 through TRAIN-03 and TRAIN-06 -- users can filter scenarios by difficulty, see random scenario cards with persona details, practice with an advisory countdown timer, and experience A/B decision branching via native Telegram buttons.

Output: Static train pool data, scenario pool hook, countdown timer hook, 4 Train feature components, A/B branching pattern, and Train.tsx with nested sub-routes.
</objective>

<execution_context>
@/Users/dmytrolevin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dmytrolevin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-learn-and-train/03-RESEARCH.md
@packages/webapp/src/lib/queries.ts
@packages/webapp/src/types/tables.ts
@packages/webapp/src/types/enums.ts
@packages/webapp/src/types/constants.ts
@packages/webapp/src/app/Router.tsx
@packages/webapp/src/pages/Train.tsx
@packages/webapp/src/shared/hooks/useMainButton.ts
@packages/webapp/src/shared/hooks/useSecondaryButton.ts
@packages/webapp/src/shared/ui/index.ts
@data/scenarios.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Static train pool + scenario pool hook + countdown timer hook</name>
  <files>
    packages/webapp/src/features/train/data/scenarios.ts
    packages/webapp/src/features/train/hooks/useScenarioPool.ts
    packages/webapp/src/features/train/hooks/useCountdown.ts
  </files>
  <action>
    1. Create `features/train/data/scenarios.ts`:
       - Define `TrainScenario` interface: `id: string`, `category: string`, `difficulty: number (1|2|3)`, `persona: { name: string; role: string; company: string; background: string }`, `situation: string`, `scoringFocus: string[]`, `idealResponse: string`
       - Export `TRAIN_POOL: TrainScenario[]` containing ALL 20 scenarios from `data/scenarios.json` `train_pool.scenarios`
       - Convert snake_case JSON keys to camelCase TypeScript (scoring_focus -> scoringFocus, ideal_response -> idealResponse)
       - This is the static fallback when `generated_scenarios` table is empty (Pitfall 4)

    2. Create `features/train/hooks/useScenarioPool.ts`:
       - Accept optional `difficulty?: number` parameter (1=Easy, 2=Medium, 3=Hard, undefined=Random)
       - Query `generated_scenarios` table from InsForge, filtered by difficulty (omit filter for Random)
       - If DB returns data, map to `TrainScenario` interface
       - If DB returns 0 rows or errors, fall back to `TRAIN_POOL` filtered by difficulty
       - For Random (no difficulty), return all scenarios and let caller pick one randomly
       - Use `queryKeys.scenarios.pool(difficulty)` key
       - Query gated on `!!telegramId`
       - NOTE: This hook reads from `lib/queries.ts` which Plan 01 extends. If Plan 01 hasn't run yet, add the scenarios query keys inline or duplicate them. The key pattern is: `['scenarios', 'pool', difficulty]`

    3. Create `features/train/hooks/useCountdown.ts`:
       - Clock-based implementation (NOT setInterval-only) to avoid drift when app is backgrounded (Pitfall 6)
       - Store `startTime: number` (Date.now() when started) and `durationMs: number`
       - On every tick AND on visibility change, compute: `remaining = durationMs - (Date.now() - startTime)`
       - Export `UseCountdownReturn`: `secondsLeft: number`, `isRunning: boolean`, `isExpired: boolean`, `start: () => void`, `pause: () => void`, `reset: () => void`
       - Accept `initialSeconds: number` parameter
       - Timer is advisory (does NOT prevent any action on expiry -- per research Open Question 2)
       - Use `document.addEventListener('visibilitychange', ...)` to recalculate on tab/app return
       - Clean up interval and event listener in useEffect cleanup
  </action>
  <verify>
    Run `cd /Users/dmytrolevin/Downloads/GD_playground && pnpm --filter @deal-quest/webapp exec tsc --noEmit` -- no type errors.
    Verify TRAIN_POOL has 20 scenarios matching data/scenarios.json train_pool.
    Verify useCountdown uses Date.now()-based calculation, not pure setInterval counting.
  </verify>
  <done>
    Static train pool contains all 20 scenarios from scenarios.json. Scenario pool hook queries InsForge with static fallback. Countdown hook uses clock-based timing immune to background drift.
  </done>
</task>

<task type="auto">
  <name>Task 2: Train components + A/B branching + sub-routed page</name>
  <files>
    packages/webapp/src/features/train/components/DifficultyFilter.tsx
    packages/webapp/src/features/train/components/ScenarioCard.tsx
    packages/webapp/src/features/train/components/TimerInput.tsx
    packages/webapp/src/features/train/components/ABBranching.tsx
    packages/webapp/src/pages/Train.tsx
  </files>
  <action>
    1. Create `DifficultyFilter.tsx`:
       - Props: `selected: number | null` (null = Random), `onSelect: (difficulty: number | null) => void`
       - Render 4 buttons in a row: Easy (1), Medium (2), Hard (3), Random (null)
       - Use Button component with variant toggling (accent for selected, default for others)
       - Each button shows difficulty label + optional count of available scenarios (if provided)
       - 44px min touch target, gap-2 between buttons
       - "Random" button selects null difficulty

    2. Create `ScenarioCard.tsx`:
       - Props: `scenario: TrainScenario`
       - Card component containing:
         - Persona section: name (bold), role + company (subtitle), background (smaller text)
         - Difficulty badge using DIFFICULTY_LABELS constant + Badge component (color varies: success for Easy, warning for Medium, error for Hard)
         - Category tag (e.g., "Corporate Objection" formatted from snake_case category)
         - Situation text in a styled blockquote (italic, left border accent, bg-surface-secondary padding)
       - Responsive layout, readable on small mobile screens

    3. Create `TimerInput.tsx`:
       - Props: `initialSeconds: number` (default 120), `scenarioId: string`, `onSubmit: () => void`
       - Uses `useCountdown(initialSeconds)` hook
       - Displays countdown timer prominently: MM:SS format, large text, color shifts (accent -> warning at 30s -> error at 10s)
       - Text area for response (for future use -- currently display only, actual submission goes to bot)
       - Uses `useMainButton({ text: 'Practice in Bot', onClick: handleSubmit })` where handleSubmit creates deep link: `https://t.me/${import.meta.env.VITE_BOT_USERNAME}?start=train_${scenarioId}` and opens via `openLink` with `tryInstantView: false`
       - Timer starts automatically when component mounts
       - Timer is advisory only -- does NOT disable input or MainButton on expiry (just shows "Time's up!" text and turns timer red)

    4. Create `ABBranching.tsx`:
       - Reusable pattern for A/B sales decision branching (TRAIN-06)
       - Props: `optionA: { label: string; onSelect: () => void }`, `optionB: { label: string; onSelect: () => void }`, `isVisible?: boolean`
       - Uses `useMainButton` for Option A (right/primary position)
       - Uses `useSecondaryButton` for Option B (left position, already defaulted in hook)
       - When either is selected, both buttons hide and the selected option is confirmed
       - TRAIN-06 integration point: ABBranching is rendered in the Train.tsx scenario step when the current scenario has a `branchingOptions` field (e.g., `scenario.branchingOptions?: { optionA: string; optionB: string }`). Currently no scenarios in TRAIN_POOL have this field, so ABBranching will not render for any existing scenario. The component is infrastructure-ready -- once branching scenarios are added to the pool (either static or via generated_scenarios), ABBranching will activate automatically.
       - Export the component so it can be imported by any scenario view that needs A/B branching

    5. Update `Train.tsx`:
       - Replace stub content with a step-based state machine: `step: 'filter' | 'scenario'`
       - State: `selectedDifficulty`, `currentScenario`, `step`
       - When step is 'filter': render DifficultyFilter + "Start Training" Button
       - When step is 'scenario': render ScenarioCard + TimerInput. Additionally, if `currentScenario.branchingOptions` exists, render ABBranching below ScenarioCard with optionA/optionB labels from the scenario's branchingOptions field. This is the concrete integration point for TRAIN-06 -- the conditional render means ABBranching only appears for branching-enabled scenarios.
       - On "Start Training": pick a random scenario from the filtered pool (using useScenarioPool), set step to 'scenario'
       - "Back to filters" handler: reset step to 'filter'
       - Use useScenarioPool(selectedDifficulty) to get the pool

    Design notes:
    - Follow features/train/components/ folder structure
    - Use existing UI components: Card, Badge, Button, Skeleton from @/shared/ui
    - Tailwind classes consistent with existing pages (space-y-4, px-4, pt-4)
    - 44px minimum touch targets
    - Import Difficulty type from @deal-quest/shared where applicable
  </action>
  <verify>
    Run `cd /Users/dmytrolevin/Downloads/GD_playground && pnpm --filter @deal-quest/webapp exec tsc --noEmit` -- no type errors.
    Run `cd /Users/dmytrolevin/Downloads/GD_playground && pnpm --filter @deal-quest/webapp build` -- production build succeeds.
    Verify Train.tsx renders DifficultyFilter and transitions to ScenarioCard + TimerInput.
    Verify ABBranching.tsx uses both useMainButton and useSecondaryButton.
    Verify Train.tsx has a conditional render for ABBranching gated on `currentScenario.branchingOptions` (grep for "branchingOptions" in Train.tsx).
  </verify>
  <done>
    Train page shows difficulty selection, renders random scenario card with persona details and countdown timer. MainButton deep links to bot for practice. ABBranching component provides reusable A/B decision pattern using native Telegram buttons, wired into Train.tsx's scenario step via branchingOptions conditional. Build passes cleanly.
  </done>
</task>

</tasks>

<verification>
- `pnpm --filter @deal-quest/webapp build` succeeds with no errors
- Train.tsx has difficulty filter -> scenario card flow
- TRAIN_POOL has 20 scenarios matching data/scenarios.json
- useCountdown uses clock-based calculation with visibilitychange listener
- useScenarioPool falls back to TRAIN_POOL when DB is empty
- ABBranching uses both MainButton and SecondaryButton hooks
- Train.tsx conditionally renders ABBranching when scenario has branchingOptions
- Timer displays MM:SS and color-shifts at 30s and 10s thresholds
</verification>

<success_criteria>
- TRAIN-01: Random scenario card shows persona name, role, company, difficulty badge, and situation text
- TRAIN-02: Countdown timer displays advisory time, text area present, submit via MainButton deep link
- TRAIN-03: Difficulty filter lets user choose Easy/Medium/Hard/Random before starting
- TRAIN-06: ABBranching component wires MainButton + SecondaryButton for A/B sales decisions, integrated in Train.tsx scenario step via branchingOptions conditional (infrastructure-ready, activates when branching scenarios exist)
- Production build passes with no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-learn-and-train/03-02-SUMMARY.md`
</output>
